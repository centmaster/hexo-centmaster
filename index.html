<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/hexo-centmaster/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/hexo-centmaster/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/hexo-centmaster/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/hexo-centmaster/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/centmaster/hexo-centmaster/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo-centmaster/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/centmaster/hexo-centmaster/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo-centmaster/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo-centmaster/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo-centmaster/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/mv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/mv/" itemprop="url">mv*</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T22:02:28+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对于MVC、MVP、MVVM三种模式的理解"><a href="#对于MVC、MVP、MVVM三种模式的理解" class="headerlink" title="对于MVC、MVP、MVVM三种模式的理解"></a>对于MVC、MVP、MVVM三种模式的理解</h3><p>mv*本质都是处理model层和vision层之间的关系，数据的流动方式。</p>
<p><strong>数据驱动</strong></p>
<p>在MVVM中，以前开发模式中必须先处理业务数据，然后根据的数据变化，去获取UI的引用然后更新UI，通过也是通过UI来获取用户输入，而在MVVM中，数据和业务逻辑处于一个独立的View Model中，ViewModel只要关注数据和业务逻辑，不需要和UI或者控件打交道。由数据自动去驱动UI去自动更新UI，UI的改变又同时自动反馈到数据，数据成为主导因素，这样使得在业务逻辑处理只要关心数据，方便而且简单很多。</p>
<p><strong>低耦合度</strong><br>MVVM模式中，数据是独立于UI的，ViewModel只负责处理和提供数据，UI想怎么处理数据都由UI自己决定，ViewModel 不涉及任何和UI相关的事也不持有UI控件的引用，即使控件改变（TextView 换成 EditText）ViewModel 几乎不需要更改任何代码，专注自己的数据处理就可以了，如果是MVP遇到UI更改，就可能需要改变获取UI的方式，改变更新UI的接口，改变从UI上获取输入的代码，可能还需要更改访问UI对象的属性代码等等。</p>
<p><strong>更新 UI</strong><br>在MVVM中，我们可以在工作线程中直接修改View Model的数据（只要数据是线程安全的），剩下的数据绑定框架帮你搞定，很多事情都不需要你去关心。</p>
<p><strong>团队协作</strong>！<br>MVVM的分工是非常明显的，由于View和View Model之间是松散耦合的。一个是处理业务和数据，一个是专门的UI处理。完全有两个人分工来做，一个做UI（xml 和 Activity）一个写ViewModel，效率更高。</p>
<p><strong>可复用性</strong><br>一个View Model复用到多个View中，同样的一份数据，用不同的UI去做展示，对于版本迭代频繁的UI改动，只要更换View层就行，对于如果想在UI上的做AbTest 更是方便的多。</p>
<p><strong>单元测试</strong><br>View Model里面是数据和业务逻辑，View中关注的是UI，这样的做测试是很方便的，完全没有彼此的依赖，不管是UI的单元测试还是业务逻辑的单元测试，都是低耦合的。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">mvvm mvp  mvc区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/vue-scopecss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/vue-scopecss/" itemprop="url">vue-scopecss</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T22:02:18+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="vue中socpe-css怎么实现的"><a href="#vue中socpe-css怎么实现的" class="headerlink" title="vue中socpe css怎么实现的"></a>vue中socpe css怎么实现的</h4><p>(源码<a href="https://github.com/AlloyTeam/AlloyTouch/blob/2b9f8ca35ab954c3a9a3ebb747e88c09503a16fa/example/scoped_css/index.html">https://github.com/AlloyTeam/AlloyTouch/blob/2b9f8ca35ab954c3a9a3ebb747e88c09503a16fa/example/scoped_css/index.html</a>)</p>
<p>每个域中的dom都会自己添加自定义的data-id的属性，然后css中添加[data-id]，会匹配这些dom</p>
<p>动态的把css变成.example[_v-f3f3eg9].  </p>
<ol>
<li>在同一组件内，你能同时用有作用域和无作用域的样式：</li>
<li>父组件的有作用域的CSS和子组件的有作用域的CSS将同时影响子组件。</li>
<li>有作用域的样式对其他部分没有影响。</li>
<li><strong>有作用域限定的样式不排除类的需要</strong>. 由于浏览器渲染方式支持多种不同的CSS选择器，加了作用域的 <code>p { color: red }</code> 会慢好多倍 （即，和属性选择器组合时候的时候）。如果你用类或者id选择器，比如 <code>.example { color: red }</code> ，你就能消除性能损失。<a href="http://stevesouders.com/efws/css-selectors/csscreate.php" target="_blank" rel="external">这里有个练习场</a> ，你可以比较测试下其中的差异。</li>
<li><strong>在递归组件中小心后代选择器！</strong> 对于 CSS 规则的选择器 <code>.a .b</code>，如果匹配 <code>.a</code> 的元素内包含一个递归子组件，那么子组件中所有包含 <code>.b</code> 的元素都会被匹配到。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">scoper</span>(<span class="params">css</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> id = generateID();</div><div class="line">        <span class="keyword">var</span> prefix = <span class="string">"#"</span> + id;</div><div class="line">        css = css.replace(<span class="regexp">/\/\*[\s\S]*?\*\//g</span>, <span class="string">''</span>);  <span class="comment">//把样式放到一行</span></div><div class="line">        <span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"([^\r\n,&#123;&#125;]+)(,(?=[^&#125;]*&#123;)|\s*&#123;)"</span>, <span class="string">"g"</span>); <span class="comment">//</span></div><div class="line">        css = css.replace(re, <span class="function"><span class="keyword">function</span>(<span class="params">g0, g1, g2</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (g1.match(<span class="regexp">/^\s*(@media|@keyframes|to|from|@font-face)/</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> g1 + g2;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (g1.match(<span class="regexp">/:scope/</span>)) &#123;</div><div class="line">                g1 = g1.replace(<span class="regexp">/([^\s]*):scope/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">h0, h1</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (h1 === <span class="string">""</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="string">"&gt; *"</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="string">"&gt; "</span> + h1;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            g1 = g1.replace(<span class="regexp">/^(\s*)/</span>, <span class="string">"$1"</span> + prefix + <span class="string">" "</span>);</div><div class="line">            <span class="keyword">return</span> g1 + g2;</div><div class="line">        &#125;);</div><div class="line">        addStyle(css,id+<span class="string">"-style"</span>);</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generateID</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> id =  (<span class="string">"scoped"</span>+ <span class="built_in">Math</span>.random()).replace(<span class="string">"0."</span>,<span class="string">""</span>);</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.getElementById(id))&#123;</div><div class="line">            <span class="keyword">return</span> generateID();</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> id;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> isIE = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> undef,</div><div class="line">            v = <span class="number">3</span>,</div><div class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),</div><div class="line">            all = div.getElementsByTagName(<span class="string">'i'</span>);</div><div class="line">        <span class="keyword">while</span> (</div><div class="line">            div.innerHTML = <span class="string">'&lt;!--[if gt IE '</span> + (++v) + <span class="string">']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'</span>,</div><div class="line">                all[<span class="number">0</span>]</div><div class="line">            );</div><div class="line">        <span class="keyword">return</span> v &gt; <span class="number">4</span> ? v : undef;</div><div class="line">    &#125;());</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params">cssText, id</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> d = <span class="built_in">document</span>,</div><div class="line">            someThingStyles = d.createElement(<span class="string">'style'</span>);</div><div class="line">        d.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(someThingStyles);</div><div class="line">        someThingStyles.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</div><div class="line">        someThingStyles.setAttribute(<span class="string">'id'</span>, id);</div><div class="line">        <span class="keyword">if</span> (isIE) &#123;</div><div class="line">            someThingStyles.styleSheet.cssText = cssText;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            someThingStyles.textContent = cssText;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">window</span>.scoper = scoper;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = scoper(<span class="string">"h1 &#123;\</span></div><div class="line"><span class="string">                   color:red;\</span></div><div class="line"><span class="string">                /*color: #0079ff;*/\</span></div><div class="line"><span class="string">                    &#125;\</span></div><div class="line"><span class="string">            \</span></div><div class="line"><span class="string">                    /*  h2 &#123;\</span></div><div class="line"><span class="string">                    color:green\</span></div><div class="line"><span class="string">                    &#125;*/"</span>);</div><div class="line"><span class="built_in">document</span>.body.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">0</span>].setAttribute(<span class="string">"id"</span>,id);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/vue-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/vue-router/" itemprop="url">vue-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T22:01:57+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue-router源码分析"><a href="#vue-router源码分析" class="headerlink" title="vue-router源码分析"></a>vue-router源码分析</h2><p>[TOC]</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>先来看整体的目录结构</p>
<p>src</p>
<p>   |—components</p>
<p>​    |—link.js</p>
<p>​    |—view.js</p>
<p>​    |—history</p>
<p>​    |—base.js</p>
<p>​    |—util</p>
<p>​     |—route.js</p>
<p>​    |—index.js                            入口文件</p>
<p>​    |—create-matcher.js                    创建match匹配函数</p>
<p>​    |—create-route-map.js                    匹配路由纪录的map</p>
<p>​    |—install.js                            插件的install方法        </p>
<p>如果想看具体完整的目录在这里：<a href="https://github.com/vuejs/vue-router/tree/dev/src">https://github.com/vuejs/vue-router/tree/dev/src</a></p>
<p>我们指对于源码有个宏观的掌握，具体的细节就不一一贴出来，都可以在目录文件中找到</p>
<h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 插件</span></div><div class="line"><span class="comment">// 安装 &lt;router-view&gt; and &lt;router-link&gt; 组件</span></div><div class="line"><span class="comment">// 且给当前应用下所有的组件都注入 $router and $route 对象</span></div><div class="line">Vue.use(VueRouter)</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义各个路由下使用的组件，简称路由组件</span></div><div class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;home&lt;/div&gt;'</span> &#125;</div><div class="line"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</div><div class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. 创建 VueRouter 实例 router</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  base: __dirname,</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Home &#125;,</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;,</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建 启动应用</span></div><div class="line"><span class="comment">// 一定要确认注入了 router </span></div><div class="line"><span class="comment">// 在 &lt;router-view&gt; 中将会渲染路由组件</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  router,</div><div class="line">  template: <span class="string">`</span></div><div class="line"><span class="string">    &lt;div id="app"&gt;</span></div><div class="line"><span class="string">      &lt;h1&gt;Basic&lt;/h1&gt;</span></div><div class="line"><span class="string">      &lt;ul&gt;</span></div><div class="line"><span class="string">        &lt;li&gt;&lt;router-link to="/"&gt;/&lt;/router-link&gt;&lt;/li&gt;</span></div><div class="line"><span class="string">        &lt;li&gt;&lt;router-link to="/foo"&gt;/foo&lt;/router-link&gt;&lt;/li&gt;</span></div><div class="line"><span class="string">        &lt;li&gt;&lt;router-link to="/bar"&gt;/bar&lt;/router-link&gt;&lt;/li&gt;</span></div><div class="line"><span class="string">        &lt;router-link tag="li" to="/bar"&gt;/bar&lt;/router-link&gt;</span></div><div class="line"><span class="string">      &lt;/ul&gt;</span></div><div class="line"><span class="string">      &lt;router-view class="view"&gt;&lt;/router-view&gt;</span></div><div class="line"><span class="string">    &lt;/div&gt;</span></div><div class="line"><span class="string">  `</span></div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<p>根据入口文件我们可以把本篇文章分为四部分去讲。1.插件 2.实例化vueRouter 3.实例化Vue 4.link和view</p>
<h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>我们可以看到利用 Vue.js 提供的插件机制 <code>.use(plugin)</code> 来安装 <code>VueRouter</code>，而这个插件机制则会调用该 <code>plugin</code> 对象的 <code>install</code> 方法（当然如果该 <code>plugin</code> 没有该方法的话会把 <code>plugin</code> 自身作为函数来调用）</p>
<p>在install.js中我们可以看到vue插件的经典写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; install &#125; <span class="keyword">from</span> <span class="string">'./install'</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">import</span> &#123; inBrowser, supportsHistory &#125; <span class="keyword">from</span> <span class="string">'./util/dom'</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 赋值 install</span></div><div class="line">VueRouter.install = install</div><div class="line"></div><div class="line"><span class="comment">// 自动使用插件</span></div><div class="line"><span class="keyword">if</span> (inBrowser &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</div><div class="line">  <span class="built_in">window</span>.Vue.use(VueRouter)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以继续在目录中查找install.js，查阅发现，主要逻辑将$route,$router注入vue原型中。所有vue组件都是vue的实例，所以都可以访问到。</p>
<h4 id="实例化VueRouter"><a href="#实例化VueRouter" class="headerlink" title="实例化VueRouter"></a>实例化VueRouter</h4><p>在入口文件中，首先要实例化一个 <code>VueRouter</code> ，然后将其传入 Vue 实例的 <code>options</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">import</span> &#123; createMatcher &#125; <span class="keyword">from</span> <span class="string">'./create-matcher'</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">  <span class="keyword">constructor</span> (options: RouterOptions = &#123;&#125;) &#123;</div><div class="line">    <span class="keyword">this</span>.app = <span class="literal">null</span></div><div class="line">    <span class="keyword">this</span>.options = options</div><div class="line">    <span class="keyword">this</span>.beforeHooks = []</div><div class="line">    <span class="keyword">this</span>.afterHooks = []</div><div class="line">    <span class="comment">// 创建 match 匹配函数</span></div><div class="line">    <span class="keyword">this</span>.match = createMatcher(options.routes || [])</div><div class="line">    <span class="comment">// 根据 mode 实例化具体的 History</span></div><div class="line">    <span class="keyword">let</span> mode = options.mode || <span class="string">'hash'</span></div><div class="line">    <span class="keyword">this</span>.fallback = mode === <span class="string">'history'</span> &amp;&amp; !supportsHistory</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fallback) &#123;</div><div class="line">      mode = <span class="string">'hash'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!inBrowser) &#123;</div><div class="line">      mode = <span class="string">'abstract'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.mode = mode</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (mode) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'history'</span>:</div><div class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>, options.base)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> <span class="string">'hash'</span>:</div><div class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>, options.base, <span class="keyword">this</span>.fallback)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">case</span> <span class="string">'abstract'</span>:</div><div class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>)</div><div class="line">        <span class="keyword">break</span></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里引出两个文件create-matcher.js和create-route-map.js。前者根据传入的routes生成对应的路由 map，然后直接返回了 <code>match</code> 匹配函数。后者根据用户路由配置对象生成普通的根据 <code>path</code> 来对应的路由记录以及根据 <code>name</code>来对应的路由记录的 map。</p>
<p>然后继续往下，非常重要的一步就是实例话history，在history目录下有base.js是history的基类。至此实例化VueRouter完成。</p>
<h4 id="实例化Vue"><a href="#实例化Vue" class="headerlink" title="实例化Vue"></a>实例化Vue</h4><p>在Vue实例化过程中，将router传入options。</p>
<p>创建一个 Vue 实例，对应的 <code>beforeCreate</code> 钩子就会被调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">  Vue.mixin(&#123;</div><div class="line">    beforeCreate () &#123;</div><div class="line">      <span class="comment">// 判断是否有 router</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options.router) &#123;</div><div class="line">      	<span class="comment">// 赋值 _router</span></div><div class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</div><div class="line">        <span class="comment">// 初始化 init</span></div><div class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</div><div class="line">        <span class="comment">// 定义响应式的 _route 对象</span></div><div class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>实例化过程中值得关注的两件事<code>router.init</code> 和 定义响应式的 <code>_route</code> 对象。router.init在index.js文件中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; install &#125; <span class="keyword">from</span> <span class="string">'./install'</span></div><div class="line"><span class="keyword">import</span> &#123; createMatcher &#125; <span class="keyword">from</span> <span class="string">'./create-matcher'</span></div><div class="line"><span class="keyword">import</span> &#123; HashHistory, getHash &#125; <span class="keyword">from</span> <span class="string">'./history/hash'</span></div><div class="line"><span class="keyword">import</span> &#123; HTML5History, getLocation &#125; <span class="keyword">from</span> <span class="string">'./history/html5'</span></div><div class="line"><span class="keyword">import</span> &#123; AbstractHistory &#125; <span class="keyword">from</span> <span class="string">'./history/abstract'</span></div><div class="line"><span class="keyword">import</span> &#123; inBrowser, supportsHistory &#125; <span class="keyword">from</span> <span class="string">'./util/dom'</span></div><div class="line"><span class="keyword">import</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">'./util/warn'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">  init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">    <span class="keyword">this</span>.app = app</div><div class="line"></div><div class="line">    <span class="keyword">const</span> history = <span class="keyword">this</span>.history</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History) &#123;</div><div class="line">      history.transitionTo(getLocation(history.base))</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HashHistory) &#123;</div><div class="line">      history.transitionTo(getHash(), () =&gt; &#123;</div><div class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</div><div class="line">          history.onHashChange()</div><div class="line">        &#125;)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.app._route = route</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>可以看到初始化主要就是给 <code>app</code> 赋值，针对于 <code>HTML5History</code> 和 <code>HashHistory</code> 特殊处理，因为在这两种模式下才有可能存在进入时候的不是默认页，需要根据当前浏览器地址栏里的 <code>path</code> 或者 <code>hash</code> 来激活对应的路由，此时就是通过调用 <code>transitionTo</code> 来达到目的；而且此时还有个注意点是针对于 <code>HashHistory</code> 有特殊处理，为什么不直接在初始化 <code>HashHistory</code> 的时候监听 <code>hashchange</code> 事件呢？这个是为了修复<a href="https://github.com/vuejs/vue-router/issues/725">vuejs/vue-router#725</a>这个 bug 而这样做的，简要来说就是说如果在 <code>beforeEnter</code> 这样的钩子函数中是异步的话，<code>beforeEnter</code> 钩子就会被触发两次，原因是因为在初始化的时候如果此时的 <code>hash</code> 值不是以 <code>/</code>开头的话就会补上 <code>#/</code>，这个过程会触发 <code>hashchange</code> 事件，所以会再走一次生命周期钩子，也就意味着会再次调用 <code>beforeEnter</code> 钩子函数。</p>
<h4 id="router-link-和-router-view-组件"><a href="#router-link-和-router-view-组件" class="headerlink" title="router-link 和 router-view 组件"></a>router-link 和 router-view 组件</h4><p>router-view在view.js文件中。可以看到逻辑还是比较简单的，拿到匹配的组件进行渲染就可以了。同文件夹中的link.js用来构造router-link.可以看出 <code>router-link</code> 组件就是在其点击的时候根据设置的 <code>to</code> 的值去调用 <code>router</code> 的 <code>push</code> 或者 <code>replace</code> 来更新路由的，同时呢，会检查自身是否和当前路由匹配（严格匹配和包含匹配）来决定自身的 <code>activeClass</code> 是否添加</p>
<h4 id="Router-总结"><a href="#Router-总结" class="headerlink" title="Router 总结"></a>Router 总结</h4><h5 id="Vuex-router-预备知识"><a href="#Vuex-router-预备知识" class="headerlink" title="Vuex-router 预备知识"></a>Vuex-router 预备知识</h5><h6 id="利用H5History-API-无刷新更改地址栏"><a href="#利用H5History-API-无刷新更改地址栏" class="headerlink" title="利用H5History API 无刷新更改地址栏"></a>利用H5History API 无刷新更改地址栏</h6><p>浏览器历史记录可以看作一个「栈」。</p>
<h6 id="pushState-state-“My-Profile”-“-profile-“-方法"><a href="#pushState-state-“My-Profile”-“-profile-“-方法" class="headerlink" title="pushState(state, “My Profile”, “/profile/“) 方法"></a>pushState(state, “My Profile”, “/profile/“) 方法</h6><p>当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求该URL</p>
<p>执行<code>pushState</code>函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。它可以接收三个参数，按顺序分别为：</p>
<ol>
<li>一个对象或者字符串，用于描述新记录的一些特性。这个参数会被一并添加到历史记录中，以供以后使用。这个参数是开发者根据自己的需要自由给出的。</li>
<li>一个字符串，代表新页面的标题。当前基本上所有浏览器都会忽略这个参数。</li>
<li>一个字符串，代表新页面的相对地址。</li>
</ol>
<h6 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h6><p>当用户点击浏览器的「前进」、「后退」按钮时，就会触发<code>popstate</code>事件。你可以监听这一事件，从而作出反应。</p>
<h6 id="replaceState-方法"><a href="#replaceState-方法" class="headerlink" title="replaceState 方法"></a>replaceState 方法</h6><p>有时，你希望不添加一个新记录，而是替换当前的记录（比如对网站的 landing page），则可以使用<code>replaceState</code>方法。这个方法和<code>pushState</code>的参数完全一样。</p>
<h6 id="利用浏览器的hash特点"><a href="#利用浏览器的hash特点" class="headerlink" title="利用浏览器的hash特点"></a>利用浏览器的hash特点</h6><p>#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。它具有如下特点：</p>
<ul>
<li><p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面</p>
</li>
<li><p>可以为hash的改变添加监听事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&quot;hashchange&quot;, funcRef, false)</div></pre></td></tr></table></figure>
</li>
<li><p>每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录</p>
</li>
</ul>
<h6 id="HashHistory-push"><a href="#HashHistory-push" class="headerlink" title="HashHistory.push()"></a>HashHistory.push()</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.location.hash = route.fullPath</div></pre></td></tr></table></figure>
<h5 id="vue-router的具体实现的比较（https-zhuanlan-zhihu-com-p-27588422）"><a href="#vue-router的具体实现的比较（https-zhuanlan-zhihu-com-p-27588422）" class="headerlink" title="vue-router的具体实现的比较（https://zhuanlan.zhihu.com/p/27588422）"></a>vue-router的具体实现的比较（<a href="https://zhuanlan.zhihu.com/p/27588422）" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27588422）</a></h5><p>“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p>
<ul>
<li>利用URL中的hash（“#”）</li>
<li>利用History interface在 HTML5中新增的方法</li>
</ul>
<h6 id="利用hash"><a href="#利用hash" class="headerlink" title="利用hash"></a>利用hash</h6><p>从设置路由改变到视图更新的流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() -！！！-&gt; &#123;app._route = route&#125; --&gt; vm.render()</div></pre></td></tr></table></figure>
<p>在感叹号这一步过程中，updateRoute的回调函数触发了mixin（应该就是vue和router的mix）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</div><div class="line">  Vue.mixin(&#123;</div><div class="line">    beforeCreate () &#123;</div><div class="line">      <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</div><div class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</div><div class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</div><div class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</div><div class="line">      &#125;</div><div class="line">      registerInstance(<span class="keyword">this</span>, <span class="keyword">this</span>)</div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在beforeCreate钩子中通过Vue.util.defineReactive()定义了响应式的_route属性。所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。</p>
<p>repalce和push  同理，区别在于替换。另外：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setupListeners ()  <span class="comment">//用来监听手动替换的hash</span></div></pre></td></tr></table></figure>
<h6 id="利用History"><a href="#利用History" class="headerlink" title="利用History"></a>利用History</h6><p>原理基本一样。不再赘述，方法替换就好。</p>
<h6 id="调用history-pushState-相比于直接修改hash主要有以下优势："><a href="#调用history-pushState-相比于直接修改hash主要有以下优势：" class="headerlink" title="调用history.pushState()相比于直接修改hash主要有以下优势："></a>调用history.pushState()相比于直接修改hash主要有以下优势：</h6><ul>
<li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li>
<li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>
<li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li>
<li>pushState可额外设置title属性供后续使用</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/v-dom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/v-dom/" itemprop="url">v-dom</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T22:01:48+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="vue1利用DocumentFragment渲染"><a href="#vue1利用DocumentFragment渲染" class="headerlink" title="vue1利用DocumentFragment渲染"></a>vue1利用DocumentFragment渲染</h4><p>_compile 部分分为三步 transclude  compile    link</p>
<ol>
<li><p>transclude<br>transclude的意思是内嵌，这个步骤会把你template里给出的模板转换成一段dom，然后抽取出你el选项指定的dom里的内容（即子元素，因为模板里可能有slot），把这段模板dom嵌入到el里面去，当然，如果replace为true，那他就是直接替换el，而不是内嵌。我们大概明白transclude这个名字的意义了，但其实更关键的是把template转换为dom的过程（如<code>&lt;p&gt;&lt;p&gt;</code>字符串转为真正的段落元素），这里为后面的编译准备好了dom。</p>
<p>说白了就是把字符串转换成dom</p>
</li>
<li><p>compile<br>compile的的过程具体就是<strong>遍历模板解析出模板里的指令</strong>。更精确的说是解析后生成了指令描述对象。<br>同时，compile函数是一个高阶函数，他执行完成之后的返回值是另一个函数：link，所以compile函数的第一个阶段是编译，返回出去的这个函数完成另一个阶段：link。</p>
</li>
<li><p>link<br>compile阶段将指令解析成为指令描述对象(descriptor)，闭包在了link函数里，link函数会把descriptor传入Directive构造函数，创建出真正的指令实例。此外link函数是作为参数传入linkAndCaptrue中的，后者负责执行link，同时取出这些新生成的指令，先按照指令的预置的优先级从高到低排好顺序，然后遍历指令执行指令的_bind方法，这个方法会为指令创建watcher，并计算表达式的值，完成前面描述的依赖收集。并最后执行对应指令的bind和update方法，使指令生效、界面更新。</p>
</li>
</ol>
<p>为什么dom的编译要分成compile和link两个phase。</p>
<p>在组件的多个实例、v-for数组等场合，我们会出现同一个段模板要绑定不同的数据然后分发到dom里面去的需求。这也是mvvm性能考量的主要场景：大数据量的重复渲染生成。而重复渲染的模板是一致的，不一致的是他们需要绑定的数据，因此compile阶段找出指令的过程是不用重复计算的，只需要link函数（和里面闭包的指令)，而模板生成的dom使用原生的cloneNode方法即可复制出一份新的dom。现在，复制出的新dom+ link+具体的数据即可完成渲染，所以分离compile、并缓存link使得Vue在渲染时避免大量重复的性能消耗。</p>
<h4 id="vue2虚拟dom的解析"><a href="#vue2虚拟dom的解析" class="headerlink" title="vue2虚拟dom的解析"></a>vue2虚拟dom的解析</h4><p>和react几乎一样</p>
<p><code>Vue</code>在<code>2.0</code>版本也引入了<code>vdom</code>。其<code>vdom</code>算法是基于<a href="https://github.com/snabbdom/snabbdom">snabbdom算法</a>所做的修改。</p>
<p>Render—&gt;createElement—&gt;diff—&gt;patch</p>
<p>这是vdom的流程，让我看看每一步都做了什么</p>
<h5 id="首先是vnode的定义"><a href="#首先是vnode的定义" class="headerlink" title="首先是vnode的定义"></a>首先是vnode的定义</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (</div><div class="line">    tag?: string,</div><div class="line">    data?: VNodeData,         // 关于这个节点的data值，包括attrs,style,hook等</div><div class="line">    children?: ?Array&lt;VNode&gt;, // 子vdom节点</div><div class="line">    text?: string,        // 文本内容</div><div class="line">    elm?: Node,           // 真实的dom节点</div><div class="line">    context?: Component,  // 创建这个vdom的上下文</div><div class="line">    componentOptions?: VNodeComponentOptions</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.tag = tag</div><div class="line">    <span class="keyword">this</span>.data = data</div><div class="line">    <span class="keyword">this</span>.children = children</div><div class="line">    <span class="keyword">this</span>.text = text</div><div class="line">    <span class="keyword">this</span>.elm = elm</div><div class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>.context = context</div><div class="line">    <span class="keyword">this</span>.functionalContext = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</div><div class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</div><div class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></div><div class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></div><div class="line">  <span class="comment">/* istanbul ignore next */</span></div><div class="line">  get child (): Component | <span class="keyword">void</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个<code>vnode</code>都映射到一个真实的<code>dom</code>节点上。其中几个比较重要的属性:</p>
<ul>
<li><code>tag</code> 属性即这个<code>vnode</code>的标签属性</li>
<li><code>data</code> 属性包含了最后渲染成真实<code>dom</code>节点后，节点上的<code>class</code>,<code>attribute</code>,<code>style</code>以及绑定的事件</li>
<li><code>children</code> 属性是<code>vnode</code>的子节点</li>
<li><code>text</code> 属性是文本属性</li>
<li><code>elm</code> 属性为这个<code>vnode</code>对应的真实<code>dom</code>节点</li>
<li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率，后文有讲解</li>
</ul>
<p><strong>在当oldVnode不存在的时候</strong>，这个时候是<code>root节点</code>初始化的过程，因此调用了<code>createElm(vnode, insertedVnodeQueue, parentElm, refElm)</code>方法去创建一个新的节点。<strong>而当oldVnode是vnode且sameVnode(oldVnode, vnode)2个节点的基本属性相同</strong>，那么就进入了2个节点的<code>diff</code>过程。</p>
<h5 id="diff过程"><a href="#diff过程" class="headerlink" title="diff过程"></a>diff过程</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</div><div class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</div><div class="line">    <span class="keyword">const</span> ch = vnode.children</div><div class="line">    <span class="comment">// 如果vnode没有文本节点</span></div><div class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</div><div class="line">      <span class="comment">// 如果oldVnode的children属性存在且vnode的属性也存在</span></div><div class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</div><div class="line">        <span class="comment">// updateChildren，对子节点进行diff</span></div><div class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</div><div class="line">        <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容</span></div><div class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</div><div class="line">        <span class="comment">// 然后将vnode的children添加进去</span></div><div class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</div><div class="line">        <span class="comment">// 删除elm下的oldchildren</span></div><div class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</div><div class="line">        <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点</span></div><div class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</div><div class="line">      <span class="comment">// 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素</span></div><div class="line">      nodeOps.setTextContent(elm, vnode.text)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这其中的<code>diff</code>过程中又分了好几种情况，<code>oldCh</code>为<code>oldVnode</code>的子节点，<code>ch</code>为<code>Vnode</code>的子节点：</p>
<ol>
<li>首先进行文本节点的判断，若<code>oldVnode.text !== vnode.text</code>，那么就会直接进行文本节点的替换；</li>
<li>在<code>vnode</code>没有文本节点的情况下，进入子节点的<code>diff</code>；</li>
<li>当<code>oldCh</code>和<code>ch</code>都存在且不相同的情况下，调用<code>updateChildren</code>对子节点进行<code>diff</code>；</li>
<li>若<code>oldCh</code>不存在，<code>ch</code>存在，首先清空<code>oldVnode</code>的文本节点，同时调用<code>addVnodes</code>方法将<code>ch</code>添加到<code>elm</code>真实<code>dom</code>节点当中；</li>
<li>若<code>oldCh</code>存在，<code>ch</code>不存在，则删除<code>elm</code>真实节点下的<code>oldCh</code>子节点；</li>
<li>若<code>oldVnode</code>有文本节点，而<code>vnode</code>没有，那么就清空这个文本节点。</li>
</ol>
<p>其中其他的都比较容易理解，我们要着重看一眼第三步的细节，也就是updateChildren过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</div><div class="line">    <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></div><div class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></div><div class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</div><div class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</div><div class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></div><div class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</div><div class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</div><div class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</div><div class="line">    </div><div class="line">    <span class="comment">// 直到oldCh或者newCh被遍历完后跳出循环</span></div><div class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</div><div class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</div><div class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</div><div class="line">        oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</div><div class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</div><div class="line">        oldStartVnode = oldCh[++oldStartIdx]</div><div class="line">        newStartVnode = newCh[++newStartIdx]</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</div><div class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</div><div class="line">        oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">        newEndVnode = newCh[--newEndIdx]</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></div><div class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</div><div class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</div><div class="line">        oldStartVnode = oldCh[++oldStartIdx]</div><div class="line">        newEndVnode = newCh[--newEndIdx]</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></div><div class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</div><div class="line">        <span class="comment">// 插入到老的开始节点的前面</span></div><div class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</div><div class="line">        oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">        newStartVnode = newCh[++newStartIdx]</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果以上条件都不满足，那么这个时候开始比较key值，首先建立key和index索引的对应关系</span></div><div class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</div><div class="line">        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></div><div class="line">        <span class="comment">// 如果idxInOld不存在</span></div><div class="line">        <span class="comment">// 1. newStartVnode上存在这个key,但是oldKeyToIdx中不存在</span></div><div class="line">        <span class="comment">// 2. newStartVnode上并没有设置key属性</span></div><div class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></div><div class="line">          <span class="comment">// 创建新的dom节点</span></div><div class="line">          <span class="comment">// 插入到oldStartVnode.elm前面</span></div><div class="line">          <span class="comment">// 参见createElm方法</span></div><div class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</div><div class="line">          newStartVnode = newCh[++newStartIdx]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          elmToMove = oldCh[idxInOld]</div><div class="line">          <span class="comment">/* istanbul ignore if */</span></div><div class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</div><div class="line">              <span class="string">'Make sure each v-for item has a unique key.'</span></div><div class="line">            )</div><div class="line">          </div><div class="line">          <span class="comment">// 将找到的key一致的oldVnode再和newStartVnode进行diff</span></div><div class="line">          <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</div><div class="line">            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</div><div class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></div><div class="line">            <span class="comment">// 移动node节点</span></div><div class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</div><div class="line">            newStartVnode = newCh[++newStartIdx]</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// same key but different element. treat as new element</span></div><div class="line">            <span class="comment">// 创建新的dom节点</span></div><div class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</div><div class="line">            newStartVnode = newCh[++newStartIdx]</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果最后遍历的oldStartIdx大于oldEndIdx的话</span></div><div class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;        <span class="comment">// 如果是老的vdom先被遍历完</span></div><div class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</div><div class="line">      <span class="comment">// 添加newVnode中剩余的节点到parentElm中</span></div><div class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123; <span class="comment">// 如果是新的vdom先被遍历完，则删除oldVnode里面所有的节点</span></div><div class="line">      <span class="comment">// 删除剩余的节点</span></div><div class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不带key标签的话，遍历完一遍以后有多余的就直接把节点删了。（不推荐，不细说）</p>
<p>在<code>vnode</code>不带<code>key</code>的情况下，每一轮的<code>diff</code>过程当中都是<code>起始</code>和<code>结束</code>节点进行比较，直到<code>oldCh</code>或者<code>newCh</code>被遍历完。而当为<code>vnode</code>引入<code>key</code>属性后，在每一轮的<code>diff</code>过程中，当<code>起始</code>和<code>结束</code>节点都没有找到<code>sameVnode</code>时，首先对<code>oldCh</code>中进行<code>key</code>值与索引的映射:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</div><div class="line">idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null</div></pre></td></tr></table></figure>
<p><code>createKeyToOldIdx</code>(<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js#L61-L69">src/core/vdom/patch.js</a>)方法，用以将<code>oldCh</code>中的<code>key</code>属性作为<code>键</code>，而对应的节点的索引作为<code>值</code>。然后再判断在<code>newStartVnode</code>的属性中是否有<code>key</code>，且是否在<code>oldKeyToIndx</code>中找到对应的节点。</p>
<ol>
<li>如果不存在这个<code>key</code>，那么就将这个<code>newStartVnode</code>作为新的节点创建且插入到原有的<code>root</code>的子节点中:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isUndef(idxInOld)) &#123; // New element</div><div class="line">    // 创建新的dom节点</div><div class="line">    // 插入到oldStartVnode.elm前面</div><div class="line">    // 参见createElm方法</div><div class="line">    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</div><div class="line">         newStartVnode = newCh[++newStartIdx]</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果存在这个<code>key</code>，那么就取出<code>oldCh</code>中的存在这个<code>key</code>的<code>vnode</code>，然后再进行<code>diff</code>的过程:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">elmToMove = oldCh[idxInOld]</div><div class="line">   /* istanbul ignore if */</div><div class="line">   if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !elmToMove) &#123;</div><div class="line">   </div><div class="line">   // 将找到的key一致的oldVnode再和newStartVnode进行diff</div><div class="line">   if (sameVnode(elmToMove, newStartVnode)) &#123;</div><div class="line">     patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</div><div class="line">     // 清空这个节点</div><div class="line">     oldCh[idxInOld] = undefined</div><div class="line">     // 移动node节点</div><div class="line">     canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</div><div class="line">     newStartVnode = newCh[++newStartIdx]</div><div class="line">   &#125; else &#123;</div><div class="line">     // same key but different element. treat as new element</div><div class="line">     // 创建新的dom节点</div><div class="line">     createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</div><div class="line">     newStartVnode = newCh[++newStartIdx]</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>通过以上分析，给<code>vdom</code>上添加<code>key</code>属性后，遍历<code>diff</code>的过程中，当<code>起始点</code>, <code>结束点</code>的<code>搜寻</code>及<code>diff</code>出现还是无法匹配的情况下时，就会用<code>key</code>来作为唯一标识，来进行<code>diff</code>，这样就可以提高<code>diff</code>效率。</p>
<p>注意在第一轮的<code>diff</code>过后<code>oldCh</code>上的<code>B节点</code>被删除了，但是<code>newCh</code>上的<code>B节点</code>上<code>elm</code>属性保持对<code>oldCh</code>上<code>B节点</code>的<code>elm</code>引用。</p>
<h5 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</div><div class="line">      <span class="comment">// 当oldVnode不存在时</span></div><div class="line">      <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</div><div class="line">          <span class="comment">// 创建新的节点</span></div><div class="line">          createElm(vnode, insertedVnodeQueue, parentElm, refElm)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</div><div class="line">          <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</div><div class="line">          <span class="comment">// patch existing root node</span></div><div class="line">          <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch</span></div><div class="line">          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</div><div class="line">    &#125; </div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在对<code>oldVnode</code>和<code>vnode</code>类型判断中有个<code>sameVnode</code>方法，这个方法决定了是否需要对<code>oldVnode</code>和<code>vnode</code>进行<code>diff</code>及<code>patch</code>的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    a.key === b.key &amp;&amp;</div><div class="line">    a.tag === b.tag &amp;&amp;</div><div class="line">    a.isComment === b.isComment &amp;&amp;</div><div class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</div><div class="line">    sameInputType(a, b)</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>sameVnode会对传入的2个vnode进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个vnode只是局部发生了更新，然后才会对这2个vnode进行diff，如果2个vnode的基本属性存在不一致的情况，那么就会直接跳过diff的过程，进而依据vnode新建一个真实的dom，同时删除老的dom节点。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/react-refresh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/react-refresh/" itemprop="url">react-refresh</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T22:01:39+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React更新机制"><a href="#React更新机制" class="headerlink" title="React更新机制"></a>React更新机制</h2><h5 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h5><p>DOM元素非常庞大，具有复杂的属性，牵一发而动全身。通过JavaScript来模拟DOM树的结构，加快响应时间</p>
<ol>
<li><p>建立虚拟DOM树：用JavaScript对象记录节点类型、属性、子节点。通过递归该虚拟DOM建立真正的DOM树</p>
</li>
<li><p>diff算法：因为跨层DOM操作很少，只比较同层DOM，从而将O(n^3)的比较降低到O(n)复杂度，深度优先遍历，记录差异：</p>
<ul>
<li>替换节点类型： div -&gt; p</li>
<li>增、删、调换子节点</li>
<li>修改节点属性</li>
<li>修改文本内容</li>
</ul>
<p>记录差异类型，差异内容，压入patch数组</p>
</li>
<li><p>根据patch数组，对真实DOM进行操作。</p>
</li>
</ol>
<h5 id="diff算法自我理解"><a href="#diff算法自我理解" class="headerlink" title="diff算法自我理解"></a>diff算法自我理解</h5><p>1.忽略跨层级操作                                tree diff</p>
<p>2.拥有相同类的组件拥有相似的树结构            component diff</p>
<p>3.同一个层级之间的节点通过key进行优化            element diff</p>
<h6 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h6><p>同一个层级之间更改，不同层级就直接删除</p>
<h6 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h6><p>同一类型的组件比较，不同类型直接替换。 允许shouldcomponentupdate自己要求是否更新</p>
<h6 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h6><p>每个element都有自己的key。遍历过程中还有个lastindex表示遍历过的节点中在老节点位置中最右的index。</p>
<p>然后新节点便利，如果在老节点中index比lastindex小，挪动。新出来的节点的话加上去。如果index比lastindex大，不动。最后再遍历一遍老节点，删除已经没有的老节点。</p>
<p>说白了：新节点位置已经比左边的新节点位置靠右了，如果在老节点中比你靠左，那就说明得挪嘛。</p>
<h5 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h5><p>我们知道，react的state变化需要借助setState，在setState后再利用virtual dom，虚拟dom差异化算法（diff algorithm）更新元素元素和节点，实现更新机制。下面我们来具体讨论关于自定义元素的整个更新机制的流程。</p>
<h5 id="react自定义元素通过receiveComponent实现更新的机制"><a href="#react自定义元素通过receiveComponent实现更新的机制" class="headerlink" title="react自定义元素通过receiveComponent实现更新的机制"></a>react自定义元素通过receiveComponent实现更新的机制</h5><p>如下为我们使用setState的具体场景。当我们点击文字的时候就会出发更新事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="string">'say:'</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  changeType:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">type</span>:<span class="string">'shout:'</span>&#125;)</div><div class="line">  &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, &#123;<span class="attr">onclick</span>:<span class="keyword">this</span>.changeType&#125;,<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">React.render(React.createElement(HelloMessage, &#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;), <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>));</div></pre></td></tr></table></figure>
<p>我们首先来定义一个ReactClass类。我们可以看到调用setState会出发receiveComponent方法。所有的挂载，更新都应该交给对应的component来管理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义ReactClass类</span></div><div class="line"><span class="keyword">var</span> ReactClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactClass.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//setState</span></div><div class="line">ReactClass.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">newState</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们来具体实现这个类。首先，我们合并改动，用改动后最新的state，props与改动前对比。如果shouldComponentsUpdate为true，我们真正开始更新。然后判断新的属性与原来差的多不多，多的话就直接用新的渲染就好了，不多的话就更新element。如果要更新就继续调用对应的component类对应的receiveComponent，本质上还是递归调用receiveComponent的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//更新</span></div><div class="line">ReactCompositeComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement, newState</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//如果接受了新的，就使用最新的element</span></div><div class="line">    <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement</div><div class="line"></div><div class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</div><div class="line">    <span class="comment">//合并state</span></div><div class="line">    <span class="keyword">var</span> nextState = $.extend(inst.state, newState);</div><div class="line">    <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//改写state</span></div><div class="line">    inst.state = nextState;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。</span></div><div class="line">    <span class="keyword">if</span> (inst.shouldComponentUpdate &amp;&amp; (inst.shouldComponentUpdate(nextProps, nextState) === <span class="literal">false</span>)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">//生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。</span></div><div class="line">    <span class="keyword">if</span> (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</div><div class="line">    <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class="line">    <span class="comment">//重新执行render拿到对应的新element;</span></div><div class="line">    <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//判断是需要更新还是直接就重新渲染</span></div><div class="line">    <span class="comment">//注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法</span></div><div class="line">    <span class="keyword">if</span> (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">        <span class="comment">//如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。</span></div><div class="line">        prevComponentInstance.receiveComponent(nextRenderedElement);</div><div class="line">        <span class="comment">//调用componentDidUpdate表示更新完成了</span></div><div class="line">        inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate();</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果发现完全是不同的两种element，那就干脆重新渲染了</span></div><div class="line">        <span class="keyword">var</span> thisID = <span class="keyword">this</span>._rootNodeID;</div><div class="line">        <span class="comment">//重新new一个对应的component，</span></div><div class="line">        <span class="keyword">this</span>._renderedComponent = <span class="keyword">this</span>._instantiateReactComponent(nextRenderedElement);</div><div class="line">        <span class="comment">//重新生成对应的元素内容</span></div><div class="line">        <span class="keyword">var</span> nextMarkup = _renderedComponent.mountComponent(thisID);</div><div class="line">        <span class="comment">//替换整个节点</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).replaceWith(nextMarkup);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用来判定两个element需不需要更新</span></div><div class="line"><span class="comment">//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。</span></div><div class="line"><span class="keyword">var</span> _shouldUpdateReactComponent ＝ <span class="function"><span class="keyword">function</span>(<span class="params">prevElement, nextElement</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (prevElement != <span class="literal">null</span> &amp;&amp; nextElement != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</div><div class="line">    <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</div><div class="line">    <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> nextType === <span class="string">'object'</span> &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这种更新方式与dom节点的diff算法一致，高效的更新渲染组件。</p>
<h5 id="react的dom元素使用receiveComponent更新的实现"><a href="#react的dom元素使用receiveComponent更新的实现" class="headerlink" title="react的dom元素使用receiveComponent更新的实现"></a>react的dom元素使用receiveComponent更新的实现</h5><p>说到这里我们必须要聊一聊diff算法的实现。</p>
<p>想一下我们怎么以最小代价去更新这段html呢。不难发现其实主要包括两个部分：</p>
<ol>
<li>属性的更新，包括对特殊属性比如事件的处理</li>
<li>子节点的更新,这个比较复杂，为了得到最好的效率，我们需要处理下面这些问题：<ul>
<li>拿新的子节点树跟以前老的子节点树对比，找出他们之间的差别。我们称之为diff</li>
<li>所有差别找出后，再一次性的去更新。我们称之为patch</li>
</ul>
</li>
</ol>
<p>所以我们定义receiveComponent方法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line">    <span class="keyword">var</span> nextProps = nextElement.props;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    <span class="comment">//需要单独的更新属性</span></div><div class="line">    <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);</div><div class="line">    <span class="comment">//再更新子节点</span></div><div class="line">    <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是属性的变更。只需要把过时的删掉，添加上新的属性就好。要注意对于特殊事件的属性作出特殊处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype._updateDOMProperties = <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> propKey;</div><div class="line">    <span class="comment">//遍历，当一个老的属性不在新的属性集合里时，需要删除掉。</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</div><div class="line">        <span class="comment">//新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除</span></div><div class="line">        <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) &#123;</div><div class="line">            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);</div><div class="line">            <span class="comment">//针对当前的节点取消事件代理</span></div><div class="line">            $(<span class="built_in">document</span>).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//从dom上删除不需要的属性</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).removeAttr(propKey)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//对于新的属性，需要写到dom节点上</span></div><div class="line">    <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</div><div class="line">        <span class="comment">//对于事件监听的属性我们需要特殊处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) &#123;</div><div class="line">            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);</div><div class="line">            <span class="comment">//以前如果已经有，说明有了监听，需要先去掉</span></div><div class="line">            lastProps[propKey] &amp;&amp; $(<span class="built_in">document</span>).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);</div><div class="line">            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span></div><div class="line">            $(<span class="built_in">document</span>).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, nextProps[propKey]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (propKey == <span class="string">'children'</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">//添加新的属性，或者是更新老的同名属性</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).prop(propKey, nextProps[propKey])</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是最核心的部分，关于dom节点的更新。把大象装进冰箱无非两部，找到差异（diff），更新（patch）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line">    <span class="keyword">var</span> nextProps = nextElement.props;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    <span class="comment">//需要单独的更新属性</span></div><div class="line">    <span class="keyword">this</span>._updateDOMProperties(lastProps,nextProps);</div><div class="line">    <span class="comment">//再更新子节点</span></div><div class="line">    <span class="keyword">this</span>._updateDOMChildren(nextProps.children);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//全局的更新深度标识</span></div><div class="line"><span class="keyword">var</span> updateDepth = <span class="number">0</span>;</div><div class="line"><span class="comment">//全局的更新队列，所有的差异都存在这里</span></div><div class="line"><span class="keyword">var</span> diffQueue = [];</div><div class="line"></div><div class="line">ReactDOMComponent.prototype._updateDOMChildren = <span class="function"><span class="keyword">function</span>(<span class="params">nextChildrenElements</span>)</span>&#123;</div><div class="line">    updateDepth++</div><div class="line">    <span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span></div><div class="line">    <span class="keyword">this</span>._diff(diffQueue,nextChildrenElements);</div><div class="line">    updateDepth--</div><div class="line">    <span class="keyword">if</span>(updateDepth == <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//在需要的时候调用patch，执行具体的dom操作</span></div><div class="line">        <span class="keyword">this</span>._patch(diffQueue);</div><div class="line">        diffQueue = [];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_diff</code>内部也会递归调用子节点的receiveComponent于是当某个子节点也是浏览器普通节点，就也会走_updateDOMChildren这一步。所以这里使用了updateDepth来记录递归的过程，只有等递归回来updateDepth为0时，代表整个差异已经分析完毕，可以开始使用patch来处理差异队列了。</p>
<p>首先我们先来看diff的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//差异更新的几种类型</span></div><div class="line"><span class="keyword">var</span> UPATE_TYPES = &#123;</div><div class="line">    MOVE_EXISTING: <span class="number">1</span>,</div><div class="line">    REMOVE_NODE: <span class="number">2</span>,</div><div class="line">    INSERT_MARKUP: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> child;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">var</span> childrenMap = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; componentChildren.length; i++) &#123;</div><div class="line">        child = componentChildren[i];</div><div class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</div><div class="line">        childrenMap[name] = child;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childrenMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//主要用来生成子节点elements的component集合</span></div><div class="line"><span class="comment">//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。</span></div><div class="line"><span class="comment">//如果是新的节点，就会重新生成一个新的componentInstance，</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> nextChildren = &#123;&#125;;</div><div class="line">    nextChildrenElements = nextChildrenElements || [];</div><div class="line">    $.each(nextChildrenElements, <span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> name = element.key ? element.key : index;</div><div class="line">        <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">        <span class="keyword">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class="line">        <span class="keyword">var</span> nextElement = element;</div><div class="line"></div><div class="line">        <span class="comment">//调用_shouldUpdateReactComponent判断是否是更新</span></div><div class="line">        <span class="keyword">if</span> (_shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">            <span class="comment">//更新的话直接递归调用子节点的receiveComponent就好了</span></div><div class="line">            prevChild.receiveComponent(nextElement);</div><div class="line">            <span class="comment">//然后继续使用老的component</span></div><div class="line">            nextChildren[name] = prevChild;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//对于没有老的，那就重新新增一个，重新生成一个component</span></div><div class="line">            <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">null</span>);</div><div class="line">            <span class="comment">//使用新的component</span></div><div class="line">            nextChildren[name] = nextChildInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nextChildren;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span></div><div class="line">ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span>(<span class="params">diffQueue, nextChildrenElements</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="comment">//拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的，记不得的可以翻上面</span></div><div class="line">  <span class="comment">//_renderedChildren 本来是数组，我们搞成map</span></div><div class="line">  <span class="keyword">var</span> prevChildren = flattenChildren(self._renderedChildren);</div><div class="line">  <span class="comment">//生成新的子节点的component对象集合，这里注意，会复用老的component对象</span></div><div class="line">  <span class="keyword">var</span> nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</div><div class="line">  <span class="comment">//重新赋值_renderedChildren，使用最新的。</span></div><div class="line">  self._renderedChildren = []</div><div class="line">  $.each(nextChildren, <span class="function"><span class="keyword">function</span>(<span class="params">key, instance</span>) </span>&#123;</div><div class="line">    self._renderedChildren.push(instance);</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>; <span class="comment">//代表到达的新的节点的index</span></div><div class="line">  <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span></div><div class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</div><div class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">    <span class="keyword">var</span> nextChild = nextChildren[name];</div><div class="line">    <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span></div><div class="line">    <span class="keyword">if</span> (prevChild === nextChild) &#123;</div><div class="line">      <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        parentId: self._rootNodeID,</div><div class="line">        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        type: UPATE_TYPES.MOVE_EXISTING,</div><div class="line">        fromIndex: prevChild._mountIndex,</div><div class="line">        toIndex: nextIndex</div><div class="line">      &#125;)</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不相同，说明是新增加的节点</span></div><div class="line">      <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span></div><div class="line">      <span class="keyword">if</span> (prevChild) &#123;</div><div class="line">        <span class="comment">//添加差异对象，类型：REMOVE_NODE</span></div><div class="line">        diffQueue.push(&#123;</div><div class="line">          parentId: self._rootNodeID,</div><div class="line">          parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">          type: UPATE_TYPES.REMOVE_NODE,</div><div class="line">          fromIndex: prevChild._mountIndex,</div><div class="line">          toIndex: <span class="literal">null</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空</span></div><div class="line">        <span class="keyword">if</span> (prevChild._rootNodeID) &#123;</div><div class="line">            $(<span class="built_in">document</span>).undelegate(<span class="string">'.'</span> + prevChild._rootNodeID);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//新增加的节点，也组装差异对象放到队列里</span></div><div class="line">      <span class="comment">//添加差异对象，类型：INSERT_MARKUP</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        parentId: self._rootNodeID,</div><div class="line">        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        type: UPATE_TYPES.INSERT_MARKUP,</div><div class="line">        fromIndex: <span class="literal">null</span>,</div><div class="line">        toIndex: nextIndex,</div><div class="line">        markup: nextChild.mountComponent() <span class="comment">//新增的节点，多一个此属性，表示新节点的dom内容</span></div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//更新mount的index</span></div><div class="line">    nextChild._mountIndex = nextIndex;</div><div class="line">    nextIndex++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span></div><div class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</div><div class="line">    <span class="keyword">if</span> (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123;</div><div class="line">      <span class="comment">//添加差异对象，类型：REMOVE_NODE</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        parentId: self._rootNodeID,</div><div class="line">        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        type: UPATE_TYPES.REMOVE_NODE,</div><div class="line">        fromIndex: prevChild._mountIndex,</div><div class="line">        toIndex: <span class="literal">null</span></div><div class="line">      &#125;)</div><div class="line">      <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听</span></div><div class="line">      <span class="keyword">if</span> (prevChildren[name]._rootNodeID) &#123;</div><div class="line">        $(<span class="built_in">document</span>).undelegate(<span class="string">'.'</span> + prevChildren[name]._rootNodeID);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大概就做了如下几件事，首先component用来放element，把数组转成了对象map，用 key作为每个element的标识，递归的根据key查找看能复用，然后根据前后节点的不同分为这么几个情况，这几个情况分别处理。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVE_EXISTING</td>
<td>新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。</td>
</tr>
<tr>
<td>INSERT_MARKUP</td>
<td>新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component不在新的集合里的，我们需要删除</td>
</tr>
</tbody>
</table>
<p>接下来我们一起来处理patch的实现。<code>_patch</code>主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用于将childNode插入到指定位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertChildAt</span>(<span class="params">parentNode, childNode, index</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> beforeChild = parentNode.children().get(index);</div><div class="line">    beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOMComponent.prototype._patch = <span class="function"><span class="keyword">function</span>(<span class="params">updates</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> update;</div><div class="line">    <span class="keyword">var</span> initialChildren = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> deleteChildren = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; updates.length; i++) &#123;</div><div class="line">        update = updates[i];</div><div class="line">        <span class="keyword">if</span> (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) &#123;</div><div class="line">            <span class="keyword">var</span> updatedIndex = update.fromIndex;</div><div class="line">            <span class="keyword">var</span> updatedChild = $(update.parentNode.children().get(updatedIndex));</div><div class="line">            <span class="keyword">var</span> parentID = update.parentID;</div><div class="line"></div><div class="line">            <span class="comment">//所有需要更新的节点都保存下来，方便后面使用</span></div><div class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</div><div class="line">            <span class="comment">//使用parentID作为简易命名空间</span></div><div class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">//所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可</span></div><div class="line">            deleteChildren.push(updatedChild)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//删除所有需要先删除的</span></div><div class="line">    $.each(deleteChildren, <span class="function"><span class="keyword">function</span>(<span class="params">index, child</span>) </span>&#123;</div><div class="line">        $(child).remove();</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) &#123;</div><div class="line">        update = updates[k];</div><div class="line">        <span class="keyword">switch</span> (update.type) &#123;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.INSERT_MARKUP:</div><div class="line">                insertChildAt(update.parentNode, $(update.markup), update.toIndex);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.MOVE_EXISTING:</div><div class="line">                insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.REMOVE_NODE:</div><div class="line">                <span class="comment">// 什么都不需要做，因为上面已经帮忙删除掉了</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样整个的更新机制就完成了。我们再来简单回顾下reactjs的差异算法：</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<ol>
<li>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</li>
<li>text节点的更新很简单，直接更新文案。</li>
<li>浏览器基本元素的更新，分为两块：<ul>
<li>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</li>
<li>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。</li>
</ul>
</li>
</ol>
<p>整个reactjs的差异算法就是这个样子。最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/readbook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/readbook/" itemprop="url">readbook</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:43:48+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h3 id="Javascript秘密花园"><a href="#Javascript秘密花园" class="headerlink" title="Javascript秘密花园"></a>Javascript秘密花园</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而<strong>仅仅</strong>是移除了属性和值的关联。</p>
<p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>
<p>这种技术被称之为 <a href="http://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">monkey patching</a> 并且会破坏<em>封装</em>。虽然它被广泛的应用到一些 JavaScript 类库中比如 <a href="http://prototypejs.org/" target="_blank" rel="external">Prototype</a>, 但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-centmaster/2017/09/13/readbook/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/nk-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/nk-interview/" itemprop="url">nk-interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:42:47+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="不成体系的各种知识点看到不会的就记录下来"><a href="#不成体系的各种知识点看到不会的就记录下来" class="headerlink" title="不成体系的各种知识点看到不会的就记录下来"></a>不成体系的各种知识点看到不会的就记录下来</h2><p>低版本浏览器不支持HTML5标签怎么解决</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line"><span class="comment">  &lt;script src="http://cdn.staticfile.org/html5shiv/r29/html5.js"&gt;&lt;/script&gt;</span></div><div class="line"><span class="comment">&lt;![endif]--&gt;</span></div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-centmaster/2017/09/13/nk-interview/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/algorithm/" itemprop="url">algorithm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:42:19+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a=<span class="number">123</span>;</div><div class="line"><span class="keyword">let</span> b=a.toString(<span class="number">2</span>);</div><div class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;</div><div class="line">  b=~b+<span class="number">1</span>;  <span class="comment">//取反加一就是取负值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-centmaster/2017/09/13/algorithm/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/FE-sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/FE-sum/" itemprop="url">FE-sum</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:41:55+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前端技术积累"><a href="#前端技术积累" class="headerlink" title="前端技术积累"></a>前端技术积累</h1><p>[TOC]</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这个面经的来源一共分为三部分。第一部分是市面上的面经结合自己的知识总结。第二部分就是自己的面经，大大小小面了也有一些了，希望自己也能总结总结造福自己造福后人。最后一部分就是针对自己做过的东西，简历上的东西做的总结，不具有普遍性。当然文件夹里还有一些算法题，平常做前端的也要动动脑嘛。希望自己和大家都能找到满意的工作。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-centmaster/2017/09/13/FE-sum/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T20:50:19+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="ES6入门-个人总结"><a href="#ES6入门-个人总结" class="headerlink" title="ES6入门  个人总结"></a>ES6入门  个人总结</h2><h4 id="ES6生命变量的六种方式"><a href="#ES6生命变量的六种方式" class="headerlink" title="ES6生命变量的六种方式"></a>ES6生命变量的六种方式</h4><p>let const promise reflect proxy generator decorator Symbol Iterator 结构赋值</p>
<p>Array: .from .of …(扩展运算符) .copyWithin .find .findindex .includes .fill .entires .keys .values</p>
<p>Object: 属性表达式 .is .assign </p>
<p>class</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/hexo-centmaster/2017/09/13/ES6/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">centmaster</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/hexo-centmaster/archives/">
            
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">centmaster</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/hexo-centmaster/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/hexo-centmaster/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/hexo-centmaster/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/hexo-centmaster/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/hexo-centmaster/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/hexo-centmaster/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
