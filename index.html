<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/hexo-centmaster/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/hexo-centmaster/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/hexo-centmaster/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/hexo-centmaster/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/centmaster/hexo-centmaster/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo-centmaster/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/centmaster/hexo-centmaster/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexo-centmaster/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexo-centmaster/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexo-centmaster/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/readbook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/readbook/" itemprop="url">readbook</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:43:48+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h3 id="Javascript秘密花园"><a href="#Javascript秘密花园" class="headerlink" title="Javascript秘密花园"></a>Javascript秘密花园</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而<strong>仅仅</strong>是移除了属性和值的关联。</p>
<p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>
<p>这种技术被称之为 <a href="http://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">monkey patching</a> 并且会破坏<em>封装</em>。虽然它被广泛的应用到一些 JavaScript 类库中比如 <a href="http://prototypejs.org/" target="_blank" rel="external">Prototype</a>, 但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>在构造函数内部 - 也就是被调用的函数内 - <code>this</code> 指向新创建的对象 <code>Object</code>。 这个<strong>新创建</strong>的对象的 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.prototype" target="_blank" rel="external"><code>prototype</code></a> 被指向到构造函数的 <code>prototype</code>。</p>
<p>如果被调用的函数没有显式的 <code>return</code> 表达式，则隐式的会返回 <code>this</code> 对象 - 也就是新创建的对象。</p>
<p>ps: 什么之前修改一个实例的原型链上方法不会改变另一个实例方法。因为并没有真正改变原型链上的方法，改变的这个方法其实是写在这个实例自身上的。覆盖了原来的方法，如果用<em>proto</em>找到原型链上的方法改动，另一个也改了。</p>
<p>new Bar() 返回的是新创建的对象，而不是数字的字面值 2。 因此 new Bar().constructor === Bar，但是如果返回的是数字对象，结果就不同了，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span></div></pre></td></tr></table></figure>
<h6 id="用工厂模式替代构造函数"><a href="#用工厂模式替代构造函数" class="headerlink" title="用工厂模式替代构造函数"></a>用工厂模式替代构造函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.value = <span class="string">'blub'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> private = <span class="number">2</span>;</div><div class="line">    obj.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> private;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为new其实就是隐式返回一个this指向的对象嘛，我自己返回一个对象。</p>
<p>虽然上面的方式比起 <code>new</code> 的调用方式不容易出错，并且可以充分利用<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures" target="_blank" rel="external">私有变量</a>带来的便利， 但是随之而来的是一些不好的地方。</p>
<ol>
<li>会占用更多的内存，因为新创建的对象<strong>不能</strong>共享原型上的方法。</li>
<li>为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li>放弃原型链仅仅是因为防止遗漏 <code>new</code> 带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<p>Ps:如果 <code>return</code> 对象的左括号和 <code>return</code> 不在一行上就会出错。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line">foo.length = <span class="number">3</span>;</div><div class="line">foo; <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line">foo.length = <span class="number">6</span>;</div><div class="line">foo; <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>为了更好的性能，推荐使用普通的 <code>for</code> 循环并缓存数组的 <code>length</code> 属性。 使用 <code>for in</code> 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Value               Class      Type</div><div class="line">-------------------------------------</div><div class="line">&quot;foo&quot;               String     string</div><div class="line">new String(&quot;foo&quot;)   String     object</div><div class="line">1.2                 Number     number</div><div class="line">new Number(1.2)     Number     object</div><div class="line">true                Boolean    boolean</div><div class="line">new Boolean(true)   Boolean    object</div><div class="line">new Date()          Date       object</div><div class="line">new Error()         Error      object</div><div class="line">[1,2,3]             Array      object</div><div class="line">new Array(1, 2, 3)  Array      object</div><div class="line">new Function(&quot;&quot;)    Function   function</div><div class="line">/abc/g              RegExp     object (function in Nitro/V8)</div><div class="line">new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro/V8)</div><div class="line">&#123;&#125;                  Object     object</div><div class="line">new Object()        Object     object</div></pre></td></tr></table></figure>
<p>可以看出来大部分Type都收Object，我们用Object.prototype.toString.call(obj).slice(8, -1);来判断Class(“[object Array]”)</p>
<h5 id="setTimeout-和-setInterval"><a href="#setTimeout-和-setInterval" class="headerlink" title="setTimeout 和 setInterval"></a><code>setTimeout</code> 和 <code>setInterval</code></h5><p>当回调函数的执行被阻塞时，<code>setInterval</code> 仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。</p>
<p>解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 阻塞执行 1 秒</span></div><div class="line">    setTimeout(foo, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p><strong>绝对不要</strong>使用字符串作为 <code>setTimeout</code> 或者 <code>setInterval</code> 的第一个参数， 这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个<em>匿名函数</em>，在函数内执行真实的回调函数。</p>
<p>另外，应该避免使用 <code>setInterval</code>，因为它的定时执行不会被 JavaScript 阻塞。</p>
<h3 id="深入理解javascript—编写高质量代码和设计模式"><a href="#深入理解javascript—编写高质量代码和设计模式" class="headerlink" title="深入理解javascript—编写高质量代码和设计模式"></a>深入理解javascript—编写高质量代码和设计模式</h3><h5 id="最小全局变量"><a href="#最小全局变量" class="headerlink" title="最小全局变量"></a>最小全局变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = b = <span class="number">0</span>;<span class="comment">//b就成了全局变量</span></div></pre></td></tr></table></figure>
<p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过 delete 操作符让变量未定义的能力。</p>
<ul>
<li>通过 var 创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li>
<li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li>
</ul>
<p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过 delete 操作符删除的，而变量是不能的</p>
<h5 id="访问全局变量"><a href="#访问全局变量" class="headerlink" title="访问全局变量"></a>访问全局变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h5 id="单-var-形式（Single-var-Pattern）"><a href="#单-var-形式（Single-var-Pattern）" class="headerlink" title="单 var 形式（Single var Pattern）"></a>单 var 形式（Single var Pattern）</h5><p>在函数顶部使用单 var 语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的…</li>
<li>少代码（类型啊传值啊单线完成）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> a = <span class="number">1</span>,</div><div class="line">       b = <span class="number">2</span>,</div><div class="line">       sum = a + b,</div><div class="line">       myobject = &#123;&#125;,</div><div class="line">       i,</div><div class="line">       j;</div><div class="line">   <span class="comment">// function body...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">looper</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> i = <span class="number">0</span>,</div><div class="line">        max,</div><div class="line">        myarray = [];</div><div class="line">   <span class="comment">// ...</span></div><div class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">      <span class="comment">// 使用myarray[i]做点什么</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环中尽量不要每次去求长度，性能影响很多。</p>
<h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p>在 for-in 中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的 for 循环，对象使用 for-in 循环。</p>
<h5 id="字符串转换成数值"><a href="#字符串转换成数值" class="headerlink" title="字符串转换成数值"></a>字符串转换成数值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+<span class="string">"08"</span> <span class="comment">// 结果是 8</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"08"</span>) <span class="comment">// 8</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'08'</span>) <span class="comment">//性能不行。因为不是简单的转化，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以 NaN 告终。</span></div></pre></td></tr></table></figure>
<h5 id="将声明变量和函数区分"><a href="#将声明变量和函数区分" class="headerlink" title="将声明变量和函数区分"></a>将声明变量和函数区分</h5><p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是 myFunction()， calculateArea()和 getFirstName()。</p>
<p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name， favorite_bands，和 old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p>
<h4 id="全面解析-Module-模式"><a href="#全面解析-Module-模式" class="headerlink" title="全面解析 Module 模式"></a>全面解析 Module 模式</h4><h5 id="引用全局变量"><a href="#引用全局变量" class="headerlink" title="引用全局变量"></a>引用全局变量</h5><p>首先我们来看看 Module 模式的基本特征：</p>
<ol>
<li>模块化，可重用</li>
<li>封装了变量和 function，和全局的 namaspace 不接触，松耦合</li>
<li>只暴露可用 public 的方法，其它私有方法全部隐藏</li>
</ol>
<p>先看一下最简单的一个实现，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> (<span class="params">eq</span>) </span>&#123;</div><div class="line">    <span class="comment">//这里可以声明私有成员</span></div><div class="line">    <span class="keyword">var</span> eqCtl = <span class="built_in">document</span>.getElementById(eq);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 暴露公开的成员</span></div><div class="line">        add: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> val = x + y;</div><div class="line">            eqCtl.innerHTML = val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</span></div><div class="line">&#125; (jQuery, YAHOO));</div><div class="line"></div><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> my = &#123;&#125;, privateName = <span class="string">"博客园"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateAddTopic</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="comment">// 这里是内部处理代码</span></div><div class="line">    &#125;</div><div class="line">    my.Name = privateName;</div><div class="line">    my.AddTopic = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">        privateAddTopic(data);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> my;</div><div class="line">&#125; ());    <span class="comment">//将变量传入全局</span></div></pre></td></tr></table></figure>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>Module 模式的一个限制就是所有的代码都要写在一个文件，但是在一些大型项目里，将一个功能分离成多个文件是非常重要的，因为可以多人合作易于开发。</p>
<h6 id="松散耦合扩展"><a href="#松散耦合扩展" class="headerlink" title="松散耦合扩展"></a>松散耦合扩展</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line">    my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//添加内部代码  </span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule|| &#123;&#125;));  <span class="comment">//通过||可以保证结构</span></div></pre></td></tr></table></figure>
<h6 id="紧耦合扩展"><a href="#紧耦合扩展" class="headerlink" title="紧耦合扩展"></a>紧耦合扩展</h6><p>虽然松耦合扩展很牛叉了，但是可能也会存在一些限制，比如你没办法重写你的一些属性或者函数，也不能在初始化的时候就是用 Module 的属性。紧耦合扩展限制了加载顺序，但是提供了我们重载的机会，看如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> oldAddPhotoMethod = my.AddPhoto;</div><div class="line">    my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 重载方法，依然可通过oldAddPhotoMethod调用旧的方法</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p>通过这种方式，我们达到了重载的目的，当然如果你想在继续在内部使用原有的属性，你可以调用 oldAddPhotoMethod 来用。</p>
<h6 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h6><p>最后一个也是最简单的使用方式，那就是创建子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;;</div><div class="line">    // ...</div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p>尽管非常简单，我还是把它放进来了，因为我想说明的是子模块也具有一般模块所有的高级使用方式，也就是说你可以对任意子模块再次使用上面的一些应用方法。</p>
<h5 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h5><p>function(){}() 这样为什么不行？因为在解析器解析全局的 function 或者 function 内部 function 关键字的时候，默认是认为 function 声明，而不是 function 表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的 function，并且抛出一个语法错误信息，因为 function 声明需要一个名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></div><div class="line"><span class="comment">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;(); <span class="comment">// SyntaxError: Unexpected token )</span></div><div class="line"><span class="comment">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></div><div class="line"><span class="comment">// 但是foo函数依然不会执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;( <span class="number">1</span> ); </div><div class="line"><span class="comment">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式： </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125; </div><div class="line">( <span class="number">1</span> );</div></pre></td></tr></table></figure>
<p>要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为 JavaScript 里括弧()里面不能包含语句，所以在这一点上，解析器在解析 function 关键字的时候，会将相应的代码解析成 function 表达式，而不是 function 声明。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/nk-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/nk-interview/" itemprop="url">nk-interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:42:47+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="不成体系的各种知识点看到不会的就记录下来"><a href="#不成体系的各种知识点看到不会的就记录下来" class="headerlink" title="不成体系的各种知识点看到不会的就记录下来"></a>不成体系的各种知识点看到不会的就记录下来</h2><p>低版本浏览器不支持HTML5标签怎么解决</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line"><span class="comment">  &lt;script src="http://cdn.staticfile.org/html5shiv/r29/html5.js"&gt;&lt;/script&gt;</span></div><div class="line"><span class="comment">&lt;![endif]--&gt;</span></div></pre></td></tr></table></figure>
<h5 id="CSS-W3C盒子和IE盒子的如何互相转化"><a href="#CSS-W3C盒子和IE盒子的如何互相转化" class="headerlink" title="CSS W3C盒子和IE盒子的如何互相转化"></a>CSS W3C盒子和IE盒子的如何互相转化</h5><p>box-sizing属性<code>box-sizing: content-box|border-box|initial|inherit;</code></p>
<p>inherit表明从父元素继承；initial表明默认值；<br>Content-box表示width和height属性只包含内容区的大小；<br>border-box表示width和height属性是<code>border + padding + content</code>的大小</p>
<h5 id="Array对象自带的排序函数底层是怎么实现的？"><a href="#Array对象自带的排序函数底层是怎么实现的？" class="headerlink" title="Array对象自带的排序函数底层是怎么实现的？"></a>Array对象自带的排序函数底层是怎么实现的？</h5><p>查阅资料发现，V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数组长度小于等于 22 的用插入排序 InsertionSort，比22大的数组则使用快速排序 QuickSort。</p>
<p>插入排序：遍历序列，每次i都从头开始比放到合适位置</p>
<h5 id="邮箱-正则https-segmentfault-com-q-1010000006661187"><a href="#邮箱-正则https-segmentfault-com-q-1010000006661187" class="headerlink" title="邮箱 正则https://segmentfault.com/q/1010000006661187"></a>邮箱 正则<a href="https://segmentfault.com/q/1010000006661187" target="_blank" rel="external">https://segmentfault.com/q/1010000006661187</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/^[a-z0-9]+([._\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+\.)&#123;1,63&#125;[a-z0-9]+$/</div></pre></td></tr></table></figure>
<h5 id="面向对象-面向过程"><a href="#面向对象-面向过程" class="headerlink" title="面向对象 面向过程"></a>面向对象 面向过程</h5><p>它的设计上的特点是：继承、封装、多态</p>
<p>面向对象设计的核心思想是模块化，对问题进行抽象。</p>
<p>ps：如何实现多态？重写父类的方法</p>
<h5 id="JS实现异步的方法"><a href="#JS实现异步的方法" class="headerlink" title="JS实现异步的方法"></a>JS实现异步的方法</h5><p>1.回调函数</p>
<p>2.Promise</p>
<p>3.事件监听，监听到再触发下一个任务</p>
<p>4.发布订阅模式</p>
<p>publish（‘done’） subscribe（‘done’，）</p>
<h5 id="移动端前端配适方案"><a href="#移动端前端配适方案" class="headerlink" title="移动端前端配适方案"></a>移动端前端配适方案</h5><p>1.Media Query</p>
<p>2.Flex</p>
<p>它的<code>viewport</code>是固定的：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;</code></p>
<p>3.rem</p>
<h5 id="懒加载的性能优化"><a href="#懒加载的性能优化" class="headerlink" title="懒加载的性能优化"></a>懒加载的性能优化</h5><p>全部一次性插入进去设置隐藏的效率远比动态插入删除效率高的多</p>
<h5 id="cookie除了key与value还有哪些参数"><a href="#cookie除了key与value还有哪些参数" class="headerlink" title="cookie除了key与value还有哪些参数"></a>cookie除了key与value还有哪些参数</h5><p>path domain Expire size</p>
<h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><table>
<thead>
<tr>
<th>Undefined</th>
<th><code>&quot;undefined&quot;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Null</td>
<td><code>&quot;object&quot;</code>(see below)</td>
</tr>
<tr>
<td>Boolean</td>
<td><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td>Number</td>
<td><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td>String</td>
<td><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td>Symbol (new in ECMAScript 2015)</td>
<td><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td>Host object (provided by the JS environment)</td>
<td><em>Implementation-dependent</em></td>
</tr>
<tr>
<td>Function object (implements [[Call]] in ECMA-262 terms)</td>
<td><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td>Any other object</td>
<td><code>&quot;object&quot;</code></td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">23</span>;</div><div class="line">&#125; </div><div class="line"><span class="keyword">typeof</span> g()<span class="comment">//number</span></div></pre></td></tr></table></figure>
<h5 id="常用算法排序"><a href="#常用算法排序" class="headerlink" title="常用算法排序"></a>常用算法排序</h5><table>
<thead>
<tr>
<th>排序法</th>
<th>最差时间分析</th>
<th>平均时间复杂度</th>
<th>稳定度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n2)</td>
<td>O(n*log2n)</td>
<td>不稳定</td>
<td>O(log2n)~O(n)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉树排序</td>
<td>O(n2)</td>
<td>O(n*log2n)</td>
<td>不一顶</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O</td>
<td>O</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>addEventListener是w3c标准写法，共有三个参数，第一个为事件类型，但是不加on，第二个参数是一个函数，用于写逻辑代码进行事件操作，第三个参数为boolean型值，true或false,true表示事件捕获，false表示事件冒泡，默认为false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="comment">//操作</span></div><div class="line">    <span class="built_in">console</span>.log(e)</div><div class="line">&#125;</div><div class="line">ele.addEventListener(<span class="string">'click'</span>, handler);<span class="comment">//绑定</span></div><div class="line">ele.removeEventListener(<span class="string">'click'</span>, handler);<span class="comment">//解绑</span></div></pre></td></tr></table></figure>
<h5 id="ES6和ES5继承的区别"><a href="#ES6和ES5继承的区别" class="headerlink" title="ES6和ES5继承的区别"></a>ES6和ES5继承的区别</h5><p>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到<strong>this</strong>上（Parent.apply(this)）.</p>
<p>ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。</p>
<h5 id="cnd-dns"><a href="#cnd-dns" class="headerlink" title="cnd dns"></a>cnd dns</h5><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C" target="_blank" rel="external">内容分发网络</a>。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="external">节点服务器</a>所构成的在现有的互联网基础之上的一层智能<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">虚拟网络</a>，CDN系统能够实时地根据<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F" target="_blank" rel="external">网络流量</a>和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<p>DNS（Domain Name System，域名系统），因特网上作为域名和<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="external">IP地址</a>相互映射的一个<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="external">分布式数据库</a>，能够使用户更方便的访问<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91" target="_blank" rel="external">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" target="_blank" rel="external">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在<a href="https://baike.baidu.com/item/UDP" target="_blank" rel="external">UDP</a>协议之上，使用端口号53。</p>
<h5 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h5><p><code>absolute</code>：相对于非static的最近祖先</p>
<h5 id="Web优化策略"><a href="#Web优化策略" class="headerlink" title="Web优化策略"></a>Web优化策略</h5><ol>
<li>请求数量：合并脚本和样式表, iconfont，拆分初始化负载（一开始只加载必要脚本），划分主域（增加DNS查询代价，但是增加了并发链接数）</li>
<li>请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化</li>
<li>利用缓存：使用 CDN，使用外部 JavaScript 和 CSS，减少 DNS 查找</li>
<li>页面结构：将样式表(影响样式的内容)放在顶部，将脚本放在底部，尽早刷新文档的输出</li>
</ol>
<h5 id="rem和em的区别"><a href="#rem和em的区别" class="headerlink" title="rem和em的区别"></a>rem和em的区别</h5><p>都是相对font-size大小，但是rem是根据root的em，em是根据父级</p>
<h5 id="发现一个神奇的东西"><a href="#发现一个神奇的东西" class="headerlink" title="发现一个神奇的东西"></a>发现一个神奇的东西</h5><p>按说substr——》对应splice     substring———》slice</p>
<p>但只有splice会真实的改变原来的数据，其他三个都不能</p>
<h5 id="css百分比相对于谁"><a href="#css百分比相对于谁" class="headerlink" title="css百分比相对于谁"></a>css百分比相对于谁</h5><p>相对于父元素宽度的：<br>[max/min-]width、left、right、padding、margin 等；</p>
<p>相对于父元素高度的：<br>[max/min-]height、top、bottom 等；</p>
<p>相对于继承字号的：<br>font-size 等；</p>
<p>相对于自身字号的：<br>line-height 等；</p>
<p>相对于自身宽高的：<br>border-radius、background-size、transform: translate()、transform-origin、zoom、clip-path 等；</p>
<h5 id="js严格模式"><a href="#js严格模式" class="headerlink" title="js严格模式"></a>js严格模式</h5><p>如果两个js用了不同模式，怎么放在一起？用IIFE将两者隔离开来</p>
<h6 id="语法限制"><a href="#语法限制" class="headerlink" title="语法限制"></a>语法限制</h6><p>1.不允许使用未声明变量，当然也不许删除变量</p>
<p>2.对象。对象属性改动限制</p>
<p>3.函数。不允许名字相同的参数，arguments与参数独立。</p>
<p>4.eval方法只在其操作的eval内部</p>
<p>5.this在严格模式下始终指向指定的值，包括null和undefined。</p>
<p>6.不允许使用with</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="built_in">window</span>.color=<span class="string">"red"</span>; <span class="comment">//node环境中为global.color = "red"; </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);<span class="comment">//严格模式下报错</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="遍历方法的区别"><a href="#遍历方法的区别" class="headerlink" title="遍历方法的区别"></a>遍历方法的区别</h5><p>map():返回一个新的Array，每个元素为调用func的结果</p>
<p>filter():返回一个符合func条件的元素数组</p>
<p>some():返回一个boolean，判断是否有元素是否符合func条件</p>
<p>every():返回一个boolean，判断每个元素是否符合func条件</p>
<p>forEach():没有返回值，只是针对每个元素调用func</p>
<h5 id="原生css实现三角形"><a href="#原生css实现三角形" class="headerlink" title="原生css实现三角形"></a>原生css实现三角形</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">width</span>: 0;</div><div class="line"><span class="selector-tag">height</span>: 0;</div><div class="line"><span class="selector-tag">border-left</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">border-right</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</div><div class="line"><span class="selector-tag">border-bottom</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</div></pre></td></tr></table></figure>
<h5 id="https和http以及http2"><a href="#https和http以及http2" class="headerlink" title="https和http以及http2"></a>https和http以及http2</h5><p><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="external">http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/</a></p>
<p>http1.0——&gt;http1.1——&gt;https——&gt;SPDY——&gt;http2.0</p>
<h6 id="影响http的主要因素"><a href="#影响http的主要因素" class="headerlink" title="影响http的主要因素"></a>影响http的主要因素</h6><p>带宽和延时。带宽现在不是大问题了，主要是延时。产生延时的3个因素</p>
<p>1.浏览器阻塞。  因为浏览器限制最大连接数</p>
<p>2.DNS查询</p>
<p>3.建立连接。三次握手。慢启动—拥塞避免。   一开始从很小开始试网络情况，然后动态调整</p>
<h6 id="1-0和1-1的区别"><a href="#1-0和1-1的区别" class="headerlink" title="1.0和1.1的区别"></a>1.0和1.1的区别</h6><p>1.缓存处理。引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
<p>2.带宽优化。在请求头引入了range头域，它允许只请求资源的某个部分</p>
<p>3.增加了更多的错误状态码。410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p>4.Host头处理。在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址</p>
<p>5.长连接</p>
<h6 id="为了保证安全性，https应运而生"><a href="#为了保证安全性，https应运而生" class="headerlink" title="为了保证安全性，https应运而生"></a>为了保证安全性，https应运而生</h6><p>在http和tcp中间多加了一个层，SSL／TLS</p>
<p>改造成https过程：安装CA证书，大量的密钥计算增加cpu计算成本</p>
<p>证书的作用：实现加密传输，认证服务器身份。</p>
<h6 id="使用SPDY—在http和ssl中间层"><a href="#使用SPDY—在http和ssl中间层" class="headerlink" title="使用SPDY—在http和ssl中间层"></a>使用SPDY—在http和ssl中间层</h6><p>1.多路复用</p>
<p>2.请求优先级</p>
<p>3.header压缩</p>
<p>4.基于https</p>
<h6 id="HTTP2-0新特性"><a href="#HTTP2-0新特性" class="headerlink" title="HTTP2.0新特性"></a>HTTP2.0新特性</h6><p>1.新的二进制格式</p>
<p>2.多路复用</p>
<p>按层从高到低。HTTP—SPDY—-SSL—-TCP</p>
<h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5><p>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。</p>
<h5 id="async-await和generator的区别"><a href="#async-await和generator的区别" class="headerlink" title="async await和generator的区别"></a>async await和generator的区别</h5><p>实验证明，前者其实就是地狱回调的样子，等callback之后再往后走。就是同步的。</p>
<p>async 是多个异步操作的promise对象，await相当于then</p>
<p>使用await Promise.all([func1(),func2()])。就可以把同步变成异步了。</p>
<p>区别：</p>
<p>前者 await后边是跟promise不是自己会转   后者跟的还是generator</p>
<h5 id="json和对象的区别"><a href="#json和对象的区别" class="headerlink" title="json和对象的区别"></a>json和对象的区别</h5><p>JSON是一种数据格式，可以用来交换、存储数据。从JSON可以方便的生成JS对象。</p>
<p>其语法可以认为是JS Object的子集，主要区别在：</p>
<ol>
<li>JSON的键必须带引号，JS可以不带（解释器自动加）</li>
<li>JSON没有函数、undefined、NaN等数据类型</li>
</ol>
<h5 id="object-create的实现原理"><a href="#object-create的实现原理" class="headerlink" title="object.create的实现原理"></a>object.create的实现原理</h5><p>我觉得，prototype引原来的，再用assign把属性方法都引过来，是不是就差不多？</p>
<h5 id="前后端分离怎么做？意义？"><a href="#前后端分离怎么做？意义？" class="headerlink" title="前后端分离怎么做？意义？"></a>前后端分离怎么做？意义？</h5><p>解耦可以方便完全不同的前后端人员开发，理清逻辑。如果前端变化远比后端变化快，应该分离。</p>
<h5 id="cookie-LocalStorage被重复覆盖"><a href="#cookie-LocalStorage被重复覆盖" class="headerlink" title="cookie,LocalStorage被重复覆盖"></a>cookie,LocalStorage被重复覆盖</h5><p>cookie.setMaxAge(Integer.MAX_VALUE); </p>
<p>如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。</p>
<p>cookie配合sessionid，共同验证登录</p>
<p>后者存的是字符串。都会被覆盖。</p>
<h5 id="js-如何添加class-不覆盖原来的"><a href="#js-如何添加class-不覆盖原来的" class="headerlink" title="js 如何添加class 不覆盖原来的"></a>js 如何添加class 不覆盖原来的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element.className = &quot;redColor&quot;;//设置class</div><div class="line">element.className += &quot; yellowBack&quot;;//增加class</div></pre></td></tr></table></figure>
<h5 id="一个何时会报undefined，何时会报referenceerror"><a href="#一个何时会报undefined，何时会报referenceerror" class="headerlink" title="一个何时会报undefined，何时会报referenceerror"></a>一个何时会报undefined，何时会报referenceerror</h5><p>当你var a，或者找一个对象里的某个属性，a=Object.create({});a.name的时候会报undefined。如果一个变量从未声明，则referenceerror。如果求一个简单变量查找属性，则typeerror</p>
<h5 id="判断js对象是否存在的方法"><a href="#判断js对象是否存在的方法" class="headerlink" title="判断js对象是否存在的方法"></a>判断js对象是否存在的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>	<span class="keyword">if</span> (!myObj) &#123;</div><div class="line">　　　　<span class="keyword">var</span> myObj = &#123; &#125;;</div><div class="line">　　&#125;<span class="comment">//一定要有var，变量提升之后才不会报错，否则ReferenceError</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">2</span>　　<span class="keyword">if</span> (!<span class="built_in">window</span>.myObj) &#123;</div><div class="line">　　　　<span class="keyword">var</span> myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"><span class="number">3</span>	<span class="keyword">if</span> (!<span class="keyword">this</span>.myObj) &#123;</div><div class="line">　　　　<span class="keyword">this</span>.myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4</span>	<span class="keyword">var</span> global = <span class="keyword">this</span>;</div><div class="line">　　<span class="keyword">if</span> (!global.myObj) &#123;</div><div class="line">　　　　global.myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">5</span>	　<span class="keyword">if</span> (<span class="keyword">typeof</span> myObj == <span class="string">"undefined"</span>) &#123;</div><div class="line">　　　　<span class="keyword">var</span> myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"><span class="number">6</span>	<span class="keyword">if</span> (myObj == <span class="literal">undefined</span>) &#123;</div><div class="line">　　　　<span class="keyword">var</span> myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"><span class="number">7</span>	<span class="keyword">if</span> (!<span class="keyword">this</span>.hasOwnProperty(<span class="string">'myObj'</span>)) &#123;</div><div class="line">　　　　<span class="keyword">this</span>.myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"><span class="number">8</span>	<span class="keyword">if</span> (!(<span class="string">'myObj'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</div><div class="line">　　　　<span class="built_in">window</span>.myObj = &#123; &#125;;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line"><span class="number">9</span>	　<span class="keyword">if</span> (myObj === <span class="literal">undefined</span>) &#123;</div><div class="line">　　　　<span class="keyword">var</span> myObj = &#123; &#125;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h5 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">foo()   <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时出现hoist的话，函数优先。</p>
<h5 id="window-onload和-document-ready-的区别，浏览器加载转圈结束时哪个时间点？"><a href="#window-onload和-document-ready-的区别，浏览器加载转圈结束时哪个时间点？" class="headerlink" title="window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？"></a>window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？</h5><p>感觉是完全加载完才停止转圈圈</p>
<h5 id="babel的使用规则"><a href="#babel的使用规则" class="headerlink" title="babel的使用规则"></a>babel的使用规则</h5><p><strong>配置</strong>：.babelrc 根据官方给的规则集配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    <span class="string">"es2015"</span>,</div><div class="line">    <span class="string">"react"</span>,</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>工具</strong>:</p>
<p>Babel-cli     用于命令行转码。</p>
<p>Babel-node    它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。</p>
<p>Babel-register    每当使用<code>require</code>加载<code>.js</code>、<code>.jsx</code>、<code>.es</code>和<code>.es6</code>后缀名的文件，就会先用Babel进行转码。</p>
<p>Babel-core    如果某些代码需要调用Babel的API进行转码，就要使用<code>babel-core</code>模块</p>
<p>Babel-polyfill        Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p>
<h5 id="js的内存泄露问题"><a href="#js的内存泄露问题" class="headerlink" title="js的内存泄露问题"></a>js的内存泄露问题</h5><p>垃圾回收机制：最常用的就是引用计数</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">&gt; <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存。</p>
<p><strong>ES6新出的Weakset和WeakMap</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</div><div class="line"></div><div class="line">wm.set(element, <span class="string">'some information'</span>);</div><div class="line">wm.get(element) <span class="comment">// "some information"</span></div></pre></td></tr></table></figure>
<p>这样，DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p><strong>常见的js内存泄露</strong>：</p>
<p>1.意外的全局变量。当你没用var声明的时候，默认帮到window全局，就有了引用，会一直占用内存。还有this误指到全局的。可以用use strict 检测这种情况。</p>
<p>2.并没有清除事件</p>
<p>setInterval(clearInterval)，addEventListener(removeEventListener)</p>
<p>3.IE6中dom对象引用了js对象，而dom对象在某个时刻被移除掉了，但js引擎不知道它被移除掉，还傻傻的保留着引用呢，就不会把js对象释放。</p>
<h5 id="url和uli的区别"><a href="#url和uli的区别" class="headerlink" title="url和uli的区别"></a>url和uli的区别</h5><p>总的来说，<strong>locators are also identifiers</strong>, so every URL is also a URI, but there are URIs which are not URLs.</p>
<h5 id="Dom渲染树渲染过程。-其实不同的浏览器引擎渲染过程稍有不同"><a href="#Dom渲染树渲染过程。-其实不同的浏览器引擎渲染过程稍有不同" class="headerlink" title="Dom渲染树渲染过程。 其实不同的浏览器引擎渲染过程稍有不同"></a>Dom渲染树渲染过程。 其实不同的浏览器引擎渲染过程稍有不同</h5><p><img src="/Users/centmaster/Documents/code/interview/FE-Learning/01-html知识点/images/browser-3.png" alt="browser-3"></p>
<h5 id="HTML和XHTML的区别"><a href="#HTML和XHTML的区别" class="headerlink" title="HTML和XHTML的区别"></a>HTML和XHTML的区别</h5><p>1.所有的标记都必须要有一个相应的结束标记<br>2.所有标签的元素和属性的名字都必须使用小写<br>3.所有的XML标记都必须合理嵌套<br>4.所有的属性必须用引号””括起来<br>5.把所有&lt;和&amp;特殊符号用编码表示<br>6.给所有属性赋一个值<br>7.不要在注释内容中使“–”<br>8.图片必须有说明文字</p>
<h5 id="怪异模式和标准模式的区别在哪（判断alert-window-top-document-compatMode-）"><a href="#怪异模式和标准模式的区别在哪（判断alert-window-top-document-compatMode-）" class="headerlink" title="怪异模式和标准模式的区别在哪（判断alert(window.top.document.compatMode) ）"></a>怪异模式和标准模式的区别在哪（判断alert(window.top.document.compatMode) ）</h5><ol>
<li><p>在严格模式中 ：width是内容宽度 ，元素真正的宽度 = marginLeft + borderLeftWidth + paddingLeft +<br>width + paddinRight + borderRightWidth +  marginRight;<br>在怪癖模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( paddingLeft + paddingRight +<br>borderLeftWidth + borderRightWidth)</p>
</li>
<li><p>可以设置行内元素的高宽<br>在Standards模式下，给span等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。</p>
</li>
<li><p>可设置百分比的高度<br>在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，<br>子元素设置一个百分比的高度是无效的。</p>
</li>
<li><p>用margin:0 auto设置水平居中在IE下会失效<br>使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,<br>quirk模式下的解决办法，用text-align属性:<br>body{text-align:center};</p>
<p>content{text-align:left}</p>
</li>
<li><p>quirk模式下设置图片的padding会失效</p>
</li>
<li><p>quirk模式下Table中的字体属性不能继承上层的设置</p>
</li>
<li><p>quirk模式下white-space:pre会失效</p>
</li>
</ol>
<h5 id="除了ajax之外，你知道fetch嘛"><a href="#除了ajax之外，你知道fetch嘛" class="headerlink" title="除了ajax之外，你知道fetch嘛"></a>除了ajax之外，你知道fetch嘛</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> response.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="http相应头和请求头"><a href="#http相应头和请求头" class="headerlink" title="http相应头和请求头"></a>http相应头和请求头</h5><table>
<thead>
<tr>
<th>相应头</th>
<th>请求头</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept  用户代理可处理的媒体类型</td>
<td>Accept-Ranges    是否接受字节范围请求</td>
</tr>
<tr>
<td>Authorization   web认证信息</td>
<td>Age    推算资源创建经过时间</td>
</tr>
<tr>
<td>Host    请求资源所在的服务器</td>
<td>Location    令客户端重定向至指定URI</td>
</tr>
<tr>
<td>If-match    比较ETag</td>
<td>WWW-Authenticate   服务器对客户端的认证信息</td>
</tr>
<tr>
<td>User-Agent     Http客户端程序信息</td>
<td>Server   http服务器的安装信息</td>
</tr>
<tr>
<td>Max-Forwards     最大传输跳转数</td>
<td>Allow    资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Range      实体的字节范围请求</td>
<td>Content-Type   实体主体的媒体类型</td>
</tr>
<tr>
<td>Referer     对请求中URI的原始获取方</td>
<td>Expires     过期时间</td>
</tr>
<tr>
<td></td>
<td>Last-Modified    资源最后的修改日期</td>
</tr>
<tr>
<td></td>
<td>Content-Length     资源主体大小</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h5 id="Http2-优势-https-segmentfault-com-a-1190000005085636"><a href="#Http2-优势-https-segmentfault-com-a-1190000005085636" class="headerlink" title="Http2 优势(https://segmentfault.com/a/1190000005085636)"></a>Http2 优势(<a href="https://segmentfault.com/a/1190000005085636" target="_blank" rel="external">https://segmentfault.com/a/1190000005085636</a>)</h5><p>多路复用        压缩头部    请求优先级        二进制            服务器推送</p>
<h5 id="两个页面之间通信"><a href="#两个页面之间通信" class="headerlink" title="两个页面之间通信"></a>两个页面之间通信</h5><h5 id="前端路由和后端路由的区别"><a href="#前端路由和后端路由的区别" class="headerlink" title="前端路由和后端路由的区别"></a>前端路由和后端路由的区别</h5><p>会造成假如两边都有一样的路径，就容易出bug</p>
<h5 id="为什么要使用这种框架而不用原生api操作dom，性能并没有优化"><a href="#为什么要使用这种框架而不用原生api操作dom，性能并没有优化" class="headerlink" title="为什么要使用这种框架而不用原生api操作dom，性能并没有优化"></a>为什么要使用这种框架而不用原生api操作dom，性能并没有优化</h5><p>但是对于coding的人来说，牺牲一点计算量可以大大的减轻coding人的工作量</p>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>严格模式的一些主要优点包括：</p>
<ul>
<li>使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。</li>
<li>防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。</li>
<li>消除 <code>this</code> 强制。如果没有严格模式，引用null或未定义的值到 <code>this</code> 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 <code>this</code> 值会抛出错误。</li>
<li>不允许重复的属性名称或参数值。当检测到对象（例如，<code>var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};</code>）中重复命名的属性，或检测到函数中（例如，<code>function foo(val1, val2, val1){}</code>）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。</li>
<li>使<code>eval()</code> 更安全。在严格模式和非严格模式下，<code>eval()</code> 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 <code>eval()</code> 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。</li>
<li>在 <code>delete</code>使用无效时抛出错误。<code>delete</code>操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。</li>
</ul>
<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">"number"</span>); <span class="comment">//true</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)</div><div class="line"><span class="built_in">Array</span>.isNaN(<span class="literal">NaN</span>)</div></pre></td></tr></table></figure>
<h5 id="isInteger实现"><a href="#isInteger实现" class="headerlink" title="isInteger实现"></a>isInteger实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> (x^<span class="number">0</span>) === x; &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.round(x) === x; &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &amp;&amp; (x % <span class="number">1</span> === <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h5 id="实现函数，-实现功能"><a href="#实现函数，-实现功能" class="headerlink" title="实现函数， 实现功能"></a>实现函数， 实现功能</h5><p>写一个 <code>sum</code>方法，在使用下面任一语法调用时，都可以正常工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>,<span class="number">3</span>));   <span class="comment">// Outputs 5</span></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>));  <span class="comment">// Outputs 5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (y !== <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">在这种情况下，由于 b 和 c都是对象，因此它们都将被转换为&quot;[object Object]&quot;</div><div class="line">var a=&#123;&#125;,</div><div class="line">    b=&#123;key:&apos;b&apos;&#125;,</div><div class="line">    c=&#123;key:&apos;c&apos;&#125;;</div><div class="line"> </div><div class="line">a[b]=123;</div><div class="line">a[c]=456;</div><div class="line"> </div><div class="line">console.log(a[b]);</div></pre></td></tr></table></figure>
<h5 id="单向绑定和双向绑定（http-www-jianshu-com-p-4ec74cb5b748）"><a href="#单向绑定和双向绑定（http-www-jianshu-com-p-4ec74cb5b748）" class="headerlink" title="单向绑定和双向绑定（http://www.jianshu.com/p/4ec74cb5b748）"></a>单向绑定和双向绑定（<a href="http://www.jianshu.com/p/4ec74cb5b748）" target="_blank" rel="external">http://www.jianshu.com/p/4ec74cb5b748）</a></h5><p>单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新</p>
<p>单向数据绑定缺点：HTML代码一旦生成完以后，就没有办法再变了，如果有新的数据来了，那就必须把之前的HTML代码去掉，再重新把新的数据和模板一起整合后插入到文档流中。</p>
<p>React可以算作单向数据中的一种。</p>
<p>双向数据绑定最经常的应用场景是表单，这样当用户在前端页面完成输入后，不用任何操作，就可以拿到用户的数据存放到数据模型中了。</p>
<p>数据模型（Module）和视图（View）之间的双向绑定。无论数据改变，或是用户操作，都能带来互相的变动，自动更新。适用于项目细节</p>
<h5 id="实现双向数据绑定的做法"><a href="#实现双向数据绑定的做法" class="headerlink" title="实现双向数据绑定的做法"></a>实现双向数据绑定的做法</h5><p>1.发布／订阅</p>
<p>2.<strong>脏检查（angular.js）</strong></p>
<p>原理是设置了一些条件，当你触发了这些条件之后，它就执行一个检测来遍历所有的数据，对比你更改了地方，然后执行变化</p>
<p><strong>3.ES7的Object.observe()</strong></p>
<p>最完美的方法，但是很多浏览器并不支持</p>
<p><strong>4.封装属性访问器/数据劫持（vue.js）</strong></p>
<p>结合发布者-订阅者模式的方式，通过ES5的<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code></p>
<h5 id="三种隐藏方式差别-visibility-hidden-display-none-opacity-0"><a href="#三种隐藏方式差别-visibility-hidden-display-none-opacity-0" class="headerlink" title="三种隐藏方式差别:visibility:hidden,display:none,opacity:0"></a>三种隐藏方式差别:visibility:hidden,display:none,opacity:0</h5><p>渲染上的差异:<br>1.将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的回流和重绘。</p>
<p>2.设置元素的visibility为hidden，和display:none的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会回流。</p>
<p>3.opacity:0,只是看不到元素,元素依然存在并且占有原有位置. 注: 事件绑定的差异: 1、display:none：元素彻底消失，不会触发绑定的事件.<br>2、visibility:hidden：无法触发其点击事件，有一种说法是display:none是元素看不见摸不着，而visibility:hidden是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。<br>3、opacity:0：可以触发点击事件，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发绑定事件<br>动画属性的差异: 1、display:none：完全不受transition属性的影响，元素立即消失<br>2、visibility：hidden：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果.<br>3、opacity:0,动画属性生效,能够进行正常的动画效果.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/algorithm/" itemprop="url">algorithm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:42:19+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a=<span class="number">123</span>;</div><div class="line"><span class="keyword">let</span> b=a.toString(<span class="number">2</span>);</div><div class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;</div><div class="line">  b=~b+<span class="number">1</span>;  <span class="comment">//取反加一就是取负值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="算法问题分类"><a href="#算法问题分类" class="headerlink" title="算法问题分类"></a>算法问题分类</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="广度优先遍历，深度优先遍历"><a href="#广度优先遍历，深度优先遍历" class="headerlink" title="广度优先遍历，深度优先遍历"></a>广度优先遍历，深度优先遍历</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> levelOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(!node) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Empty Tree'</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> que = []</div><div class="line">  que.push(node)</div><div class="line">  <span class="keyword">while</span>(que.length !== <span class="number">0</span>) &#123;</div><div class="line">    node = que.shift()</div><div class="line">    <span class="built_in">console</span>.log(node.value)</div><div class="line">    <span class="keyword">if</span>(node.left) que.push(node.left)</div><div class="line">    <span class="keyword">if</span>(node.right) que.push(node.right)</div><div class="line">  &#125;</div><div class="line">&#125;			<span class="comment">//广度利用队列</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preOrderUnRecur = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(!node) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Empty Tree'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> stack = []</div><div class="line">  stack.push(node)</div><div class="line">  <span class="keyword">while</span>(stack.length !== <span class="number">0</span>) &#123;</div><div class="line">    node = stack.pop()</div><div class="line">    <span class="built_in">console</span>.log(node.value)    </div><div class="line">    <span class="keyword">if</span>(node.right) stack.push(node.right)</div><div class="line">    <span class="keyword">if</span>(node.left) stack.push(node.left)</div><div class="line">  &#125;</div><div class="line">&#125;				<span class="comment">//深度利用栈</span></div></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> postOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;  </div><div class="line"><span class="keyword">if</span>(node)&#123;  </div><div class="line">postOrder(node.left);  </div><div class="line">postOrder(node.right);  </div><div class="line"><span class="built_in">console</span>.log(node.value);  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>  （2）链表反转；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pre=head;</div><div class="line"><span class="keyword">let</span> cur=head.next;</div><div class="line">pre.next=<span class="literal">null</span>;</div><div class="line"><span class="keyword">while</span>(cur.next!==<span class="literal">null</span>)&#123;</div><div class="line">  <span class="keyword">let</span> temp=cur.next;</div><div class="line">  cur.next=pre;</div><div class="line">  pre=cur;</div><div class="line">  cur=temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  （3）链表排序；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">let</span> i=head;</div><div class="line"><span class="keyword">let</span> j=head.next;</div><div class="line"><span class="keyword">let</span> base=i.val;</div><div class="line"><span class="keyword">while</span>(j!==<span class="literal">null</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(j.val&lt;base)&#123;</div><div class="line">    i=i.next;</div><div class="line">    swap(i,j);</div><div class="line">  &#125;</div><div class="line">  j=j.next;</div><div class="line">&#125;</div><div class="line">swap(i,head);</div><div class="line"> sort(head,i);</div><div class="line">  sort(i.next,j)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  （4）合并两个有序链表；</p>
<p>  （5）求出链表倒数第k个值；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fa=sl=head;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;k<span class="number">-2</span>;i++)&#123;</div><div class="line">  fa=fa.next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(fa.next!=<span class="literal">null</span>)&#123;</div><div class="line">  sl=sl.next;</div><div class="line">  fa=fa.next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> sl.val;</div></pre></td></tr></table></figure>
<p>  （6）判断链表是否有环，有环返回相遇节点；</p>
<p>​        快慢针，能相遇就说明有</p>
<p>  （7）在一个有环链表中找到环的入口；</p>
<p>​        从快慢相遇点开始走，另一个从起始点开始走，就能走到</p>
<p>​        推倒。设环长r，非环长l，相遇点距环口m.</p>
<p>​        l+m+t1r=(l+m+t2r)/2</p>
<p>​        l+m=(2*t1-t2)r=tr</p>
<p>​        l=tr-m=(r-m)+(t-1)r        所以一开始从那里走的话一定会在交叉点相会</p>
<p>  （8）删除当前给定节点node；</p>
<p>​        node.next=temp;</p>
<p>​        node.val=temp.val;</p>
<p>​        node.next=temp.next;        </p>
<p>  （9）找出链表的中间节点。快慢指针</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="斐波纳切-注意尾部回调"><a href="#斐波纳切-注意尾部回调" class="headerlink" title="斐波纳切 注意尾部回调"></a>斐波纳切 注意尾部回调</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">x,m=<span class="number">1</span>,n=<span class="number">0</span></span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(x&gt;<span class="number">2</span>)&#123;</div><div class="line">  	x--;</div><div class="line">  	<span class="keyword">return</span> fib(x,m+n,m);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="keyword">return</span> m+n;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">filt</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> result=[];</div><div class="line">        <span class="keyword">var</span> hash = &#123;&#125;;</div><div class="line">        array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">          <span class="keyword">if</span>(!hash[item])&#123;</div><div class="line">            result.push(item);</div><div class="line">            hash[item]=<span class="literal">true</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        <span class="built_in">console</span>.log(result);</div><div class="line">      &#125;</div><div class="line">filt();</div></pre></td></tr></table></figure>
<h5 id="判断两个json是否相同"><a href="#判断两个json是否相同" class="headerlink" title="判断两个json是否相同"></a>判断两个json是否相同</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> x=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;,y=&#123;<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">a</span>:<span class="number">1</span>&#125;,z=&#123;<span class="attr">a</span>:<span class="number">2</span>,<span class="attr">b</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="comment">//我能想到的方法就是便利每个变量，然后对比</span></div><div class="line">deter(x,y)  <span class="comment">//true</span></div><div class="line">deter(x,z)  <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h5 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stack</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.dataStore=[];</div><div class="line">     <span class="keyword">this</span>.top=<span class="number">0</span>;</div><div class="line">     <span class="keyword">this</span>.push=push;</div><div class="line">     <span class="keyword">this</span>.pop=pop;</div><div class="line">     <span class="keyword">this</span>.peek=peek;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.dataStore[top++]=element;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.top;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.top=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.dataStore=[];</div><div class="line">     <span class="keyword">this</span>.enqueue=enqueue;</div><div class="line">     <span class="keyword">this</span>.dequeue=dequeue;</div><div class="line">     <span class="keyword">this</span>.front=front;</div><div class="line">     <span class="keyword">this</span>.back=back;</div><div class="line">     <span class="keyword">this</span>.toString=toString;</div><div class="line">     <span class="keyword">this</span>.empty=empty;</div><div class="line">   &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.dataStore.push(element);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.dataStore.shift();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length<span class="number">-1</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> resstr=<span class="string">''</span>;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.dataStore.length;i++)&#123;</div><div class="line">       resstr+=<span class="keyword">this</span>.dataStore[i]+<span class="string">'/n'</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> resstr;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.element=element;</div><div class="line">     <span class="keyword">this</span>.next=<span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">llist</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="string">'head'</span>);</div><div class="line">     <span class="keyword">this</span>.find=find;</div><div class="line">     <span class="keyword">this</span>.insert=insert;</div><div class="line">     <span class="keyword">this</span>.remove=remove;</div><div class="line">     <span class="keyword">this</span>.display=display;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> curNode=<span class="keyword">this</span>.head;</div><div class="line">     <span class="keyword">while</span>(curNode!=item)&#123;</div><div class="line">       curNode=curNode.next;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> curNode;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newELement,item</span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> newNode=<span class="keyword">new</span> Node(newElment);</div><div class="line">     <span class="keyword">var</span> current=<span class="keyword">this</span>.find(item);</div><div class="line">     newNode.next=current.next;</div><div class="line">     current.next=newNode;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> curNode=<span class="keyword">this</span>.head;</div><div class="line">     <span class="keyword">while</span>(!(curNode.next==<span class="literal">null</span>))&#123;</div><div class="line">       print(curNode.next.element);</div><div class="line">       curNode=curNode.next;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findprevious</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> curNode=<span class="keyword">this</span>.head;</div><div class="line">     	<span class="keyword">while</span>(!(curNode.next==<span class="literal">null</span>)&amp;&amp;(curNode.next.element!=item))&#123;</div><div class="line">         curNode=curNode.next;</div><div class="line">     	&#125;</div><div class="line">     	<span class="keyword">return</span> curNode;</div><div class="line">   &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> previous=findprevious(item);</div><div class="line">     <span class="keyword">if</span>(!(previous.next.next==<span class="literal">null</span>))&#123;</div><div class="line">       previous.next=previous.next.next;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//双向链表</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.element=element;</div><div class="line">     <span class="keyword">this</span>.next=<span class="literal">null</span>;</div><div class="line">     <span class="keyword">this</span>.previous=<span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.head=<span class="keyword">new</span> Node(<span class="string">'head'</span>);</div><div class="line">     <span class="keyword">this</span>.find=find;</div><div class="line">     <span class="keyword">this</span>.insert=insert;</div><div class="line">     <span class="keyword">this</span>.display=display;</div><div class="line">     <span class="keyword">this</span>.remove=remove;</div><div class="line">     <span class="keyword">this</span>.findlast=findlast;</div><div class="line">     <span class="keyword">this</span>.dispReverse=dispReverse;</div><div class="line">&#125;</div><div class="line">funciton dispReverse()&#123;</div><div class="line">     <span class="keyword">var</span> curNode=<span class="keyword">this</span>.head;</div><div class="line">     curNode=<span class="keyword">this</span>.findLast();</div><div class="line">     <span class="keyword">while</span>(!(curNode==<span class="literal">null</span>))&#123;</div><div class="line">       print(curNode.element);</div><div class="line">       curNode=curNode.previous;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLast</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">var</span> curNode=<span class="keyword">this</span>.head;</div><div class="line">     <span class="keyword">while</span>(!(curNode.next==<span class="literal">null</span>))&#123;</div><div class="line">       curNode=curNode.next;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> curNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="深度优先和广度优先的遍历"><a href="#深度优先和广度优先的遍历" class="headerlink" title="深度优先和广度优先的遍历"></a>深度优先和广度优先的遍历</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wideTraversal</span>(<span class="params">selectNode</span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> nodes = [];  </div><div class="line">    <span class="keyword">if</span> (selectNode != <span class="literal">null</span>) &#123;  </div><div class="line">        <span class="keyword">var</span> queue = [];  </div><div class="line">        queue.unshift(selectNode);  </div><div class="line">        <span class="keyword">while</span> (queue.length != <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">var</span> item = queue.shift();  </div><div class="line">            nodes.push(item);  </div><div class="line">            <span class="keyword">var</span> children = item.children;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++)  </div><div class="line">                queue.push(children[i]);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> nodes;   </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> preOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (node) &#123;</div><div class="line">    <span class="built_in">console</span>.log(node.value);</div><div class="line">    preOrder(node.left);</div><div class="line">    preOrder(node.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(node)&#123;</div><div class="line">    inOrder(node.left);</div><div class="line">    <span class="built_in">console</span>.log(node.value);</div><div class="line">    inOrder(node.right);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> postOrder = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (node) &#123;</div><div class="line">    postOrder(node.left);</div><div class="line">    postOrder(node.right);</div><div class="line">    <span class="built_in">console</span>.log(node.value);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/FE-sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/FE-sum/" itemprop="url">FE-sum</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T21:41:55+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端技术积累"><a href="#前端技术积累" class="headerlink" title="前端技术积累"></a>前端技术积累</h1><p>[TOC]</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这个面经的来源一共分为三部分。第一部分是市面上的面经结合自己的知识总结。第二部分就是自己的面经，大大小小面了也有一些了，希望自己也能总结总结造福自己造福后人。最后一部分就是针对自己做过的东西，简历上的东西做的总结，不具有普遍性。当然文件夹里还有一些算法题，平常做前端的也要动动脑嘛。希望自己和大家都能找到满意的工作。</p>
<h2 id="第一部分-前端面经总结"><a href="#第一部分-前端面经总结" class="headerlink" title="第一部分 前端面经总结"></a>第一部分 前端面经总结</h2><p>大赞！<a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question/tree/master/%E5%89%8D%E7%AB%AF%E8%AF%95%E9%A2%98">https://github.com/paddingme/Front-end-Web-Development-Interview-Question/tree/master/%E5%89%8D%E7%AB%AF%E8%AF%95%E9%A2%98</a></p>
<h3 id="html基础"><a href="#html基础" class="headerlink" title="html基础"></a>html基础</h3><h5 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h5><h6 id="html"><a href="#html" class="headerlink" title="html"></a>html</h6><p>避免空链接（因为还是会请）</p>
<p>避免深层级嵌套</p>
<p>显示设置宽高</p>
<p>避免脚本阻塞加载</p>
<h6 id="css"><a href="#css" class="headerlink" title="css"></a>css</h6><p>避免使用@import</p>
<h6 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h6><p>事件代理</p>
<p>避免频繁的dom操作</p>
<h6 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h6><p>减少http请求次数</p>
<p>减少dns查找次数（缓存三十分钟，可以分块）</p>
<p>减少重定向</p>
<p>首屏加载，滚屏加载</p>
<p>能使用GET就用GET</p>
<p>使用外部js，css</p>
<p>减少cookie</p>
<h5 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h5><table>
<thead>
<tr>
<th>&amp;</th>
<th>get</th>
<th>post</th>
</tr>
</thead>
<tbody>
<tr>
<td>后退/刷新</td>
<td>无害</td>
<td>请求重新提交</td>
</tr>
<tr>
<td>书签</td>
<td>可做书签</td>
<td>不可做</td>
</tr>
<tr>
<td>缓存</td>
<td>可被缓存</td>
<td>不能被缓存</td>
</tr>
<tr>
<td>历史</td>
<td>保留在浏览器记录里</td>
<td>不保留</td>
</tr>
<tr>
<td>对数据长度限制</td>
<td>限制（2048字符）</td>
<td>不限制</td>
</tr>
<tr>
<td>安全性</td>
<td>url中暴露数据</td>
<td>相对安全</td>
</tr>
<tr>
<td>可见性</td>
<td>url中可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
<p>你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>
<p>业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到</p>
<p>GET和POST还有一个重大区别，简单的说：</p>
<p><strong>GET产生一个TCP数据包;POST产生两个TCP数据包。</strong></p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
<h5 id="What’s-the-difference-between-HTML-and-XHTML"><a href="#What’s-the-difference-between-HTML-and-XHTML" class="headerlink" title="What’s the difference between HTML and XHTML?"></a>What’s the difference between HTML and XHTML?</h5><p>XHTML is not so much different from HTML 4.01 standard. The major differences are:</p>
<ul>
<li>XHTML elements must be <strong>properly nested</strong>.</li>
<li>XHTML elements must always be <strong>closed</strong>.</li>
<li>XHTML elements must be in <strong>lowercase</strong>.</li>
<li>XHTML documents must have <strong>one root element</strong>.</li>
</ul>
<h5 id="XML到底是啥，和html有啥区别"><a href="#XML到底是啥，和html有啥区别" class="headerlink" title="XML到底是啥，和html有啥区别"></a>XML到底是啥，和html有啥区别</h5><p>一种语言的标准，比html更底层吧。XML是爹，主要是为了数据格式化，和json很像</p>
<h5 id="XPath又是啥，干了什么"><a href="#XPath又是啥，干了什么" class="headerlink" title="XPath又是啥，干了什么"></a>XPath又是啥，干了什么</h5><p>XPath stands for XML Path Language.It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an <a href="https://developer.mozilla.org/en-US/docs/XML" target="_blank" rel="external">XML</a> document.</p>
<p>XPath is mainly used in一种xml语言– <a href="https://developer.mozilla.org/en-US/docs/XSLT" target="_blank" rel="external">XSLT</a>, but can also be used as a much more powerful way of navigating through the <a href="https://developer.mozilla.org/en-US/docs/DOM" target="_blank" rel="external">DOM</a> of any XML-like language document, such as HTML and <a href="https://developer.mozilla.org/en-US/docs/XUL" target="_blank" rel="external">XUL</a>, instead of relying on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById" target="_blank" rel="external"><code>document.getElementById</code></a> method, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/childNodes" target="_blank" rel="external"><code>element.childNodes</code></a> properties, and other DOM Core features.</p>
<p>document.evaluate</p>
<h5 id="怪异模式和标准模式最大的区别是什么"><a href="#怪异模式和标准模式最大的区别是什么" class="headerlink" title="怪异模式和标准模式最大的区别是什么"></a>怪异模式和标准模式最大的区别是什么</h5><p>盒模型，怪异模式按IE那种border里边都算宽高。</p>
<h5 id="如何判断-一个对象是dom对象"><a href="#如何判断-一个对象是dom对象" class="headerlink" title="如何判断 一个对象是dom对象"></a>如何判断 一个对象是dom对象</h5><p>Obj instanceof HTMLElement   //HTMLCollection    HTMLDivElement.    nodeType</p>
<h5 id="h5标签了解多少"><a href="#h5标签了解多少" class="headerlink" title="h5标签了解多少"></a>h5标签了解多少</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;<span class="name">vedio</span>&gt;</span><span class="tag">&lt;<span class="name">source</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>语义化的好处</p>
<p>1去掉样式能让页面清晰的呈现出来</p>
<p>2屏幕阅读器会按标记读你的网页／移动端友好</p>
<p>3.有益于SEO，爬虫</p>
<p>4.方便同事共同开发</p>
</blockquote>
<h5 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h5><p>Gecko:Firefox</p>
<p>Presto:opera</p>
<p>Webkit:chrome,safari</p>
<p>Trident:IE</p>
<p>区分浏览器—navigator.userAgent</p>
<p>判断是否是IE-window.ActiveXObject</p>
<h5 id="NodeList-和-HTMLCollection之间的关系？"><a href="#NodeList-和-HTMLCollection之间的关系？" class="headerlink" title="NodeList 和 HTMLCollection之间的关系？"></a>NodeList 和 HTMLCollection之间的关系？</h5><p>主要不同在于HTMLCollection是元素集合而NodeList是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection </p>
<h5 id="rem实现自适应"><a href="#rem实现自适应" class="headerlink" title="rem实现自适应"></a>rem实现自适应</h5><p>相对于根元素决定字体大小。</p>
<h5 id="常见兼容性问题"><a href="#常见兼容性问题" class="headerlink" title="常见兼容性问题"></a>常见兼容性问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* 上下margin重合问题</div><div class="line">ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。</div><div class="line">解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</div></pre></td></tr></table></figure>
<h5 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">（1）创建新节点</div><div class="line"></div><div class="line">      createDocumentFragment()    //创建一个DOM片段</div><div class="line"></div><div class="line">      createElement()   //创建一个具体的元素</div><div class="line"></div><div class="line">      createTextNode()   //创建一个文本节点</div><div class="line"></div><div class="line">（2）添加、移除、替换、插入</div><div class="line"></div><div class="line">      appendChild()</div><div class="line"></div><div class="line">      removeChild()</div><div class="line"></div><div class="line">      replaceChild()</div><div class="line"></div><div class="line">      insertBefore() //在已有的子节点前插入一个新的子节点</div><div class="line"></div><div class="line">（3）查找</div><div class="line"></div><div class="line">      getElementsByTagName()    //通过标签名称</div><div class="line"></div><div class="line">      getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</div><div class="line"></div><div class="line">      getElementById()    //通过元素Id，唯一性</div></pre></td></tr></table></figure>
<h5 id="document-write和-innerHTML的区别"><a href="#document-write和-innerHTML的区别" class="headerlink" title="document.write和 innerHTML的区别"></a>document.write和 innerHTML的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.write只能重绘整个页面</div><div class="line"></div><div class="line">innerHTML可以重绘页面的一部分</div></pre></td></tr></table></figure>
<h5 id="DOM操作插入节点"><a href="#DOM操作插入节点" class="headerlink" title="DOM操作插入节点"></a>DOM操作插入节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> ndContainer = <span class="built_in">document</span>.getElementById(<span class="string">'js-list'</span>);</div><div class="line">    <span class="keyword">if</span> (!ndContainer) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> total = <span class="number">30000</span>;</div><div class="line">    <span class="keyword">const</span> batchSize = <span class="number">4</span>; <span class="comment">// 每批插入的节点次数，越大越卡</span></div><div class="line">    <span class="keyword">const</span> batchCount = total / batchSize; <span class="comment">// 需要批量处理多少次</span></div><div class="line">    <span class="keyword">let</span> batchDone = <span class="number">0</span>;  <span class="comment">// 已经完成的批处理个数</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">appendItems</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</div><div class="line">            <span class="keyword">const</span> ndItem = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">            ndItem.innerText = (batchDone * batchSize) + i + <span class="number">1</span>;</div><div class="line">            fragment.appendChild(ndItem);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 每次批处理只修改 1 次 DOM</span></div><div class="line">        ndContainer.appendChild(fragment);</div><div class="line"></div><div class="line">        batchDone += <span class="number">1</span>;</div><div class="line">        doBatchAppend();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doBatchAppend</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (batchDone &lt; batchCount) &#123;</div><div class="line">            <span class="built_in">window</span>.requestAnimationFrame(appendItems);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// kickoff</span></div><div class="line">    doBatchAppend();</div><div class="line"></div><div class="line">    ndContainer.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">const</span> target = e.target;</div><div class="line">        <span class="keyword">if</span> (target.tagName === <span class="string">'LI'</span>) &#123;</div><div class="line">            alert(target.innerHTML);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h6><p>DocumentFragment:文档碎片，虚拟的dom，优化了多次插入。</p>
<p>requestAnimationFrame:因为电脑屏幕是60帧，setInterval这些16.7并不好。</p>
<ul>
<li>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。</li>
<li>在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。</li>
</ul>
<p>如果想自己设置频率：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fps = <span class="number">15</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        requestAnimationFrame(draw);</div><div class="line">        <span class="comment">// Drawing code goes here</span></div><div class="line">    &#125;, <span class="number">1000</span> / fps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><h5 id="Overflow-hidden-是否形成新的块级格式化上下文？"><a href="#Overflow-hidden-是否形成新的块级格式化上下文？" class="headerlink" title="Overflow :hidden 是否形成新的块级格式化上下文？"></a>Overflow :hidden 是否形成新的块级格式化上下文？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;p&gt;I am floated&lt;/p&gt;</div><div class="line">    &lt;p&gt;So am I&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div &#123;overflow: hidden;&#125;</div><div class="line">p &#123;float: left;&#125;</div></pre></td></tr></table></figure>
<p>A：会形成。</p>
<p>会触发BFC的条件有：</p>
<ul>
<li>float的值不为none。</li>
<li>overflow的值不为visible。</li>
<li>display的值为table-cell, table-caption, inline-block 中的任何一个。</li>
<li>position的值不为relative 和static。</li>
</ul>
<h4 id="flex的使用"><a href="#flex的使用" class="headerlink" title="flex的使用"></a>flex的使用</h4><h5 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h5><p>Main axis:主轴线 从左到右 Cross axis:交叉轴线 从上到下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-direction: row | row-reverse | column | column-reverse;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-wrap: nowrap | wrap | wrap-reverse;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">justify-content: flex-start | flex-end | center | space-between | space-around;主轴对齐方式</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">align-items: flex-start | flex-end | center | baseline | stretch;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class="line">定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</div></pre></td></tr></table></figure>
<h5 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">order: <span class="xml"><span class="tag">&lt;<span class="name">integer</span>&gt;</span>;   数值越小，排列越靠前，默认为0</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-grow: <span class="xml"><span class="tag">&lt;<span class="name">number</span>&gt;</span>; 默认为0，即如果存在剩余空间，也不放大</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-shrink: <span class="xml"><span class="tag">&lt;<span class="name">number</span>&gt;</span>; 缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto;  定义了在分配多余空间之前，项目占据的主轴空间。就是设宽度</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flex: none|[ <span class="xml"><span class="tag">&lt;<span class="name">'flex-grow'</span>&gt;</span> <span class="tag">&lt;<span class="name">'flex-shrink'</span>&gt;</span>? || <span class="tag">&lt;<span class="name">'flex-basis'</span>&gt;</span> ]</span></div><div class="line"><span class="xml">            该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">允许单个项目有与其他项目不一样的对齐方式</div></pre></td></tr></table></figure>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><h6 id="骰子实现1239排列"><a href="#骰子实现1239排列" class="headerlink" title="骰子实现1239排列"></a>骰子实现1239排列</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</div><div class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</div><div class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">flex-end</span>;</div><div class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">space-between</span>;</div></pre></td></tr></table></figure>
<h6 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"HolyGrail"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"HolyGrail-body"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"HolyGrail-content"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"HolyGrail-nav"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"HolyGrail-ads"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.HolyGrail</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</div><div class="line">  <span class="attribute">flex-direction</span>: column;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">header</span>,</div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.HolyGrail-body</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.HolyGrail-content</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.HolyGrail-nav</span>, <span class="selector-class">.HolyGrail-ads</span> &#123;</div><div class="line">  <span class="comment">/* 两个边栏的宽度设为12em */</span></div><div class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">12em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.HolyGrail-nav</span> &#123;</div><div class="line">  <span class="comment">/* 导航放到最左边 */</span></div><div class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="固定低栏"><a href="#固定低栏" class="headerlink" title="固定低栏"></a>固定低栏</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"Site"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"Site-content"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.Site</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</div><div class="line">  <span class="attribute">flex-direction</span>: column;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.Site-content</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h5><table>
<thead>
<tr>
<th><a href="http://www.w3school.com.cn/cssref/selector_element_comma.asp" target="_blank" rel="external"><em>element</em>,<em>element</em></a></th>
<th>div,p</th>
<th>选择所有 <div> 元素和所有 <p> 元素。</p></div></th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_element_element.asp" target="_blank" rel="external"><em>element</em> <em>element</em></a></td>
<td>div p</td>
<td>选择 <div> 元素内部的所有 <p> 元素。</p></div></td>
<td>1</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_element_gt.asp" target="_blank" rel="external"><em>element</em>&gt;<em>element</em></a></td>
<td>div&gt;p</td>
<td>选择父元素为 <div> 元素的所有 <p> 元素。</p></div></td>
<td>2</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_element_plus.asp" target="_blank" rel="external"><em>element</em>+<em>element</em></a></td>
<td>div+p</td>
<td>选择紧接在 <div> 元素之后的所有 <p> 元素。</p></div></td>
<td>2</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_attribute.asp" target="_blank" rel="external">[<em>attribute</em>]</a></td>
<td>[target]</td>
<td>选择带有 target 属性所有元素。</td>
<td>2</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_attribute_value.asp" target="_blank" rel="external">[<em>attribute</em>=<em>value</em>]</a></td>
<td>[target=_blank]</td>
<td>选择 target=”_blank” 的所有元素。</td>
<td>2</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/cssref/selector_attribute_value_contain.asp" target="_blank" rel="external">[<em>attribute</em>~=<em>value</em>]</a></td>
<td>[title~=flower]</td>
<td>选择 title 属性包含单词 “flower” 的所有元素。</td>
<td>2</td>
</tr>
<tr>
<td>[[<em>attribute</em>\</td>
<td>=<em>value</em>]](<a href="http://www.w3school.com.cn/cssref/selector_attribute_value_start.asp" target="_blank" rel="external">http://www.w3school.com.cn/cssref/selector_attribute_value_start.asp</a>)</td>
<td>[lang\</td>
<td>=en]</td>
<td>选择 lang 属性值以 “en” 开头的所有元素。</td>
<td>2</td>
</tr>
</tbody>
</table>
<h5 id="screen关键词是指设备物理屏幕的大小还是指浏览器的视窗？"><a href="#screen关键词是指设备物理屏幕的大小还是指浏览器的视窗？" class="headerlink" title="screen关键词是指设备物理屏幕的大小还是指浏览器的视窗？"></a>screen关键词是指设备物理屏幕的大小还是指浏览器的视窗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@media only screen and (max-width: 1024px) &#123;margin: 0;&#125;</div></pre></td></tr></table></figure>
<p>A: 浏览器视窗</p>
<h5 id="Difference-between-block-inline-block-inline"><a href="#Difference-between-block-inline-block-inline" class="headerlink" title="Difference between block  inline-block inline"></a>Difference between block  inline-block inline</h5><p>大体来说HTML元素各有其自身的布局级别（block元素还是inline元素）：</p>
<p>常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6, DL, OL, UL 等。</p>
<p>常见的内联元素有 SPAN, A, STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。</p>
<p>block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。</p>
<ul>
<li>display:block</li>
</ul>
<ol>
<li><ol>
<li>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。</li>
<li>block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。</li>
<li>block元素可以设置margin和padding属性。</li>
</ol>
</li>
</ol>
<ul>
<li>display:inline</li>
</ul>
<ol>
<li><ol>
<li>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</li>
<li>inline元素设置width,height属性无效。</li>
<li>inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</li>
</ol>
</li>
</ol>
<ul>
<li>display:inline-block</li>
</ul>
<ol>
<li><ol>
<li><p>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p>
<p>​</p>
</li>
</ol>
</li>
</ol>
<h5 id="Difference-between-transition-and-animation"><a href="#Difference-between-transition-and-animation" class="headerlink" title="Difference between transition and animation"></a>Difference between transition and animation</h5><h6 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">height</span>:<span class="number">15px</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">15px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span>&#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">450px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> <span class="number">1s</span> height ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只选择效果时间。transition的优点在于简单易用，但是它有几个很大的局限。</p>
<p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p>
<p>（2）transition是一次性的，不能重复发生，除非一再触发。</p>
<p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p>
<p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p>
<h5 id="css圆角"><a href="#css圆角" class="headerlink" title="css圆角"></a>css圆角</h5><p>如果是长度，就是圆角的半径，0就是直角。</p>
<p>如果是百分比，超过50%，四个角就合成椭圆了</p>
<h5 id="mypic-jpg会被浏览器加载吗？"><a href="#mypic-jpg会被浏览器加载吗？" class="headerlink" title="mypic.jpg会被浏览器加载吗？"></a>mypic.jpg会被浏览器加载吗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;test1&quot;&gt;</div><div class="line">    &lt;span id=&quot;test2&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">#test1 &#123;</div><div class="line">    display: none;</div><div class="line">&#125;</div><div class="line">#test2 &#123;</div><div class="line">    background-image: url(&apos;mypic.jpg&apos;);</div><div class="line">    visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A: 不会被下载。</p>
<h5 id="What-is-Flash-of-Unstyled-Content-How-do-you-avoid-FOUC"><a href="#What-is-Flash-of-Unstyled-Content-How-do-you-avoid-FOUC" class="headerlink" title="What is Flash of Unstyled Content? How do you avoid FOUC?"></a>What is Flash of Unstyled Content? How do you avoid FOUC?</h5><p>原因大致为：1，使用import方法导入样式表。2，将样式表放在页面底部3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p>解决方法：使用LINK标签将样式表放在文档HEAD中。</p>
<h5 id="隐藏元素的方法"><a href="#隐藏元素的方法" class="headerlink" title="隐藏元素的方法"></a>隐藏元素的方法</h5><p>Display,visibility,opacity,position:absolute;top:-9999px;</p>
<h5 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="{ box-sizing: border-box; }"></a>{ box-sizing: border-box; }</h5><p>固定了盒子的尺寸，无论怎么调整边距都不会改变盒子的大小.似乎是padding变了</p>
<h3 id="Js基础"><a href="#Js基础" class="headerlink" title="Js基础"></a>Js基础</h3><h5 id="JS原生自定义事件"><a href="#JS原生自定义事件" class="headerlink" title="JS原生自定义事件"></a>JS原生自定义事件</h5><p><strong>在某个对象上绑定不同类别的一个或多个方法，并且让它们分别执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventHandle = &#123;</div><div class="line">    on: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events,fn</span>)</span>&#123;</div><div class="line">        obj.listeners = obj.listeners || &#123;&#125;;</div><div class="line">        obj.listeners[events] = obj.listeners[events] || [];</div><div class="line">        obj.listeners[events].push(fn);</div><div class="line">    &#125;,</div><div class="line">    fire: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123;</div><div class="line">            <span class="built_in">console</span>.log(obj.listeners[events]);</div><div class="line">            obj.listeners[events][i] &amp;&amp; obj.listeners[events][i]();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    off: <span class="function"><span class="keyword">function</span>(<span class="params">obj,events</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123;</div><div class="line">            obj.listeners[events][i] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//绑定自定义事件，</span></div><div class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;);<span class="comment">//准备执行方法1</span></div><div class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;);<span class="comment">//准备执行方法2</span></div><div class="line">eventHandle.on(oDiv,<span class="string">"eventType1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;);<span class="comment">//准备执行方法3</span></div><div class="line">eventHandle.on(oDiv,<span class="string">"eventType2"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;);<span class="comment">//准备执行方法4</span></div><div class="line"></div><div class="line"><span class="comment">//触发执行</span></div><div class="line">eventHandle.fire(oDiv,<span class="string">"eventType1"</span>);<span class="comment">//执行eventType1下的所有方法</span></div></pre></td></tr></table></figure>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型    构造函数        实例三者之间关系</p>
<p>JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<ul>
<li>每个对象都有一个指向它的原型的的内部链接(此链接还没有规范的访问方式，一般用<strong>proro</strong>代替),这个原型也有自己的原型，直到每个对象的原型为<code>null</code>为止</li>
<li>任意一个函数都可以作为构造器即<code>var someFun = new AnyFun()</code></li>
<li>每个函数都有一个<code>prototype</code>属性，其它对象没有，该属性也是一个对象，该对象有一个<code>constructor</code>属性指向该函数</li>
<li>使用<code>new</code>去实例化一个函数后，得到的是一个对象。该函数的实例的原型指向构造函数的<code>prototype</code>属性</li>
<li>每个对象都有自己的属性和方法，如果没有找到就会沿着自己的原型链一直往上去找</li>
</ul>
<h5 id="js的继承和继承的方法和优缺点？"><a href="#js的继承和继承的方法和优缺点？" class="headerlink" title="js的继承和继承的方法和优缺点？"></a>js的继承和继承的方法和优缺点？</h5><p><a href="http://www.zyy1217.com/2017/03/13/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">http://www.zyy1217.com/2017/03/13/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F/</a></p>
<p>区别类的继承和实例化</p>
<p>非常常用的类继承是这个样子的：</p>
<p><code>B.prototype = new A()</code><br>这时候特别容易和实例化给混淆了(反正我混了<em>—</em>)：<br><code>b = new A()</code></p>
<h5 id="js的继承方式"><a href="#js的继承方式" class="headerlink" title="js的继承方式"></a>js的继承方式</h5><p>下面的这些怎么判断，直接看是不是在prototype上，在的话就会共用，不在的话就没有复用。</p>
<p>那为什么放在原型上就可以复用呢？</p>
<p>因为每个实例都可以顺着原型链找到student.prototype，所以放在上游大家就能复用了。不放在上游等于没次构造函数就实例化一次，浪费了。</p>
<p>1.原型链继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Super = functioin(name) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super(<span class="string">'eric'</span>);  <span class="comment">//通过改变原型对象实现继承</span></div><div class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub(<span class="string">'male'</span>)</div><div class="line">     sub2 = <span class="keyword">new</span> Sub(<span class="string">'female'</span>);</div><div class="line"></div><div class="line">sub1.setName(<span class="string">'ada'</span>);</div><div class="line"><span class="comment">// 这里必须通过setName方法来修改继承来的name属性。</span></div><div class="line"><span class="comment">// 如果通过sub1.name== 'ada',就打不到目的，因为此时sub1对象上没有name属性，</span></div><div class="line"><span class="comment">// 这样等于为该对象添加了新的属性，而不是修改继承而来的name属性。</span></div><div class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// ada,可见此sub2的name也会被修改掉</span></div><div class="line"><span class="built_in">console</span>.log(sub1.getName === sub2.getName) <span class="comment">// true,复用了方法</span></div></pre></td></tr></table></figure>
<p><strong>优点：</strong>父类的方法得到了复用。</p>
<p><strong>缺点：</strong>同理父类的属性也是复用，即子类实例没有自己的属性。</p>
<p>new多个实例，改变其中一个，其他的属性也会被更改</p>
<p>2.借用构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex,name</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>,name); <span class="comment">// 调用父类方法为子类实例添加属性</span></div><div class="line">    <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub(<span class="string">'male'</span>,<span class="string">'eric'</span>),</div><div class="line">     sub2 = <span class="keyword">new</span> Sub(<span class="string">'female'</span>,<span class="string">'eric'</span>);</div><div class="line">sub1.name = <span class="string">'ada'</span>;</div><div class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// eric,实例的属性没有相互影响</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sub1.getName === sub2.getName); <span class="comment">// false,可见方法没有复用</span></div></pre></td></tr></table></figure>
<p><strong>优点：</strong>子类的每个实例都有自己的属性（name），不会相互影响。</p>
<p><strong>缺点：</strong>但是继承父类方法的时候就不需要这种特性，没有实现父类方法的复用。</p>
<p>3.组合继承    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Super.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>: Super, // 保持构造函数和原型对象的完整性</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>,<span class="string">'eric'</span>); <span class="comment">//继承父类属性</span></div><div class="line">    <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super(<span class="string">'eric'</span>); <span class="comment">//继承父类方法</span></div><div class="line">Sub.prototype.constructor = Sub;</div><div class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub(<span class="string">'male'</span>),</div><div class="line">    sub2 = <span class="keyword">new</span> Sub(<span class="string">'female'</span>);</div><div class="line"><span class="comment">// 可以按上述两种方法验证，复用了父类的方法，实例没有复用，达到目的</span></div></pre></td></tr></table></figure>
<p><strong>优点：</strong>继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性。</p>
<p><strong>缺点：</strong>因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费。</p>
<p>4.原型式继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">	F.prototype = o;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.寄生组合继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Super.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>: Super,</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> Sub = <span class="function"><span class="keyword">function</span>(<span class="params">sex,name</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 组合继承的缺点就是在继承父类方法的时候调用了父类构造函数，从而造成内存浪费，</span></div><div class="line"><span class="comment">// 现在只要解决了这个问题就完美了。那在复用父类方法的时候，</span></div><div class="line"><span class="comment">// 使用Object.create方法也可以达到目的，没有调用父类构造函数，问题解决。</span></div><div class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</div><div class="line">Sub.prototype.constructor = Sub;</div></pre></td></tr></table></figure>
<p>这特么不就是，你原型用人家的原型没动构造函数，你直接又把人家构造函数拿过来。齐活！</p>
<p>通过在父类原型和子类原型之间加入一个临时的构造函数F，切断了子类原型和父类原型之间的联系，这样当子类原型做修改时就不会影响到父类原型。</p>
<p>6.es6中的class</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>() </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">this</span>.name = props.name || <span class="string">'eric'</span>;</div><div class="line">    &#125;</div><div class="line">    setName(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    getName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props); <span class="comment">// 创建实例，继承父类属性和方法</span></div><div class="line">        <span class="keyword">this</span>.sex = props.sex || <span class="string">'male'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub(&#123;</div><div class="line">    name: <span class="string">'eric'</span>,</div><div class="line">    sex: <span class="string">'male'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> Sub(&#123;</div><div class="line">    name: <span class="string">'eric'</span>,</div><div class="line">    sex: <span class="string">'female'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">sub1.setName(<span class="string">'ada'</span>);</div><div class="line"><span class="built_in">console</span>.log(sub1.getName(),sub2.getName()) <span class="comment">// ada,eric,属性没复用，各自实例都有自己的属性。</span></div><div class="line"><span class="built_in">console</span>.log(sub1.getName === sub2.getName) <span class="comment">// true; 复用了父类的方法</span></div><div class="line"><span class="built_in">console</span>.log(Sub.prototype.sex) <span class="comment">// undefined</span></div><div class="line"><span class="comment">// 子类原型对象上没有父类构造函数中赋值的属性，不是组合式继承</span></div></pre></td></tr></table></figure>
<p><strong>由以上结果可以看到es6中的class只不过是一种语法糖，通过上面的验证得知符合寄生组合继承的特点</strong></p>
<h5 id="原始数据结构类型和引用类型的区别"><a href="#原始数据结构类型和引用类型的区别" class="headerlink" title="原始数据结构类型和引用类型的区别"></a>原始数据结构类型和引用类型的区别</h5><p>（讲的特好<a href="https://segmentfault.com/a/1190000008472264）" target="_blank" rel="external">https://segmentfault.com/a/1190000008472264）</a></p>
<h6 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h6><p>1.基本数据类型的值都是不可变的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"change"</span>;</div><div class="line">name = <span class="string">"change1"</span>;</div><div class="line"><span class="built_in">console</span>.log(name)<span class="comment">//change1</span></div></pre></td></tr></table></figure>
<p>原来的change并没有改变，只是将指针指向了change1</p>
<p>2.基本数据类型不可以添加属性和方法</p>
<p>3.基本数据类型的赋值是简单的赋值。就直接把值给你</p>
<p>4.基本数据类型值的比较是值的比较</p>
<p>5.基本数据类型存放在栈区</p>
<p>包括变量的标识符和值</p>
<h6 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h6><p>1.引用类型的值是可以改变的</p>
<p>2.引用类型可以添加属性和方法</p>
<p>3.引用类型的赋值是对象的引用（只是把指针给你）</p>
<p>4.引用类型的比较是引用的比较</p>
<p>5.引用类型是同时存在栈和堆中</p>
<p>引用类型的存储需要在内存的栈区和堆区共同完成，栈区保存变量标识符和指向堆内存的地址</p>
<h6 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h6><p>ECMAScript还提供了三个特殊的引用类型Boolean,String,Number.我们称这三个特殊的引用类型为基本包装类型，也叫包装对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"helloworld"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>所以当第二行代码访问s1的时候，后台会自动完成下列操作：</p>
<ol>
<li>创建String类型的一个实例；// var s1 = new String(“helloworld”);</li>
<li>在实例上调用指定方法；// var s2 = s1.substr(4);</li>
<li>销毁这个实例；// s1 = null;</li>
</ol>
<p>正因为有第三步这个销毁的动作，所以你应该能够明白为什么基本数据类型不可以添加属性和方法，这也正是基本装包类型和引用类型主要区别：对象的生存期.使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中.而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'A'</span>);</div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'A'</span>);</div><div class="line">a==b	<span class="comment">//false</span></div></pre></td></tr></table></figure>
<h6 id="Null-和-Undefined-的区别"><a href="#Null-和-Undefined-的区别" class="headerlink" title="Null 和 Undefined 的区别"></a>Null 和 Undefined 的区别</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>(Null)<span class="comment">//0</span></div><div class="line"><span class="number">5</span>+Null <span class="comment">//5</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)<span class="comment">// NaN</span></div><div class="line"><span class="number">5</span> + <span class="literal">undefined</span><span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<p><strong>null表示”没有对象”，即该处不应该有值</strong></p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。 //new Object(null). 没有继承任何对象，自己就是终点</p>
<p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</strong></p>
<p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
<p>（4）函数没有返回值时，默认返回undefined。</p>
<h5 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h5><p>descriptor中定义的参数用来定义或修改的属性的描述符</p>
<p><code>configurable</code> 当且仅当该属性的 configurable 为 true 时，该属性<code>描述符</code>才能够被改变，也能够被删除。</p>
<p><code>enumerable</code>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。。 </p>
<p>属性特性 <code>enumerable</code> 决定这个属性是否能被 <code>for...in</code> 循环或 <code>Object.keys</code> 方法遍历得到</p>
<p><code>writable</code>当且仅当该属性的 writable 为 true 时，该属性才能被<code>[赋值运算符]</code>改变。</p>
<p><code>value</code>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</p>
<p><code>get</code>一个给属性提供 getter 的方法，如果没有 getter 则为 <code>undefined</code>。该方法返回值被用作属性值。</p>
<p><code>set</code>一个给属性提供 setter 的方法，如果没有 setter 则为 <code>undefined</code>。该方法将接受唯一参数，并将该参数的新值分配给该属性。</p>
<h5 id="关于对象添加getter和setter的方法"><a href="#关于对象添加getter和setter的方法" class="headerlink" title="关于对象添加getter和setter的方法"></a>关于对象添加getter和setter的方法</h5><p>1.通过对象初始化器在创建对象的时候指明（也可以称为通过字面值创建对象时声明）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = &#123;</div><div class="line">        a : <span class="number">7</span>,</div><div class="line">        get b()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a +<span class="number">1</span>;&#125;,<span class="comment">//通过 get,set的 b,c方法间接性修改 a 属性</span></div><div class="line">        set c(x)&#123;<span class="keyword">this</span>.a = x/<span class="number">2</span>&#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">console</span>.log(o.a);</div><div class="line">    <span class="built_in">console</span>.log(o.b);</div><div class="line">    o.c = <span class="number">50</span>;</div><div class="line">    <span class="built_in">console</span>.log(o.a);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>2.使用 <code>Object.create</code> 方法. Object.create(proto, [ propertiesObject ])</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="literal">null</span>;</div><div class="line">    o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,<span class="comment">//指定原型为 Object.prototype</span></div><div class="line">            &#123;</div><div class="line">                bar:&#123;</div><div class="line">                    get :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">                    &#125;,</div><div class="line">                    set : <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">                        <span class="built_in">console</span>.log(<span class="string">"Setting `o.bar` to "</span>,val);</div><div class="line">                        <span class="keyword">this</span>.a = val;</div><div class="line">                    &#125;,</div><div class="line">                    configurable :<span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">            &#125;<span class="comment">//第二个参数</span></div><div class="line">        );</div><div class="line">    o.a = <span class="number">10</span>;</div><div class="line">    <span class="built_in">console</span>.log(o.bar);</div><div class="line">    o.bar = <span class="number">12</span>;</div><div class="line">    <span class="built_in">console</span>.log(o.bar);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>3.使用 <code>Object.defineProperty</code> 方法.    Object.defineProperty(obj, prop, descriptor)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = &#123; <span class="attr">a</span> : <span class="number">1</span>&#125;<span class="comment">//声明一个对象,包含一个 a 属性,值为1</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(o,<span class="string">"b"</span>,&#123;</div><div class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">        &#125;,</div><div class="line">        set : <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.a = val;</div><div class="line">        &#125;,</div><div class="line">        configurable : <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(o.b);</div><div class="line">    o.b = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(o.b);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>4.使用 <code>Object.defineProperties</code>方法.   Object.defineProperties(obj, props)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="string">"string"</span>&#125;;</div><div class="line">    <span class="built_in">Object</span>.defineProperties(obj,&#123;</div><div class="line">        <span class="string">"A"</span>:&#123;</div><div class="line">            get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a+<span class="number">1</span>;&#125;,</div><div class="line">            set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;<span class="keyword">this</span>.a = val;&#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"B"</span>:&#123;</div><div class="line">            get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.b+<span class="number">2</span>;&#125;,</div><div class="line">            set:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;<span class="keyword">this</span>.b = val&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(obj.A);</div><div class="line">    <span class="built_in">console</span>.log(obj.B);</div><div class="line">    obj.A = <span class="number">3</span>;</div><div class="line">    obj.B = <span class="string">"hello"</span>;</div><div class="line">    <span class="built_in">console</span>.log(obj.A);</div><div class="line">    <span class="built_in">console</span>.log(obj.B);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h5 id="对象的扩展，密封以及冻结"><a href="#对象的扩展，密封以及冻结" class="headerlink" title="对象的扩展，密封以及冻结"></a>对象的扩展，密封以及冻结</h5><ul>
<li><p>扩展特性</p>
<ul>
<li><p><code>Object.isExtensible</code> 方法</p>
<p>可扩展和上述的可修改不是一个概念</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象是否可以扩展与对象的属性是否可以配置无关</span></div><div class="line">empty = <span class="built_in">Object</span>.create(&#123;&#125;,&#123;</div><div class="line">    <span class="string">"a"</span>:&#123;</div><div class="line">        value : <span class="number">1</span>,</div><div class="line">        configurable : <span class="literal">false</span>,<span class="comment">//不可配置</span></div><div class="line">        enumerable : <span class="literal">true</span>,<span class="comment">//可枚举</span></div><div class="line">        writable : <span class="literal">true</span><span class="comment">//可写</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(empty) === <span class="literal">true</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>Object.preventExtensions</code> 方法</p>
<p>修改为不可扩展。如果为当前不可扩展对象 empty 修改属性是成功的，这是因为一个对象的属性是否可以被修改与该对象是否可以扩展无关，而是与该对象在创建的时候是否声明为不可重写有关</p>
</li>
</ul>
</li>
<li><p>密封特性</p>
<ul>
<li><p><code>Object.isSealed</code> 方法</p>
<p>密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//新建的对象默认不是密封的</span></div><div class="line">    <span class="keyword">var</span> empty = &#123;&#125;;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(empty) === <span class="literal">false</span>);<span class="comment">//true</span></div><div class="line"></div><div class="line">    <span class="comment">//如果把一个空对象变得不可扩展,则它同时也会变成个密封对象.</span></div><div class="line">    <span class="built_in">Object</span>.preventExtensions(empty);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(empty) === <span class="literal">true</span>);<span class="comment">//true</span></div><div class="line"></div><div class="line">    <span class="comment">//但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.</span></div><div class="line">    <span class="keyword">var</span> hasProp = &#123;<span class="attr">fee</span> : <span class="string">"fie foe fum"</span>&#125;;</div><div class="line">    <span class="built_in">Object</span>.preventExtensions(hasProp);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(hasProp) === <span class="literal">false</span>);<span class="comment">//true</span></div><div class="line"></div><div class="line">    <span class="comment">//如果把这个属性变得不可配置,则这个对象也就成了密封对象.</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(hasProp,<span class="string">"fee"</span>,&#123;<span class="attr">configurable</span> : <span class="literal">false</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(hasProp) === <span class="literal">true</span>);<span class="comment">//true</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
<li><p><code>Object.seal</code> 方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.seal(o);  <span class="comment">//与下面的操作效果相同</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">"a"</span>,&#123;<span class="attr">configurable</span>:<span class="literal">false</span>,<span class="attr">writable</span>:<span class="literal">false</span>&#125;);</div><div class="line"><span class="built_in">Object</span>.preventExtensions(o);</div></pre></td></tr></table></figure>
</li>
<li><p>冻结特性</p>
<ul>
<li><p><code>Object.isFrozen</code> 方法</p>
<p>冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Object.freeze</code> 方法</p>
<ul>
<li><p><code>浅冻结</code> 与 <code>深冻结</code></p>
<p>倘若一个对象的属性是一个对象，那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。</p>
<p>深冻结：遍历递归操作冻结每一层</p>
</li>
</ul>
</li>
</ul>
<h5 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h5><h6 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#tab"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>))</span>&#123;</div><div class="line">   <span class="keyword">var</span> $obj=$(ev.target);</div><div class="line">   $obj.css(<span class="string">"background"</span>,<span class="string">"red"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ulNode=<span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</div><div class="line">ulNode.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">     <span class="keyword">if</span>(e.target&amp;&amp;e.target.nodeName.toUpperCase()==<span class="string">"LI"</span>)&#123;<span class="comment">/*判断目标事件是否为li*/</span></div><div class="line">       alert(e.target.innerHTML);</div><div class="line">     &#125;</div><div class="line">   &#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h5 id="async和defer的作用是什么？有什么区别"><a href="#async和defer的作用是什么？有什么区别" class="headerlink" title="async和defer的作用是什么？有什么区别"></a>async和defer的作用是什么？有什么区别</h5><p>1.<script src="example.js"></script></p>
<p>没有defer或async属性，浏览器会立即加载并执行相应的脚本。也就是说在渲染script标签之后的文档之前，不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载；<br>2.<script async src="example.js"></script></p>
<p>有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；（异步加载，加载完马上执行）<br>3.<script defer src="example.js"></script></p>
<p>有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。(不耽误后边文档加载，但是都加载完执行。)</p>
<h5 id="event对象属性方法"><a href="#event对象属性方法" class="headerlink" title="event对象属性方法"></a>event对象属性方法</h5><p>onblur onload onkeyup onmouseup</p>
<h5 id="for-in-和for-of的区别是什么"><a href="#for-in-和for-of的区别是什么" class="headerlink" title="for in 和for of的区别是什么"></a>for in 和for of的区别是什么</h5><p>for in 遍历的是索引. 还可以遍历对象，但是可能会遍历到继承的元素方法，使用hasOwnProperty（）判断</p>
<p>for of遍历的是对应的元素值</p>
<p>遍历对象新出的 Object.keys() Object.values. Object.entires()</p>
<h5 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h5><p>Object.keys.    for..in</p>
<h5 id="深复制与浅复制"><a href="#深复制与浅复制" class="headerlink" title="深复制与浅复制"></a>深复制与浅复制</h5><p>1.直接用等号赋值 浅复制</p>
<p>2.Object.assign() 居然也是浅复制.   因为copy对象的时候是复制指针</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</div><div class="line"> <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span></div><div class="line"> </div><div class="line"> obj1.a = <span class="number">1</span>;</div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125;</span></div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span></div><div class="line"> </div><div class="line"> obj2.a = <span class="number">2</span>;</div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// &#123; a: 1, b: &#123; c: 0&#125;&#125;</span></div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">// &#123; a: 2, b: &#123; c: 0&#125;&#125;</span></div><div class="line"> </div><div class="line"> obj2.b.c = <span class="number">3</span>;</div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj1)); <span class="comment">// &#123; a: 1, b: &#123; c: 3&#125;&#125;</span></div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2)); <span class="comment">// &#123; a: 2, b: &#123; c: 3&#125;&#125;</span></div><div class="line"> </div><div class="line"> <span class="comment">// Deep Clone</span></div><div class="line"> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span> , <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>&#125;&#125;;</div><div class="line"> <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</div><div class="line"> obj1.a = <span class="number">4</span>;</div><div class="line"> obj1.b.c = <span class="number">4</span>;</div><div class="line"> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj3)); <span class="comment">// &#123; a: 0, b: &#123; c: 0&#125;&#125;</span></div></pre></td></tr></table></figure>
<p>3.jQuery.extend     vue的touch函数？</p>
<p>4.Json.parse. Json.stringify</p>
<h5 id="闭包-！"><a href="#闭包-！" class="headerlink" title="闭包 ！"></a>闭包 ！</h5><h6 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h6><p>定义：当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p>
<p>辨认：就两点，1内部有一个函数保存了作用域内的变量   2这个变量暴露暴露出来</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(message)</div><div class="line">  &#125;,<span class="number">1000</span>);</div><div class="line">&#125;   <span class="comment">//不是非得return出去才叫暴露</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">name,selector</span>)</span>&#123;</div><div class="line">  $(selector).click(<span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name)</div><div class="line">  &#125;);</div><div class="line">&#125;  <span class="comment">//在任务中，只要使用了回调函数，实际上就是在使用闭包</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">start</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> count = start;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            count++;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = Counter(<span class="number">4</span>);</div><div class="line">foo.increment();</div><div class="line">foo.get(); <span class="comment">// 5    其实这就是模块的写法</span></div></pre></td></tr></table></figure>
<h6 id="闭包与setTimeout"><a href="#闭包与setTimeout" class="headerlink" title="闭包与setTimeout"></a>闭包与setTimeout</h6><p>因为for循环他们共享同一个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i &#125;);  <span class="comment">// (*)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">// 5 (not 3)</span></div></pre></td></tr></table></figure>
<p>改变函数使得输出12345</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>answer</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </div><div class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">	&#125;,i*<span class="number">1000</span>)</div><div class="line">     &#125;)(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">  setTimeout((<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)(i)</div><div class="line">  &#125;,i*<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line">             </div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(e);</div><div class="line">        &#125;</div><div class="line">    &#125;)(i), <span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    output(i);  <span class="comment">// 这里传过去的 i 值被复制了</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div></pre></td></tr></table></figure>
<p>使用Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></div><div class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">        resolve();</div><div class="line">    &#125;, <span class="number">1000</span> * i);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 生成全部的异步操作</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    tasks.push(output(i));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异步操作完成之后，输出最后的 i</span></div><div class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟其他语言中的 sleep，实际上可以是任何异步操作</span></div><div class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, timeountMS);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;  <span class="comment">// 声明即执行的 async 函数表达式</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>变异啦！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">1000</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;          <span class="comment">//内部其实没有对参数的引用，所以还是55555</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">1000</span>);</div><div class="line">  &#125;)();</div><div class="line">&#125;			<span class="comment">//undefined x5</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;)(i), i * <span class="number">1000</span>);</div><div class="line">&#125;				<span class="comment">//立即执行函数立即执行，setTimeout就等于传了个undefined。会立刻输出01234</span></div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		<span class="comment">//2 3 5 4 1</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);					</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);		</div><div class="line"><span class="comment">//执行过程如下：</span></div><div class="line">JavaScript引擎首先从macrotask queue中取出第一个任务，</div><div class="line">执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行；</div><div class="line">然后再从macrotask queue中取下一个，</div><div class="line">执行完毕后，再次将microtask queue中的全部取出；</div><div class="line">循环往复，直到两个queue中的任务都取完。</div><div class="line"></div><div class="line">解释：</div><div class="line">代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。</div><div class="line">后面遇到了setTimeout，又加入到macrotask queue中，</div><div class="line">然后，遇到了promise.then，放入到了另一个队列microtask queue。</div><div class="line">等整个execution context stack执行完后，</div><div class="line">下一步该取的是microtask queue中的任务了。</div><div class="line">因此promise.then的回调比setTimeout先执行</div></pre></td></tr></table></figure>
<h5 id="创建对象的三种方法"><a href="#创建对象的三种方法" class="headerlink" title="创建对象的三种方法"></a>创建对象的三种方法</h5><h6 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Object.create(proto, [ propertiesObject ]) 第二个参数为新要添加的属性</span></div><div class="line"><span class="keyword">var</span> Student = &#123;</div><div class="line">    name: <span class="string">'Robot'</span>,</div><div class="line">    height: <span class="number">1.2</span>,</div><div class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">    <span class="comment">// 初始化新对象:</span></div><div class="line">    s.name = name;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></div><div class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="class-实现"><a href="#class-实现" class="headerlink" title="class 实现"></a>class 实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hello() &#123;</div><div class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">        <span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    myGrade() &#123;</div><div class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="上下文和作用域"><a href="#上下文和作用域" class="headerlink" title="上下文和作用域"></a>上下文和作用域</h5><p>在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续寻找。直到找到该变量，或抵达最外层的作用域为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a=<span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"></div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>作用域分为两种，词法作用域和动态作用域。js是词法作用域。</p>
<p>词法作用域最重要的特征是它的定义过程发生在代码书写阶段。</p>
<h5 id="this的误区"><a href="#this的误区" class="headerlink" title="this的误区"></a>this的误区</h5><p>指向自身，this指向函数的作用域。 //this取决于调用位置</p>
<h5 id="this和上下文作用域"><a href="#this和上下文作用域" class="headerlink" title="this和上下文作用域"></a>this和上下文作用域</h5><p>分成声明和赋值两个步骤。一开始先声明，然后赋值的时候如果没声明再声明（全局作用域），最后赋值。</p>
<p>this不是author-time binding，而是 runtime binding。</p>
<p>当函数作为对象方法调用时，<code>this</code>指向该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  prop: <span class="number">37</span>,</div><div class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// logs 37</span></div></pre></td></tr></table></figure>
<h5 id="this对象绑定规则（箭头函数不满足）"><a href="#this对象绑定规则（箭头函数不满足）" class="headerlink" title="this对象绑定规则（箭头函数不满足）"></a>this对象绑定规则（箭头函数不满足）</h5><p>new&gt;call或者apply&gt;上下文对象调用&gt;严格模式下绑定undefined否则global</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p= &#123;</div><div class="line">   data:&#123;</div><div class="line">      flag: <span class="literal">true</span></div><div class="line">   &#125;,</div><div class="line">   init: <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.flag)</div><div class="line">   &#125;</div><div class="line">&#125;			 <span class="comment">//箭头函数没有自己的this，他的this值继承自外部。而这里就是继承p的，p的上下文this是全局				window对象了，所以会报						undefined的错误</span></div><div class="line">p.init()     <span class="comment">//结果是undefined，如果是普通函数结果是true</span></div></pre></td></tr></table></figure>
<p>特殊情况！：</p>
<h5 id="深度拷贝对象https-www-zhihu-com-question-23031215"><a href="#深度拷贝对象https-www-zhihu-com-question-23031215" class="headerlink" title="深度拷贝对象https://www.zhihu.com/question/23031215"></a>深度拷贝对象<a href="https://www.zhihu.com/question/23031215" target="_blank" rel="external">https://www.zhihu.com/question/23031215</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.val = <span class="number">1</span>;</div><div class="line"> <span class="keyword">var</span> obj = &#123;</div><div class="line">   val: <span class="number">2</span>,</div><div class="line">   dbl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.val *= <span class="number">2</span>;</div><div class="line">     val *= <span class="number">2</span>;</div><div class="line">     <span class="built_in">console</span>.log(val);</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.val);</div><div class="line">   &#125;</div><div class="line"> &#125;;</div><div class="line"> <span class="comment">// 说出下面的输出结果</span></div><div class="line"> obj.dbl();</div><div class="line"> <span class="keyword">var</span> func = obj.dbl;</div><div class="line"> func();      		<span class="comment">// 2 4 8 8</span></div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">var</span> obj = &#123;</div><div class="line">   say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> f1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// obj</span></div><div class="line">       setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// obj</span></div><div class="line">       &#125;)</div><div class="line">     &#125;</div><div class="line">     f1();</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> obj.say()</div><div class="line"> </div><div class="line">   <span class="keyword">var</span> obj = &#123;</div><div class="line">   say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// window, f1调用时,没有宿主对象,默认是window</span></div><div class="line">       setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></div><div class="line">       &#125;)</div><div class="line">     &#125;;</div><div class="line">     f1();</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> obj.say()</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></div><div class="line">  a=<span class="number">100</span>;</div><div class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//100</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);<span class="comment">//10</span></div><div class="line">  <span class="keyword">var</span> a;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>RegExp 是JS中的类，同Array类似。</p>
<p>第一个参数正则匹配。第二个参数（g:全局查找  i:不区分大小写  m:多行查找）</p>
<h5 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h5><p>test()—return boolean</p>
<p>exec()—return a Array with index and input</p>
<p>search()—return index and u can both input RegExp or String                               //字符串带的方法</p>
<p>replace()—as it looks like </p>
<h5 id="difference-between"><a href="#difference-between" class="headerlink" title="difference between [] {} ()"></a>difference between [] {} ()</h5><p>[0-9] 查找任何从 0 至 9 的数字</p>
<p>{8} 表示位数为8位</p>
<p>()的作用是提取匹配的字符串。表达式中有几个<code>()</code>就会得到几个相应的匹配字符串。比如<code>(\s+)</code>表示连续空格的字符串</p>
<h5 id="和"><a href="#和" class="headerlink" title="^ 和 $"></a>^ 和 $</h5><p><code>^</code> 匹配一个字符串的开头，比如 (<code>^a</code>) 就是匹配以字母<code>a</code>开头的字符串</p>
<p><code>$</code> 匹配一个字符串的结尾,比如 (<code>b$</code>) 就是匹配以字母<code>b</code>结尾的字符串</p>
<p><code>^</code>还有另个一个作用就是取反，比如<code>[^xyz]</code>表示匹配的字符串不包含<code>xyz</code></p>
<h5 id="d-s-w"><a href="#d-s-w" class="headerlink" title="\d \s \w ."></a>\d \s \w .</h5><p><code>\d</code> 匹配一个非负整数， 等价于 <code>[0-9]</code>；</p>
<p><code>\s</code> 匹配一个空白字符；</p>
<p><code>\w</code> 匹配一个英文字母或数字，等价于<code>[0-9a-zA-Z]</code>；</p>
<p><code>.</code> 匹配除换行符以外的任意字符，等价于<code>[^\n]</code>。</p>
<h5 id=""><a href="#" class="headerlink" title="* + ?"></a>* + ?</h5><p><code>*</code>表示匹配前面元素0次或多次，比如<code>(\s*)</code>就是匹配0个或多个空格；</p>
<p><code>+</code> 表示匹配前面元素1次或多次，比如<code>(\d+)</code>就是匹配由至少1个整数组成的字符串；</p>
<p><code>?</code>表示匹配前面元素0次或1次，相当于<code>{0,1}</code>，比如<code>(\w?)</code> 就是匹配最多由1个字母或数字组成的字符串 。</p>
<h5 id="还有一些语法"><a href="#还有一些语法" class="headerlink" title="还有一些语法"></a>还有一些语法</h5><p>[adgk]   查找给定集合内的任何字符。</p>
<p><code>\W</code>  查找非单词字符。</p>
<p><code>\d</code>  查找数字。</p>
<p><code>\D</code> 查找非数字字符。</p>
<p><code>\b</code> 匹配单词边界。</p>
<p><code>\B</code> 匹配非单词边界。</p>
<p><code>\0</code> 查找 NULL 字符。</p>
<p><code>\n</code> 查找换行符。</p>
<p><code>\f</code> 查找换页符。</p>
<p><code>\r</code> 查找回车符。</p>
<p><code>\t</code> 查找制表符。</p>
<p><code>\v</code> 查找垂直制表符。</p>
<p><code>\xxx</code> 查找以八进制数 xxx 规定的字符。</p>
<p><code>\xdd</code> 查找以十六进制数 dd 规定的字符。</p>
<p><code>\uxxxx</code> 查找以十六进制数 xxxx 规定的 Unicode 字符。</p>
<p>n{X,Y} <code>X</code>和 <code>Y</code> 为正整数。前面的模式<code>n</code> 连续出现至少 <code>X</code>次，至多 <code>Y</code>次时匹配</p>
<p>?=n 匹配任何其后紧接指定字符串<code>n</code> 的字符串。</p>
<p>?!n 匹配任何其后没有紧接指定字符串 <code>n</code> 的字符串</p>
<h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h5><p><a href="https://segmentfault.com/a/1190000008782928" target="_blank" rel="external">https://segmentfault.com/a/1190000008782928</a></p>
<h6 id="为什么要virtual-dom"><a href="#为什么要virtual-dom" class="headerlink" title="为什么要virtual dom"></a>为什么要virtual dom</h6><p>操作dom太耗资源，所以优化为操作对象</p>
<h6 id="核心：比较只会在同层级进行-不会跨层级比较。"><a href="#核心：比较只会在同层级进行-不会跨层级比较。" class="headerlink" title="核心：比较只会在同层级进行, 不会跨层级比较。"></a>核心：<strong>比较只会在同层级进行, 不会跨层级比较。</strong></h6><p>更新流程：</p>
<p>1.先判断两个vnode的key和sel是否相同。不值的比较就直接用新节点替代老节点。否则进入第二步</p>
<p>2.节点的比较有5种情况</p>
<ol>
<li><code>if (oldVnode === vnode)</code>，他们的引用一致，可以认为没有变化。</li>
<li><code>if(oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text)</code>，文本节点的比较，需要修改，则会调用<code>Node.textContent = vnode.text</code>。</li>
<li><code>if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch )</code>, 两个节点都有子节点，而且它们不一样，这样我们会调用<code>updateChildren</code>函数比较子节点，这是diff的核心，后边会讲到。</li>
<li><code>else if (ch)</code>，只有新的节点有子节点，调用<code>createEle(vnode)</code>，<code>vnode.el</code>已经引用了老的dom节点，<code>createEle</code>函数会在老dom节点上添加子节点。</li>
<li><code>else if (oldCh)</code>，新节点没有子节点，老节点有子节点，直接删除老节点。</li>
</ol>
<p>3.通过设置的key进行遍历比较子节点</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ul>
<li>尽量不要跨层级的修改dom</li>
<li>设置key可以最大化的利用节点</li>
<li>不要盲目相信diff的效率，在必要时可以手工优化</li>
</ul>
<h5 id="自己写一个vue组件"><a href="#自己写一个vue组件" class="headerlink" title="自己写一个vue组件"></a>自己写一个vue组件</h5><p><a href="https://juejin.im/entry/58a11c648d6d81006c9d739d" target="_blank" rel="external">https://juejin.im/entry/58a11c648d6d81006c9d739d</a></p>
<p>仿照着分页自己写了个conole-panel的控制台。主要实现了，黑色背景，字体，以及随着控制log的增加，自动跟随到最新的信息。大概的思路就是自己写个普通的组件，要填的通过props传进来。然后vue.use引用就好了</p>
<h5 id="父子组件间通信"><a href="#父子组件间通信" class="headerlink" title="父子组件间通信"></a>父子组件间通信</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"counter-event-example"</span>&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">  &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/</span>button-counter&gt;</div><div class="line">  &lt;button-counter v-on:increment=<span class="string">"incrementTotal"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span></div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  </div><div class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      counter: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></div><div class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#counter-event-example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    total: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="非父子组件间通信"><a href="#非父子组件间通信" class="headerlink" title="非父子组件间通信"></a>非父子组件间通信</h5><p>如果2个组件不是父子组件那么如何通信呢？这时可以通过eventHub来实现通信.<br>所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let Hub = new Vue(); //创建事件中心11</div></pre></td></tr></table></figure>
<p>组件1触发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div @click=&quot;eve&quot;&gt;&lt;/div&gt;</div><div class="line">methods: &#123;</div><div class="line">    eve() &#123;</div><div class="line">        Hub.$emit(&apos;change&apos;,&apos;hehe&apos;); //Hub触发事件</div><div class="line">    &#125;</div><div class="line">&#125;123456123456</div></pre></td></tr></table></figure>
<p>组件2接收:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&lt;/div&gt;</div><div class="line">created() &#123;</div><div class="line">    Hub.$on(&apos;change&apos;, () =&gt; &#123; //Hub接收事件</div><div class="line">        this.msg = &apos;hehe&apos;;</div><div class="line">    &#125;);</div><div class="line">&#125;123456123456</div></pre></td></tr></table></figure>
<p>这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！</p>
<h5 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h5><p>beforecreate    created</p>
<p>beforemounted    mounted</p>
<p>beforeupdate    updated</p>
<p>activated    deactivated</p>
<p>beforedestory    destroyed</p>
<h5 id="vue的生命周期各阶段都做了什么？"><a href="#vue的生命周期各阶段都做了什么？" class="headerlink" title="vue的生命周期各阶段都做了什么？"></a>vue的生命周期各阶段都做了什么？</h5><p><code>beforeCreate</code> 实例创建前：这个阶段实例的data、methods是读不到的<br><code>created</code> 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染<br><code>beforeMount</code>：在挂载开始之前被调用：相关的 render 函数首次被调用。<br><code>mounted</code>：el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染<br><code>beforeUpdate</code>：数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理<br><code>updated</code>：这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行<br><code>beforeDestory</code>：实例销毁之前调用。<br><code>destroyed</code>：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。    </p>
<h5 id="vue生命周期在真实场景下的业务应用"><a href="#vue生命周期在真实场景下的业务应用" class="headerlink" title="vue生命周期在真实场景下的业务应用"></a>vue生命周期在真实场景下的业务应用</h5><p><code>created</code>：进行ajax请求异步数据的获取、初始化数据<br><code>mounted</code>：挂载元素内dom节点的获取<br><code>nextTick</code>：针对单一事件更新数据后立即操作dom<br><code>updated</code>：任何数据的更新，如果要做统一的业务逻辑处理<br><code>watch</code>：监听具体数据变化，并做相应的处理</p>
<p>react的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">         &#123;<span class="keyword">this</span>.props.text || <span class="string">"兄弟组件未更新"</span>&#125;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">class Parent extends React.Component&#123;</span></div><div class="line"><span class="regexp">  constructor(props)&#123;</span></div><div class="line"><span class="regexp">    super(props);</span></div><div class="line"><span class="regexp">    this.state = &#123;&#125;</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">  refresh()&#123;</span></div><div class="line"><span class="regexp">    return (e)=&gt;&#123;</span></div><div class="line"><span class="regexp">      this.setState(&#123;</span></div><div class="line"><span class="regexp">        text: "兄弟组件沟通成功",</span></div><div class="line"><span class="regexp">      &#125;)</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">  render()&#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">      &lt;div&gt;</span></div><div class="line"><span class="regexp">        &lt;h2&gt;兄弟组件沟通&lt;/</span>h2&gt;</div><div class="line">        &lt;Brother1 refresh=&#123;<span class="keyword">this</span>.refresh()&#125;/&gt;</div><div class="line">        &lt;Brother2 text=&#123;<span class="keyword">this</span>.state.text&#125;/&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div></pre></td></tr></table></figure>
<h5 id="react组件之间交流方式"><a href="#react组件之间交流方式" class="headerlink" title="react组件之间交流方式"></a>react组件之间交流方式</h5><p>父子：父组件更新组件状态／子组件触发更新父组件状态—也在props里调用父亲组件的方法改变state</p>
<p>兄弟：借助父组件更新，层次比较深就很不方便／React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。</p>
<h5 id="vuex是为什么出现的"><a href="#vuex是为什么出现的" class="headerlink" title="vuex是为什么出现的"></a>vuex是为什么出现的</h5><ul>
<li>管理多个组件共享状态。</li>
<li>全局状态管理。</li>
<li>状态变更跟踪。</li>
<li>让状态管理形成一种规范，使代码结构更清晰。</li>
</ul>
<h5 id="源码中的遍历对象"><a href="#源码中的遍历对象" class="headerlink" title="源码中的遍历对象"></a>源码中的遍历对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">touch</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(obj === <span class="string">'Object'</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(obj))&#123;</div><div class="line">      obj.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;touch(ele)&#125;)</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">let</span> keys=<span class="built_in">Object</span>.keys(obj)</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> keys)&#123;</div><div class="line">        touch(obj[key])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><h5 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    devtool: <span class="string">"source-map"</span>, 					<span class="comment">//配置生成 Source Maps 的选项  将编译前后代码每行一												一对应起来，有四个不同轻重的选项。</span></div><div class="line">    entry: __dirname + <span class="string">"/app/main.js"</span>, 		<span class="comment">//入口文件路径</span></div><div class="line">    output: &#123;</div><div class="line">        path: __dirname + <span class="string">"/build/"</span>, 		<span class="comment">//存放打包后文件的地方路径</span></div><div class="line">        filename: <span class="string">"[name]-[hash].js"</span> 		<span class="comment">//打包后的文件名</span></div><div class="line">    &#125;,</div><div class="line">    devServer: &#123;							<span class="comment">//构建本地服务器</span></div><div class="line">        port: <span class="string">"9000"</span>,</div><div class="line">        inline: <span class="literal">true</span>,						<span class="comment">//改变文件自动刷新</span></div><div class="line">        historyApiFallback: <span class="literal">true</span>,</div><div class="line">        hot: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;								<span class="comment">//loader进行文件预处理，允许js之外所有静态自由</span></div><div class="line">        loaders: [&#123;							<span class="comment">//匹配不同文件进行解析</span></div><div class="line">            test: <span class="regexp">/\.json$/</span>,</div><div class="line">            loader: <span class="string">"json-loader"</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.js$/</span>,</div><div class="line">            exclude: <span class="regexp">/node_modules/</span>, 		<span class="comment">//编译打包时需要排除 node_modules 文件夹</span></div><div class="line">            loader: <span class="string">"babel-loader"</span>			<span class="comment">//.babelrc将babel配置写到这个文件中</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.css$/</span>,</div><div class="line">            use: ExtractTextPlugin.extract(&#123;</div><div class="line">                fallback: <span class="string">"style-loader"</span>,						</div><div class="line">                use: <span class="string">"css-loader?modules!postcss-loader"</span>		</div><div class="line">              								<span class="comment">//cssmodules运用模块</span></div><div class="line">           									<span class="comment">//postcss 解析scss,less之类的 </span></div><div class="line">              								<span class="comment">//css-loader 使你能够使用类似 @import 和 													url(...) 的方法实现 require() 的功能</span></div><div class="line">              								<span class="comment">//style-loader 将所有的计算后的样式加入页面中</span></div><div class="line">            &#125;)</div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [								<span class="comment">//插件</span></div><div class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Flying Unicorns inc."</span>), </div><div class="line">      										<span class="comment">//在这个数组中new一个实例就可以了</span></div><div class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">            template: __dirname + <span class="string">"/app/index.tmpl.html"</span> <span class="comment">//new一个插件的实例，并传入相关的参数</span></div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热加载插件</span></div><div class="line">        <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin(),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name]-[hash].css"</span>)		</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Webpack中-—save-dev-和-—save-的区别"><a href="#Webpack中-—save-dev-和-—save-的区别" class="headerlink" title="Webpack中 —save-dev 和 —save 的区别"></a>Webpack中 —save-dev 和 —save 的区别</h5><p>前者是开发时候用的，后者是发布之后也要用的</p>
<h5 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h5><h6 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h6><p>Nodejs</p>
<p>优点：</p>
<ul>
<li>服务器端模块便于重用</li>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">NPM</a> 中已经有将近20万个可以使用模块包</li>
</ul>
<p>缺点：</p>
<ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li>
</ul>
<h6 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h6><p><a href="https://github.com/amdjs/amdjs-api">Asynchronous Module Definition</a> 规范其实只有一个主要接口 <code>define(id?, dependencies?, factory)</code>，它要在声明模块的时候指定所有的依赖 <code>dependencies</code>，并且还要当做形参传到 <code>factory</code> 中，对于依赖的模块提前执行，依赖前置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</div><div class="line">  return someExportedValue;</div><div class="line">&#125;);</div><div class="line">require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;);</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>适合在浏览器环境中异步加载模块</li>
</ul>
<p>缺点：</p>
<ul>
<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>
<li>不符合通用的模块化思维方式，是一种妥协的实现</li>
</ul>
<p>实现：</p>
<ul>
<li><a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a></li>
</ul>
<h6 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h6><p><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md">Common Module Definition</a> 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(function(require, exports, module) &#123;</div><div class="line">  var $ = require(&apos;jquery&apos;);</div><div class="line">  var Spinning = require(&apos;./spinning&apos;);</div><div class="line">  exports.doSomething = ...</div><div class="line">  module.exports = ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>依赖就近，延迟执行</li>
<li>可以很容易在 Node.js 中运行</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖 SPM 打包，模块的加载逻辑偏重</li>
</ul>
<p>实现：</p>
<ul>
<li><a href="http://seajs.org/" target="_blank" rel="external">Sea.js</a></li>
</ul>
<p>AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行</p>
<p>CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖</p>
<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。<br>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CMD</span></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</div><div class="line">    a.doSomethis();</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>)<span class="comment">//依赖可以就近书写</span></div><div class="line">    b.doSomething()</div><div class="line">&#125;)</div><div class="line"><span class="comment">//AMD</span></div><div class="line">define([<span class="string">'./a,./b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="comment">//依赖必须一开始就写好</span></div><div class="line">    a.dosomething()</div><div class="line">    b.dosomething()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="webpack-vs-gulp-amp-grunt"><a href="#webpack-vs-gulp-amp-grunt" class="headerlink" title="webpack vs gulp&amp;grunt"></a>webpack vs gulp&amp;grunt</h5><p>前者的工作流程是，将整个项目作为一个主体，通过给定的主文件，根据整个文件开始找到项目的所有依赖。然后通过loaders处理，最后打包成一个浏览器可以识别的js文件。</p>
<p>后者就有点像小孩。在配置文件中给出需要对文件的各种操作命令，然后他会帮你操作完成。</p>
<h5 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h5><p>清除浮动 还是 闭合浮动</p>
<p>外边距重合，父div撑不起来</p>
<p>清除浮动指的是运用clear属性去解决浮动父容器高度塌陷的问题，clear属性规定元素的哪一侧不允许其他浮动元素。<br>可选择的值有：left, right, both, none, inherit</p>
<p><strong>清除浮动方法1</strong>：通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素。</p>
<p><strong>清除浮动方法2</strong>：BFC（Block Format Content）清理浮动，BFC可以<strong>阻止垂直外边距折叠</strong>、<strong>不会重叠浮动元素</strong>、可以<strong>包含浮动</strong>。因此清理浮动在BFC的语境下就是“包含浮动”，也即让父容器形成BFC就可以。</p>
<h5 id="会触发BFC的条件有："><a href="#会触发BFC的条件有：" class="headerlink" title="会触发BFC的条件有："></a>会触发BFC的条件有：</h5><ul>
<li><p>float的值不为none。</p>
</li>
<li><p>overflow的值不为visible。</p>
</li>
<li><p>display的值为table-cell, table-caption, inline-block 中的任何一个。</p>
</li>
<li><p>position的值不为relative 和static。</p>
<p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距.</p>
<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</p>
<p>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</p>
<p>两个外边距一正一负时，折叠结果是两者的相加的和。</p>
<p>ps：一个包另一个，被包的那个的margin就被吃掉了，还是贴在一起的！！！</p>
<p>还有一种就是里边是float外边div，就撑不开，跑外边来了</p>
</li>
</ul>
<h5 id="css圆角-1"><a href="#css圆角-1" class="headerlink" title="css圆角"></a>css圆角</h5><p>如果是长度，就是圆角的半径，0就是直角。</p>
<p>如果是百分比，超过50%，四个角就合成椭圆了</p>
<h5 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h5><p>兵分三路。HTML/SVG/XHTML负责DOM树，css负责css树，js通过相应的api操作这两个树，解析完成后通过两个树变成渲染树。</p>
<p>ps：Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。</p>
<h5 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h5><ol>
<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 Resize ,Add or delete element</li>
<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 Change color</li>
</ol>
<p>注意：回流必将引起重绘，而重绘不一定会引起回流。</p>
<p>浏览器很聪明，回流重绘到一定数量才会发生。</p>
<h6 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h6><p>一次性更改style，绝对定位复杂操作的动画。不要把DOM结点的属性值放在一个循环里当成循环里的变量。千万不要使用table布局</p>
<ul>
<li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>当你移动DOM的位置，或是搞个动画的时候。</li>
<li>当你修改CSS样式的时候。</li>
<li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li>
<li>当你修改网页的默认字体时。</li>
</ul>
<h2 id="第二部分-计算机网络"><a href="#第二部分-计算机网络" class="headerlink" title="第二部分 计算机网络"></a>第二部分 计算机网络</h2><h5 id="在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"><a href="#在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？"></a>在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</h5><p>dns缓存（地址），cdn缓存（文件），浏览器缓存，服务器缓存。</p>
<h5 id="关于cookie的一切"><a href="#关于cookie的一切" class="headerlink" title="关于cookie的一切"></a>关于cookie的一切</h5><p><strong>cookie的属性</strong>：</p>
<p>Domain：域，表示当前cookie所属于哪个域或子域下面。（www.jianshu.com）</p>
<p>Path：表示cookie的所属路径。（／）</p>
<p>Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了（2017-10-20T02:16:19.000Z）</p>
<p>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。</p>
<p>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。</p>
<p><strong>服务器发送cookie给客户端</strong>：</p>
<p>从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。</p>
<p>Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly</p>
<p><strong>从客户端把cookie发送到服务器</strong>：</p>
<p>从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。</p>
<p><strong>关于修改，设置cookie</strong>：</p>
<p>除了服务器发送给客户端（浏览器）的时候，通过Set-Cookie，创建或更新对应的cookie之外，还可以通过浏览器内置的一些脚本，比如javascript，去设置对应的cookie，对应实现是操作js中的document.cookie。</p>
<p><strong>Cookie的缺陷：</strong></p>
<p>(1)cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</p>
<p>(2)由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)</p>
<p>(3)Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</p>
<h5 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h5><p>Cache-Control：max-age=600。设置有效时长</p>
<p>Expires：一个时间节点，表示在这个时间节点之前都是有效的</p>
<p>Last-Modified（或 Etag）：最后一次更新时间节点</p>
<p>Etag：相当于一个tagid，上传到server端检查id是否一致</p>
<h6 id="200-for-cache-vs-304-not-Modify"><a href="#200-for-cache-vs-304-not-Modify" class="headerlink" title="200 for cache   vs  304 not Modify"></a>200 for cache   vs  304 not Modify</h6><p> 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存</p>
<p>304&lt;——&gt;由last-modify&amp;&amp;etag控制。</p>
<p>200 for cache&lt;——&gt;由Cache-Control &amp;&amp; Expires控制。前者优先级更高</p>
<h5 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h5><h6 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h6><p>请求行        //三个字段：方法字段，URL字段，HTTP版本</p>
<p>请求头部        //Host 请求主机名，Accept 客户端可识别的内容类型列表，User-Agent 产生请求的浏览器类型，                          Connection 是否持续保持连接</p>
<p>请求正文        //POST</p>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p>状态行              //由HTTP协议版本号， 状态码， 状态消息</p>
<p>响应头部.        //Date：服务器生成响应报文并发送的日期和时间，该时间是服务器在它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。Server:表示该报文是由一台Apache Web服务器产生的。Last-Modified： 对象创建或最后修改的时间。Content-Type：指定了实体中的对象是HTML(text/html),编码类型是UTF-8</p>
<p>空行告诉下一行是正文</p>
<p>响应正文</p>
<p><img src="/Users/deepglint/Downloads/sanciwoshou.png" alt="sanciwoshou"></p>
<h5 id="为什么要三次握手，四次挥手"><a href="#为什么要三次握手，四次挥手" class="headerlink" title="为什么要三次握手，四次挥手"></a>为什么要三次握手，四次挥手</h5><p>三次是为了server端一直等待。server 说好，但是服务器端没收到或者发的没收到。</p>
<p>四次是因为双方都有可能还有信息没有发，所以需要各自都说不发了。</p>
<h5 id="为什么要重定向"><a href="#为什么要重定向" class="headerlink" title="为什么要重定向"></a>为什么要重定向</h5><p>其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a href="http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。" target="_blank" rel="external">http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。</a></p>
<p>301 or 302</p>
<p>他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；</p>
<p>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</strong></p>
<p>反向代理</p>
<p>所有服务器前面加个代理来分配大量的请求响应</p>
<h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><p>1xx：信息性状态码，表示服务器接受请求正在处理</p>
<p>2xx：成功状态码，表示服务器正确处理完请求</p>
<p>3xx：重定向状态码，表示请求资源位置发生改变，需要重新重定向</p>
<p>4xx：服务器端错误状态码，服务器无法处理该请求</p>
<p>5xx：服务器错误状态码，服务器处理请求错误</p>
<blockquote>
<p>面试官问了问题，是直接返回404好还是返回200在response的body中返回404比较好</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>1**：信息性状态码</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>2**：成功状态码</td>
</tr>
<tr>
<td></td>
<td>200：OK 请求正常处理</td>
</tr>
<tr>
<td></td>
<td>204：No Content请求处理成功，但没有资源可返回</td>
</tr>
<tr>
<td></td>
<td>206：Partial Content对资源的某一部分的请求</td>
</tr>
<tr>
<td></td>
<td>3**：重定向状态码</td>
</tr>
<tr>
<td></td>
<td>301：Moved Permanently 永久重定向</td>
</tr>
<tr>
<td></td>
<td>302：Found 临时性重定向</td>
</tr>
<tr>
<td></td>
<td>304：Not Modified 缓存中读取</td>
</tr>
<tr>
<td></td>
<td>4**：客户端错误状态码</td>
</tr>
<tr>
<td></td>
<td>400：Bad Request 请求报文中存在语法错误</td>
</tr>
<tr>
<td></td>
<td>401：Unauthorized需要有通过Http认证的认证信息</td>
</tr>
<tr>
<td></td>
<td>403：Forbidden访问被拒绝</td>
</tr>
<tr>
<td></td>
<td>404：Not Found无法找到请求资源</td>
</tr>
<tr>
<td></td>
<td>5**：服务器错误状态码</td>
</tr>
<tr>
<td></td>
<td>500：Internal Server Error 服务器端在执行时发生错误</td>
</tr>
<tr>
<td></td>
<td>503：Service Unavailable 服务器处于超负载或者正在进行停机维护</td>
</tr>
</tbody>
</table>
<h4 id="计算机网络—自顶向下总结-http-www-jianshu-com-p-48f2bebaeb40"><a href="#计算机网络—自顶向下总结-http-www-jianshu-com-p-48f2bebaeb40" class="headerlink" title="计算机网络—自顶向下总结(http://www.jianshu.com/p/48f2bebaeb40)"></a>计算机网络—自顶向下总结(<a href="http://www.jianshu.com/p/48f2bebaeb40" target="_blank" rel="external">http://www.jianshu.com/p/48f2bebaeb40</a>)</h4><h5 id="应用层-进程与计算机网络间的接口"><a href="#应用层-进程与计算机网络间的接口" class="headerlink" title="应用层   进程与计算机网络间的接口"></a>应用层   进程与计算机网络间的接口</h5><h6 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h6><p>http协议（web） ：无状态，乱序是TCP考虑的事，拉协议</p>
<p>FTP协议（文件传输）</p>
<p>SMTP协议（电子邮件）：推协议</p>
<h6 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h6><p>主机名—&gt;IP地址转换的目录服务</p>
<p>通常从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的</p>
<h6 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h6><p>DDos：向处理如.com域的域名服务器发送大量DNS请求，使得大部分合法请求无法获得响应</p>
<p>DNS反射：请求中冒充目标主机源地址，大量请求DNS服务器，DNS就大量向源地址主机发送回答，淹没目标主机</p>
<h5 id="传输层-为应用程序提供正确的应用级进程之间的交付服务"><a href="#传输层-为应用程序提供正确的应用级进程之间的交付服务" class="headerlink" title="传输层 为应用程序提供正确的应用级进程之间的交付服务"></a>传输层 为应用程序提供正确的应用级进程之间的交付服务</h5><h6 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h6><p>TCP：有连接的，需要握手包到底的。稳定但是大。HTTP FTP    head:20bit</p>
<p>TCP does error checking and error recovery. Erroneous packets are retransmitted from the source to the destination.</p>
<p>UDP：                                        DNS,VOIP.               8bit    </p>
<p>UDP does error checking but simply discards erroneous packets. Error recovery is not attempted.</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>仅在网络层提供连接服务的计算机网络成为虚电路；仅在网络层提供无连接服务的计算机网络称为数据报网络</p>
<h5 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h5><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><h2 id="第三部分-简历和面试技巧总结"><a href="#第三部分-简历和面试技巧总结" class="headerlink" title="第三部分 简历和面试技巧总结"></a>第三部分 简历和面试技巧总结</h2><h5 id="回答职业规划类型问题"><a href="#回答职业规划类型问题" class="headerlink" title="回答职业规划类型问题"></a>回答职业规划类型问题</h5><p>体现扎根动机，公司优秀多向公司学习</p>
<h5 id="反问面试官的最后一个问题"><a href="#反问面试官的最后一个问题" class="headerlink" title="反问面试官的最后一个问题"></a>反问面试官的最后一个问题</h5><h6 id="这次面试我还有哪些需要提高的地方"><a href="#这次面试我还有哪些需要提高的地方" class="headerlink" title="这次面试我还有哪些需要提高的地方"></a>这次面试我还有哪些需要提高的地方</h6><h6 id="在公司里的部门，做什么"><a href="#在公司里的部门，做什么" class="headerlink" title="在公司里的部门，做什么"></a>在公司里的部门，做什么</h6><h5 id="平常关注的前端消息"><a href="#平常关注的前端消息" class="headerlink" title="平常关注的前端消息"></a>平常关注的前端消息</h5><p>知乎，前端周刊 <a href="https://zhuanlan.zhihu.com/p/27966492" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27966492</a></p>
<p>​       前端外看评论 <a href="https://zhuanlan.zhihu.com/FrontendMagazine" target="_blank" rel="external">https://zhuanlan.zhihu.com/FrontendMagazine</a></p>
<p>​       前端学习指南 <a href="https://zhuanlan.zhihu.com/study-fe" target="_blank" rel="external">https://zhuanlan.zhihu.com/study-fe</a></p>
<p>​       前端大哈 <a href="https://zhuanlan.zhihu.com/qianduandaha" target="_blank" rel="external">https://zhuanlan.zhihu.com/qianduandaha</a></p>
<h5 id="看过的前端书籍"><a href="#看过的前端书籍" class="headerlink" title="看过的前端书籍"></a>看过的前端书籍</h5><p>权威指南，你不知道的js，understunding es6，阮es6，DOM编程艺术，bad things about JavaScript，图解http，css secrets ,css 权威指南，算法导论，jquery实战，黑客与画家,编写高质量JavaScript代码的68个有效方法,Head First HTML5 Programming,数据结构与算法JavaScript描述，编写高质量代码–Web前端开发修炼之道，javascript秘密花园，javascript的怪癖，Git教程，css编写规范，深入理解javascript，typescript，</p>
<p>廖雪峰 阮一峰</p>
<h5 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h5><p>前端大全</p>
<p>算法与数学之美</p>
<p>36氪</p>
<p>IFE</p>
<h4 id="简历内容具体分析"><a href="#简历内容具体分析" class="headerlink" title="简历内容具体分析"></a>简历内容具体分析</h4><h5 id="弹幕"><a href="#弹幕" class="headerlink" title="弹幕"></a>弹幕</h5><p>功能实现：</p>
<p>颜色随机 span.style.color = colors[index];</p>
<p>高度：算出一共能多少行，随机行数</p>
<p>一开始在屏幕的最右侧：</p>
<p>var screenW = window.innerWidth;<br>span.style.left = screenW +’px’;</p>
<p>动态往左：arr[i] -= 2。oSpan[i].style.left = arr[i]+’px’;</p>
<p>判断是否超出屏幕：if (arr[i] &lt; -oSpan[i].offsetWidth)</p>
<p>细节处理：</p>
<p>观看量35万的视5000条弹幕。可以设置屏幕的弹幕数，vip有优先权。</p>
<p>bilibili也会出现弹幕太多覆盖屏幕，只能关了再看。会有遮盖，不过颜色不同，行高固定。</p>
<p>使用的是transform translate</p>
<h5 id="chorme插件"><a href="#chorme插件" class="headerlink" title="chorme插件"></a>chorme插件</h5><p>调试安卓手机</p>
<p>所以也不用再在chrome上安装ADB插件了 但需要下载最新的chrome</p>
<p>chrome://inspect</p>
<p>手机上看到的内容pc端可以同步审查元素</p>
<h5 id="mock后端数据"><a href="#mock后端数据" class="headerlink" title="mock后端数据"></a>mock后端数据</h5><p>json-server</p>
<h5 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h5><p><a href="http://www.jianshu.com/p/4784216b8194" target="_blank" rel="external">http://www.jianshu.com/p/4784216b8194</a></p>
<h5 id="git版本控制"><a href="#git版本控制" class="headerlink" title="git版本控制"></a>git版本控制</h5><p>Master        正式发版用</p>
<p>Develop        开发重大版本</p>
<p>Feature        开发某种特定功能</p>
<p>Release        发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试</p>
<p>Fixbug        修补bug分支</p>
<p>后三种为临时分支，用完就删</p>
<p>Dev</p>
<p>git checkout -b develop master        创建分枝</p>
<p>git checkout master                切换到Master分支</p>
<p>git merge –no-ff develop            对Develop分支进行合并</p>
<p>这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>Feature</p>
<p>git checkout -b feature-x develop</p>
<p>git checkout develop</p>
<p>git merge –no-ff feature-x        </p>
<p>git branch -d feature-x            删除分支</p>
<p>Release</p>
<p>git checkout -b release-1.2 develop</p>
<p>git checkout master</p>
<p>git merge –no-ff release-1.2</p>
<p>git tag -a 1.2                         对合并生成的新节点，做一个标签</p>
<p>Fixbug</p>
<p>git checkout -b fixbug-0.1 master</p>
<p>git checkout master</p>
<p>git merge –no-ff fixbug-0.1</p>
<p>git tag -a 0.1.1</p>
<p>git checkout develop</p>
<p>git merge –no-ff fixbug-0.1</p>
<p>git checkout develop</p>
<p>git merge –no-ff fixbug-0.1</p>
<h5 id="滚屏加载"><a href="#滚屏加载" class="headerlink" title="滚屏加载"></a>滚屏加载</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="keyword">var</span> winH = $(<span class="built_in">window</span>).height(); <span class="comment">//页面可视区域高度 </span></div><div class="line">    <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">//设置当前页数 </span></div><div class="line">    $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">        <span class="keyword">var</span> pageH = $(<span class="built_in">document</span>.body).height(); </div><div class="line">        <span class="keyword">var</span> scrollT = $(<span class="built_in">window</span>).scrollTop(); <span class="comment">//滚动条top </span></div><div class="line">        <span class="keyword">var</span> aa = (pageH-winH-scrollT)/winH; </div><div class="line">        <span class="keyword">if</span>(aa&lt;<span class="number">0.02</span>)&#123; </div><div class="line">            $.getJSON(<span class="string">"result.php"</span>,&#123;<span class="attr">page</span>:i&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123; </div><div class="line">                <span class="keyword">if</span>(json)&#123; </div><div class="line">                    <span class="keyword">var</span> str = <span class="string">""</span>; </div><div class="line">                    $.each(json,<span class="function"><span class="keyword">function</span>(<span class="params">index,array</span>)</span>&#123; </div><div class="line">                        <span class="keyword">var</span> str = <span class="string">"&lt;div class=\"single_item\"&gt;&lt;div class=\"element_head\"&gt;"</span>; </div><div class="line">                        <span class="keyword">var</span> str += <span class="string">"&lt;div class=\"date\"&gt;"</span>+array[<span class="string">'date'</span>]+<span class="string">"&lt;/div&gt;"</span>; </div><div class="line">                        <span class="keyword">var</span> str += <span class="string">"&lt;div class=\"author\"&gt;"</span>+array[<span class="string">'author'</span>]+<span class="string">"&lt;/div&gt;"</span>; </div><div class="line">                        <span class="keyword">var</span> str += <span class="string">"&lt;/div&gt;&lt;div class=\"content\"&gt;"</span>+array[<span class="string">'content'</span>]+<span class="string">"&lt;/div&gt;&lt;/div&gt;"</span>; </div><div class="line">                        $(<span class="string">"#container"</span>).append(str); </div><div class="line">                    &#125;); </div><div class="line">                    i++; </div><div class="line">                &#125;<span class="keyword">else</span>&#123; </div><div class="line">                    $(<span class="string">".nodata"</span>).show().html(<span class="string">"别滚动了，已经到底了。。。"</span>); </div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">                &#125; </div><div class="line">            &#125;); </div><div class="line">        &#125; </div><div class="line">    &#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Js：</p>
<p>网页可见区域宽： document.body.clientWidth<br>网页可见区域高： document.body.clientHeight<br>网页可见区域宽： document.body.offsetWidth (包括边线的宽)<br>网页可见区域高： document.body.offsetHeight (包括边线的高)<br>网页正文全文宽： document.body.scrollWidth<br>网页正文全文高： document.body.scrollHeight<br>网页被卷去的高： document.body.scrollTop<br>网页被卷去的左： document.body.scrollLeft<br>网页正文部分上： window.screenTop<br>网页正文部分左： window.screenLeft<br>屏幕分辨率的高： window.screen.height<br>屏幕分辨率的宽： window.screen.width<br>屏幕可用工作区高度： window.screen.availHeight<br>屏幕可用工作区宽度： window.screen.availWidth</p>
<p>JQuery:</p>
<p>$(document).ready(function(){<br>alert($(window).height()); //浏览器当前窗口可视区域高度<br>alert($(document).height()); //浏览器当前窗口文档的高度<br>alert($(document.body).height());//浏览器当前窗口文档body的高度<br>alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin<br>alert($(window).width()); //浏览器当前窗口可视区域宽度<br>alert($(document).width());//浏览器当前窗口文档对象宽度<br>alert($(document.body).width());//浏览器当前窗口文档body的宽度<br>alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度</p>
<h6 id="当数据量很大的时候，更细致的分析-https-juejin-im-post-58b545f0b123db005734634e"><a href="#当数据量很大的时候，更细致的分析-https-juejin-im-post-58b545f0b123db005734634e" class="headerlink" title="当数据量很大的时候，更细致的分析(https://juejin.im/post/58b545f0b123db005734634e)"></a>当数据量很大的时候，更细致的分析(<a href="https://juejin.im/post/58b545f0b123db005734634e" target="_blank" rel="external">https://juejin.im/post/58b545f0b123db005734634e</a>)</h6><p>问题：</p>
<p>1.设置阀值，不要等到最后再拉动加载，比如可以提前一页</p>
<p>2.top，temp，bottom三块，滚动过程中不断改变数组中数据，保证数据长度一定。</p>
<p>3.dom操作是阻塞的</p>
<p>衡量标准：</p>
<p>1.使用window.performance</p>
<p>HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。</p>
<p>2.使用console.time方法与console.timeEnd方法</p>
<p>其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。</p>
<p>解决思路：</p>
<p>但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题：</p>
<p>1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。</p>
<p>2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。</p>
<p>“截流和防抖动函数”（Throttle和Debounce）。<br>简单总结一下：</p>
<p>1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间;</p>
<p>2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h5><p>基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。</p>
<p>其中，是否发生滚动由lastScrollY === window.scrollY来判断。 document.body.scrollTop</p>
<p>DOM回收</p>
<p>每加载一次数据，就生成“.page-container .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。</p>
<h6 id="总结—一共就四点优化"><a href="#总结—一共就四点优化" class="headerlink" title="总结—一共就四点优化"></a>总结—一共就四点优化</h6><p>dom回收，维持dom数量。     </p>
<p>对于滚动事件的监听</p>
<p>不要等到拉到最后再加载。</p>
<p>墓碑（Tombstones）—先占位</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/centmaster/hexo-centmaster/hexo-centmaster/2017/09/13/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="centmaster">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo-centmaster/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hexo-centmaster/2017/09/13/ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T20:50:19+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES6入门-个人总结"><a href="#ES6入门-个人总结" class="headerlink" title="ES6入门  个人总结"></a>ES6入门  个人总结</h2><h4 id="ES6生命变量的六种方式"><a href="#ES6生命变量的六种方式" class="headerlink" title="ES6生命变量的六种方式"></a>ES6生命变量的六种方式</h4><p>let const promise reflect proxy generator decorator Symbol Iterator 结构赋值</p>
<p>Array: .from .of …(扩展运算符) .copyWithin .find .findindex .includes .fill .entires .keys .values</p>
<p>Object: 属性表达式 .is .assign </p>
<p>class</p>
<h4 id="1-let-const"><a href="#1-let-const" class="headerlink" title="1.let/const"></a>1.let/const</h4><h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><p>1.块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    object = &#123;</div><div class="line">        a: <span class="literal">true</span>,</div><div class="line">        b: <span class="literal">true</span>,</div><div class="line">        c: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//因为再执行的时候key都已经变成c了</span></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs "a", then "b", then "c"</span></div><div class="line">&#125;);				<span class="comment">//if change to var then outputs c c c</span></div></pre></td></tr></table></figure>
<p>2.不存在变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var 的情况</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// let 的情况</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>3.暂时性死区</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.在同一个块级作用域中不允许重复声明</p>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>声明一个只读常量，一旦声明不能改变。声明也必须带着值</p>
<p>实质是，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。也就是说，可以再往对象里填东西，但不能重复声明。</p>
<p>const同时也满足，块级作用域，变量不提升，暂时性死区。</p>
<h6 id="const必须声明的时候赋值"><a href="#const必须声明的时候赋值" class="headerlink" title="const必须声明的时候赋值"></a>const必须声明的时候赋值</h6><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>在ES6浏览器中，允许块级作用域中声明函数</p>
<p>因为外边看不到块里边的变量，所以提案，do用来得到块级作用域中的变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</div><div class="line">  <span class="keyword">let</span> t = f();</div><div class="line">  t * t + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>let与const表现相同，因为在每个块级作用于中都没有被改变。for循环就不行，因为i++试图更改const</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    object = &#123;</div><div class="line">        a: <span class="literal">true</span>,</div><div class="line">        b: <span class="literal">true</span>,</div><div class="line">        c: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="comment">// doesn't cause an error</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs "a", then "b", then "c"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h5><p>一般我们顶层对象和全局是不区分的。let和const声明的全局对象不属于顶层对象（window，global）</p>
<h4 id="2-函数的扩展"><a href="#2-函数的扩展" class="headerlink" title="2.函数的扩展"></a>2.函数的扩展</h4><h5 id="基本的用法"><a href="#基本的用法" class="headerlink" title="基本的用法"></a>基本的用法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);		<span class="comment">//设置初始值不能有重复的参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></div><div class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(method);					<span class="comment">//与赋值结构一同使用</span></div><div class="line">&#125;</div><div class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</div><div class="line"><span class="comment">// "GET"</span></div><div class="line">fetch(<span class="string">'http://example.com'</span>)</div><div class="line"><span class="comment">// 报错</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];			<span class="comment">//省略值只能在末尾</span></div><div class="line">&#125;</div><div class="line">f() <span class="comment">// [1, undefined]</span></div><div class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined])</span></div><div class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></div><div class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2。 length属性返回参数没有默认值的个数</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1。 在尾部的参数不计入</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;		<span class="comment">//赋值是在一开始完成的</span></div><div class="line">  <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">f() <span class="comment">// ReferenceError: x is not defined</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;			<span class="comment">//这个比较复杂，如果把var去掉，foo()的结果就是2.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">  y();</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// 3</span></div><div class="line">x <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h5 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort(); <span class="comment">//rest本来就是数组，不需要像arguments一样转</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</div><div class="line"> 						 <span class="comment">// 不能这么些，rest之后不能再有其他参数，会报错</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><p>规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。禁止这种写法的原因是因为先解析参数，可是函数执行才判断严格模式。</p>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">// ES5</span></div><div class="line">f.name <span class="comment">// ""</span></div><div class="line"><span class="comment">// ES6		</span></div><div class="line">f.name <span class="comment">// "f"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"  会加bound</span></div></pre></td></tr></table></figure>
<h5 id="箭头函数有几个使用注意点。"><a href="#箭头函数有几个使用注意点。" class="headerlink" title="箭头函数有几个使用注意点。"></a>箭头函数有几个使用注意点。</h5><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</div><div class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</div><div class="line"><span class="comment">// id: 42</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;); <span class="comment">//直接返回对象的话要加括号</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ES6   这就是箭头函数的this，就是直接绑定不变且根据父亲this的指向</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应量： <code>arguments</code>、<code>super</code>、<code>new.target</code>。由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<h5 id="替换掉call，apply，bind绑定"><a href="#替换掉call，apply，bind绑定" class="headerlink" title="替换掉call，apply，bind绑定"></a>替换掉call，apply，bind绑定</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">bar.bind(foo);</div></pre></td></tr></table></figure>
<h5 id="尾部调用优化！！！"><a href="#尾部调用优化！！！" class="headerlink" title="尾部调用优化！！！"></a>尾部调用优化！！！</h5><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> g(m + n);</div><div class="line">&#125;</div><div class="line">f();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">f();</div></pre></td></tr></table></figure>
<h5 id="尾部递归！！！（栈溢出）"><a href="#尾部递归！！！（栈溢出）" class="headerlink" title="尾部递归！！！（栈溢出）"></a>尾部递归！！！（栈溢出）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</div><div class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</div><div class="line">  <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改写有两种：</p>
<p>1.函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。f(x,y,z)===&gt;f(x)g(y)n(z)</p>
<p>2.使用默认值，就可以只传一个参数</p>
<p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<h6 id="允许最后一个参数有分号"><a href="#允许最后一个参数有分号" class="headerlink" title="允许最后一个参数有分号"></a>允许最后一个参数有分号</h6><h4 id="3-Promise基本用法"><a href="#3-Promise基本用法" class="headerlink" title="3.Promise基本用法"></a>3.Promise基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... some code</span></div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);		<span class="comment">//catch和then都返回的是一个新的promise对象</span></div><div class="line">  &#125;</div><div class="line">&#125;);		<span class="comment">//then中第一个func为resolve的回调，第二个参数可选，catch更好，因为也可捕获之前then中的错误</span></div><div class="line">promise.then().catch. or promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;,()=&gt;&#123;&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    client.open(<span class="string">"GET"</span>, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = <span class="string">"json"</span>;</div><div class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</div><div class="line">        resolve(<span class="keyword">this</span>.response);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看出，promise是个异步操作。但是还不是并发嘛，所以继续往下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line"> 	setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  resolve();</div><div class="line">  &#125;,<span class="number">100</span>)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);					</div><div class="line">&#125;);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line"> 	setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">  resolve();</div><div class="line">  &#125;,<span class="number">10</span>)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		<span class="comment">//2 1 3 4</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);					</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="其他一些方法"><a href="#其他一些方法" class="headerlink" title="其他一些方法"></a>其他一些方法</h5><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>当三个都resolve的时候才会继续往下走，有一个reject了就直接reject了。返回的是一个数组，方法参数可以不是数组。所有promise都会跑，然后出来也是按顺序的。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = Promise.race([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。会先把p1包装成Promise</p>
<h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</div></pre></td></tr></table></figure>
<p>有时需要将现有对象转为Promise对象，<code>Promise.resolve</code>方法就起到这个作用</p>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><h5 id="Promise-done"><a href="#Promise-done" class="headerlink" title="Promise.done()"></a>Promise.done()</h5><p>Promise对象的回调链，不管以<code>then</code>方法或<code>catch</code>方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个<code>done</code>方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .done();</div></pre></td></tr></table></figure>
<p>它的实现代码相当简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</div><div class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">      <span class="comment">// 抛出一个全局错误</span></div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从上面代码可见，<code>done</code>方法的使用，可以像<code>then</code>方法那样用，提供<code>Fulfilled</code>和<code>Rejected</code>状态的回调函数，也可以不提供任何参数。但不管怎样，<code>done</code>都会捕捉到任何可能出现的错误，并向全局抛出。</p>
<h5 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h5><p><code>finally</code>方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与<code>done</code>方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h4 id="4-变量的结构赋值"><a href="#4-变量的结构赋值" class="headerlink" title="4.变量的结构赋值"></a>4.变量的结构赋值</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>等号右边不是可遍历的结构，将会报错。Set也可以结构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];  x <span class="comment">// null  必须要严格等于undefined才会使用默认值</span></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];  <span class="comment">//惰性求值</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div></pre></td></tr></table></figure>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;  <span class="comment">//按照属性名来对应</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;; y <span class="comment">// 5</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</div><div class="line">first <span class="comment">// 1</span></div><div class="line">last <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div></pre></td></tr></table></figure>
<h5 id="数值和布尔值"><a href="#数值和布尔值" class="headerlink" title="数值和布尔值"></a>数值和布尔值</h5><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);  <span class="comment">// [ 3, 7 ]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];				<span class="comment">//设置默认值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h5><p>变量声明不能使用圆括号，模式（就是一个对象的感觉）不能使用</p>
<h6 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  id: <span class="number">42</span>,</div><div class="line">  status: <span class="string">"OK"</span>,</div><div class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;  <span class="comment">//json快速赋值</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line">[x, y] = [y, x];				<span class="comment">//交换</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);	<span class="comment">//遍历Map</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-数组的扩展"><a href="#5-数组的扩展" class="headerlink" title="5.数组的扩展"></a>5.数组的扩展</h4><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>替代apply</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line">f(...args);</div><div class="line"><span class="comment">// ES5 的写法</span></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</div><div class="line"><span class="comment">// ES6 的写法</span></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</div><div class="line"></div><div class="line">arr1.push(...arr2);</div></pre></td></tr></table></figure>
<p>应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</div><div class="line"><span class="comment">// ES6</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</div><div class="line"><span class="comment">// ES6</span></div><div class="line">[a, ...rest] = list</div><div class="line"></div><div class="line">[...<span class="string">'hello'</span>]  <span class="comment">// [ "h", "e", "l", "l", "o" ] 将字符串转换成数组</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</div><div class="line"><span class="keyword">var</span> array = [...nodeList];   　　　　　　<span class="comment">//将Iterator 接口的对象转换成真正数组</span></div></pre></td></tr></table></figure>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h5><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。第一个参数为对象，第二个参数可以像map一样操作，最后一个参数绑定this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div></pre></td></tr></table></figure>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p><code>Array.of</code>方法用于将一组值，转换为数组</p>
<p>主要其实是为了弥补Array(2)这个bug，要是我想这样呢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></div></pre></td></tr></table></figure>
<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<h5 id="find-amp-amp-findindex"><a href="#find-amp-amp-findindex" class="headerlink" title="find &amp;&amp; findindex"></a>find &amp;&amp; findindex</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)  <span class="comment">// -5</span></div></pre></td></tr></table></figure>
<p>主要是弥补了indexOf无法识别NAN，因为其内部用的是‘===’来判断的</p>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h5><p>感觉和上边这个差不多，只不过返回T/F。两个共同弥补indexOf</p>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h5><p>全部擦除然后添上。允许第二，三个参数选择起始和结束位置</p>
<h5 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h5><p>最后一点！数组的空位处理标准都不一样，ES6按undefined来。总之避免使用空位</p>
<h4 id="6-对象的扩展"><a href="#6-对象的扩展" class="headerlink" title="6.对象的扩展"></a>6.对象的扩展</h4><h5 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line"> <span class="keyword">return</span> &#123;x, y&#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</div></pre></td></tr></table></figure>
<p>class是关键字，不要使用这种方式</p>
<h5 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [propKey]: <span class="literal">true</span>,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>属性的简洁表示和属性名表达式不能同时使用</p>
<p>如果属性名表达式是一个对象，命名就是<code>[object Object]</code>，这一点要特别小心。</p>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>近似于三等号，只是有上边这两个区别。</p>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>将源对象（source）的所有可枚举属性，复制到目标对象（target）。浅复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line"></div><div class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);<span class="comment">//除了字符串其他基本类型都不行</span></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</div><div class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</div><div class="line"><span class="built_in">Object</span>.assign(target, source)  <span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;  冲突就直接覆盖</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [4, 5, 3] 把数组视为对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</div><div class="line">&#125;			<span class="comment">//克隆对象</span></div><div class="line"></div><div class="line">options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);<span class="comment">//这样可以用来设置默认值。最好用简单类型</span></div></pre></td></tr></table></figure>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有5种方法可以遍历对象的属性。</p>
<p>ps：<code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。</li>
</ul>
<h5 id="Null传到运算符"><a href="#Null传到运算符" class="headerlink" title="Null传到运算符"></a>Null传到运算符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">'default'</span>;</div></pre></td></tr></table></figure>
<p>上面代码有三个<code>?.</code>运算符，只要其中一个返回<code>null</code>或<code>undefined</code>，就不再往下运算，而是返回<code>undefined</code>。</p>
<h4 id="7-Symbol"><a href="#7-Symbol" class="headerlink" title="7.Symbol"></a>7.Symbol</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因</p>
<h4 id="8-Proxy-amp-amp-Reflect"><a href="#8-Proxy-amp-amp-Reflect" class="headerlink" title="8.Proxy&amp;&amp;Reflect"></a>8.Proxy&amp;&amp;Reflect</h4><h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>写在一起是因为是配套使用的。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<ul>
<li>get() set() has() deleteProperty() difineProperty()//与属性有关的方法</li>
<li>getOwnPropertyDescriptor() ownKeys()//Own的属性描述和属性keys</li>
<li>getPrototypeOf() setPrototypeOf()//与原型有关的方法</li>
<li>isExtensible()判断是否可以扩展 preventExtensions()阻止添加新属性</li>
<li>apply()//调用方法有关</li>
<li>construct()//和new 有关的</li>
<li>revocabal //用来取消proxy实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>this的指向问题：指向proxy而不是指向对象</p>
<h5 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h5><p>1.将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<p>2.修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<p>3.让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法</span></div><div class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 新写法</span></div><div class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>4.<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<h4 id="9-Iterator与for…of-循环"><a href="#9-Iterator与for…of-循环" class="headerlink" title="9.Iterator与for…of 循环"></a>9.Iterator与for…of 循环</h4><p>因为现在已经有四种数据类型，Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。</p>
<h5 id="默认Iterator接口———-Symbol-iterator"><a href="#默认Iterator接口———-Symbol-iterator" class="headerlink" title="默认Iterator接口———[Symbol.iterator]"></a>默认Iterator接口———[Symbol.iterator]</h5><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          value: <span class="number">1</span>,</div><div class="line">          done: <span class="literal">true</span></div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;			<span class="comment">//每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];<span class="comment">//简便的赋方法</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> iterable = &#123;</div><div class="line">  a: <span class="string">'a'</span>,</div><div class="line">  b: <span class="string">'b'</span>,</div><div class="line">  c: <span class="string">'c'</span>,</div><div class="line">  length: <span class="number">3</span>,</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</div><div class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// undefined, undefined, undefined  键名不是数字不行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-调用Iterator接口的场合"><a href="#3-调用Iterator接口的场合" class="headerlink" title="3.调用Iterator接口的场合"></a>3.调用Iterator接口的场合</h5><p>1.结构赋值</p>
<p>2.扩展运算符（…)</p>
<p>3.yield</p>
<p>4.遍历</p>
<h5 id="4-遍历器对象的return-throw"><a href="#4-遍历器对象的return-throw" class="headerlink" title="4.遍历器对象的return(),throw()"></a>4.遍历器对象的return(),throw()</h5><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p>
<p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句或<code>continue</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p>
<h5 id="5-for…of-好在哪里"><a href="#5-for…of-好在哪里" class="headerlink" title="5.for…of 好在哪里"></a>5.for…of 好在哪里</h5><p>forEach:不能break跳出</p>
<p>for…in:</p>
<p>主要是用来遍历对象。但是遍历对象其实也能用for(x of arr.keys())</p>
<p>遍历数组有三个问题：（1)index本来是数字，它处理成字符串</p>
<p>​                     (2)遍历顺序不定</p>
<p>​                     (3)原型链上其他的值也会被遍历到</p>
<h5 id="6-为对象添加Iterator接口"><a href="#6-为对象添加Iterator接口" class="headerlink" title="6.为对象添加Iterator接口"></a>6.为对象添加Iterator接口</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next() &#123;</div><div class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</div><div class="line">          <span class="keyword">return</span> &#123;</div><div class="line">            value: self.data[index++],</div><div class="line">            done: <span class="literal">false</span></div><div class="line">          &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="10-Generator函数"><a href="#10-Generator函数" class="headerlink" title="10.Generator函数"></a>10.Generator函数</h4><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></div><div class="line">hw.next()</div></pre></td></tr></table></figure>
<p>与Iterator接口的关系</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</div><div class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g[<span class="built_in">Symbol</span>.iterator]() === g  		<span class="comment">//他自己本身返回的就是iterator</span></div></pre></td></tr></table></figure>
<p>next方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</div><div class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</div><div class="line">  <span class="keyword">return</span> (x + y + z);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</div><div class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></div><div class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></div><div class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</div><div class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></div><div class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></div><div class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></div></pre></td></tr></table></figure>
<p>for…of遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 2 3 4 5 		一旦done:true 循环就会终止</span></div></pre></td></tr></table></figure>
<p>利用generator为对象添加Iterator接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</div><div class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first: Jane</span></div><div class="line"><span class="comment">// last: Doe</span></div></pre></td></tr></table></figure>
<p>当然也可以加上遍历器接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</div><div class="line">    <span class="keyword">yield</span> [propKey, <span class="keyword">this</span>[propKey]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</div><div class="line"></div><div class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first: Jane</span></div><div class="line"><span class="comment">// last: Doe</span></div></pre></td></tr></table></figure>
<p>其他调用Iterator接口的也可以使用。这就可以把generator看成一种数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span></div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span></div><div class="line">  <span class="keyword">return</span> <span class="number">3</span></div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 扩展运算符</span></div><div class="line">[...numbers()] <span class="comment">// [1, 2]</span></div><div class="line"></div><div class="line"><span class="comment">// Array.from 方法</span></div><div class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></div><div class="line"></div><div class="line"><span class="comment">// 解构赋值</span></div><div class="line"><span class="keyword">let</span> [x, y] = numbers();</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// for...of 循环</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(n)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>return,throw</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;</span></div><div class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>可以利用yield*来用generator调用另一个generator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">  <span class="keyword">yield</span>* foo();</div><div class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello!'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'open'</span>;</div><div class="line">  <span class="keyword">yield</span> inner();</div><div class="line">  <span class="keyword">yield</span> <span class="string">'close'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = outer1()</div><div class="line">gen.next().value <span class="comment">// "open"</span></div><div class="line">gen.next().value <span class="comment">// 返回一个遍历器对象</span></div><div class="line">gen.next().value <span class="comment">// "close"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'open'</span></div><div class="line">  <span class="keyword">yield</span>* inner()</div><div class="line">  <span class="keyword">yield</span> <span class="string">'close'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = outer2()</div><div class="line">gen.next().value <span class="comment">// "open"</span></div><div class="line">gen.next().value <span class="comment">// "hello!"</span></div><div class="line">gen.next().value <span class="comment">// "close"</span></div></pre></td></tr></table></figure>
<p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</p>
<p>如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">11</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = g();</div><div class="line">obj.a <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>Generator函数也不能跟<code>new</code>命令一起用，会报错。因为返回的是指针，不是this，指针中有next。调用next后返回对象</p>
<p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = F.call(F.prototype);</div><div class="line"></div><div class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></div><div class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></div><div class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div><div class="line"></div><div class="line">f.a <span class="comment">// 1</span></div><div class="line">f.b <span class="comment">// 2</span></div><div class="line">f.c <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</div><div class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</div><div class="line">    <span class="built_in">console</span>.log(resp.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</div><div class="line">    it.next(response);		<span class="comment">//必须要加上参数，yield本身没有返回值</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next();</div></pre></td></tr></table></figure>
<p>For…of本质是一个while循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = iterateJobs(jobs);</div><div class="line"><span class="keyword">var</span> res = it.next();</div><div class="line"></div><div class="line"><span class="keyword">while</span> (!res.done)&#123;</div><div class="line">  <span class="keyword">var</span> result = res.value;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  res = it.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Thunk和co用来处理generator的异步处理</p>
<h4 id="11-async"><a href="#11-async" class="headerlink" title="11.async"></a>11.async</h4><p><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</div><div class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</div><div class="line">  <span class="keyword">return</span> stockPrice;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。</p>
<p>正常情况下，<code>await</code>命令后面是一个 Promise 对象。如果不是，会被转成一个立即<code>resolve</code>的 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> timeout(ms);</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure>
<p>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</div></pre></td></tr></table></figure>
<p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>
<h4 id="12-Class"><a href="#12-Class" class="headerlink" title="12.Class"></a>12.Class</h4><p>注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">  [methodName]() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line">Point === Point.prototype.constructor <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> Point() <span class="comment">//与构造函数使用方法一样,必须要加new否则报错</span></div></pre></td></tr></table></figure>
<p>类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toValue() &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Point.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</div><div class="line">  toString() &#123;&#125;,</div><div class="line">  toValue() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这样也可以</span></div><div class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>区别于ES5，类的内部所有定义的方法，都是不可枚举的（non-enumerable）</p>
<p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">point.toString() <span class="comment">// (2, 3)</span></div><div class="line"></div><div class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></div><div class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></div><div class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></div><div class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">  getClassName() &#123;</div><div class="line">    <span class="keyword">return</span> Me.name;		<span class="comment">//只能在内部看到结果是Me，外部读不到</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不存在变量提升。否则，下面这种情况，提升完因为let Foo(还没声明，没提升)，就会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原则上讲是不存在私有属性和方法的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  foo (baz) &#123;</div><div class="line">    bar.call(<span class="keyword">this</span>, baz);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...曲线救国，或者用symbol</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>私有方法使用#号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  #a;</div><div class="line">  #b;</div><div class="line">  #sum() &#123; return #a + #b; &#125;  //也相应的私有方法</div><div class="line">  printSum() &#123; console.log(#sum()); &#125;</div><div class="line">  constructor(a, b) &#123; #a = a; #b = b; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意内部this的指向。说白了跟其他的方法里边包了this，调用上下文不一致一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">  printName(name = <span class="string">'there'</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  print(text) &#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</div><div class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</div><div class="line">printName();</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//使用箭头函数解决</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>父类的静态方法，可以被子类继承。静态方法也是可以从<code>super</code>对象上调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> classMethod() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.classMethod() <span class="comment">// 'hello'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.classMethod()</div><div class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></div></pre></td></tr></table></figure>
<p>下面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prop = <span class="number">1</span>;</div><div class="line">Foo.prop <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p><code>new</code>是从构造函数生成实例的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();  <span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></div></pre></td></tr></table></figure>
<p>Object.getPrototypeOf()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point</div><div class="line"><span class="comment">// true    判断一个类是否继承了另一个类</span></div></pre></td></tr></table></figure>
<p>super关键字，既可以当作函数使用，也可以当作对象使用</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例</p>
<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  p() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// this是B中的this	A.prototype.p()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.p = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  get m() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.p;</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//调用不到</span></div></pre></td></tr></table></figure>
<p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code></p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类。它在 ES6 的实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">...mixins</span>) </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</div><div class="line">    copyProperties(Mix, mixin);</div><div class="line">    copyProperties(Mix.prototype, mixin.prototype);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Mix;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span>(<span class="params">target, source</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</div><div class="line">    <span class="keyword">if</span> ( key !== <span class="string">"constructor"</span></div><div class="line">      &amp;&amp; key !== <span class="string">"prototype"</span></div><div class="line">      &amp;&amp; key !== <span class="string">"name"</span></div><div class="line">    ) &#123;</div><div class="line">      <span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</div><div class="line">      <span class="built_in">Object</span>.defineProperty(target, key, desc);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="13-修饰器"><a href="#13-修饰器" class="headerlink" title="13.修饰器"></a>13.修饰器</h4><p>类的修饰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@testable</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</div><div class="line">  target.isTestable = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyTestableClass.isTestable <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>方法的修饰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  @readonly</div><div class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>)</span>&#123;</div><div class="line">  <span class="comment">// descriptor对象原来的值如下</span></div><div class="line">  <span class="comment">// &#123;</span></div><div class="line">  <span class="comment">//   value: specifiedFunction,</span></div><div class="line">  <span class="comment">//   enumerable: false,</span></div><div class="line">  <span class="comment">//   configurable: true,</span></div><div class="line">  <span class="comment">//   writable: true</span></div><div class="line">  <span class="comment">// &#125;;</span></div><div class="line">  descriptor.writable = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">return</span> descriptor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</div><div class="line"><span class="comment">// 类似于   修饰类不可写</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</div></pre></td></tr></table></figure>
<p>为什么不能修饰函数？因为函数有变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@add</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//变量提升之后</span></div><div class="line">@add</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> counter;</div><div class="line"><span class="keyword">var</span> add;</div><div class="line"></div><div class="line">counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p>
<p>Mixin模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Foo = &#123;</div><div class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@mixins(Foo)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</div><div class="line">obj.foo() <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<h4 id="14-Module的加载实现"><a href="#14-Module的加载实现" class="headerlink" title="14.Module的加载实现"></a>14.Module的加载实现</h4><p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p>export</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * y;<span class="comment">//可以输出类</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> &#123;		<span class="comment">//使用as重命名</span></div><div class="line">  v1 <span class="keyword">as</span> streamV1,</div><div class="line">  v2 <span class="keyword">as</span> streamV2,</div><div class="line">  v2 <span class="keyword">as</span> streamLatestVersion</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500毫秒之后变成<code>baz</code>。</p>
<p>import</p>
<p><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;<span class="comment">//整体加载</span></div></pre></td></tr></table></figure>
<p>Export default</p>
<p>当你不知道输出了什么模块也懒得看api的时候。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一组  </span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入   因为只能输出一个default，所以没必要加大括号了</span></div><div class="line"></div><div class="line"><span class="comment">// 第二组</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></div></pre></td></tr></table></figure>
<p><code>defer</code>与<code>async</code>的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"foo.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"module"</span>&gt;</div><div class="line">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"./utils.js"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// other code</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<h5 id="ES6模块加载与commonJS的差异"><a href="#ES6模块加载与commonJS的差异" class="headerlink" title="ES6模块加载与commonJS的差异"></a>ES6模块加载与commonJS的差异</h5><p>它们有两个重大差异。</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">centmaster</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/hexo-centmaster/archives/">
            
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">centmaster</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/hexo-centmaster/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/hexo-centmaster/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/hexo-centmaster/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/hexo-centmaster/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/hexo-centmaster/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/hexo-centmaster/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/hexo-centmaster/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
