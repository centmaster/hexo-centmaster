{"meta":{"title":"Centmaster的地盘","subtitle":"FEer","description":"足球，利物浦，杰拉德，sia，憧憬着很多，更多","author":"centmaster","url":"https://github.com/centmaster/hexo-centmaster"},"pages":[{"title":"tags","date":"2017-09-13T14:52:29.000Z","updated":"2017-09-13T14:52:53.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/centmaster/hexo-centmaster/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js design-patterns","slug":"design-patterns","date":"2017-09-23T12:06:01.000Z","updated":"2017-09-23T12:22:56.000Z","comments":true,"path":"2017/09/23/design-patterns/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/23/design-patterns/","excerpt":"","text":"js设计模式帅照镇楼，哈哈哈哈 对比发布／订阅模式和观察者模式","categories":[],"tags":[]},{"title":"vue-scopecss 源码分析","slug":"vue-scopecss","date":"2017-09-14T14:02:18.000Z","updated":"2017-09-13T14:30:54.000Z","comments":true,"path":"2017/09/14/vue-scopecss/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/14/vue-scopecss/","excerpt":"源码 每个域中的dom都会自己添加自定义的data-id的属性，然后css中添加[data-id]，会匹配这些dom","text":"源码 每个域中的dom都会自己添加自定义的data-id的属性，然后css中添加[data-id]，会匹配这些dom 动态的把css变成.example[_v-f3f3eg9]. 在同一组件内，你能同时用有作用域和无作用域的样式： 父组件的有作用域的CSS和子组件的有作用域的CSS将同时影响子组件。 有作用域的样式对其他部分没有影响。 有作用域限定的样式不排除类的需要. 由于浏览器渲染方式支持多种不同的CSS选择器，加了作用域的 p { color: red } 会慢好多倍 （即，和属性选择器组合时候的时候）。如果你用类或者id选择器，比如 .example { color: red } ，你就能消除性能损失。这里有个练习场 ，你可以比较测试下其中的差异。 在递归组件中小心后代选择器！ 对于 CSS 规则的选择器 .a .b，如果匹配 .a 的元素内包含一个递归子组件，那么子组件中所有包含 .b 的元素都会被匹配到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768;(function () &#123; function scoper(css) &#123; var id = generateID(); var prefix = \"#\" + id; css = css.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ''); //把样式放到一行 var re = new RegExp(\"([^\\r\\n,&#123;&#125;]+)(,(?=[^&#125;]*&#123;)|\\s*&#123;)\", \"g\"); // css = css.replace(re, function(g0, g1, g2) &#123; if (g1.match(/^\\s*(@media|@keyframes|to|from|@font-face)/)) &#123; return g1 + g2; &#125; if (g1.match(/:scope/)) &#123; g1 = g1.replace(/([^\\s]*):scope/, function(h0, h1) &#123; if (h1 === \"\") &#123; return \"&gt; *\"; &#125; else &#123; return \"&gt; \" + h1; &#125; &#125;); &#125; g1 = g1.replace(/^(\\s*)/, \"$1\" + prefix + \" \"); return g1 + g2; &#125;); addStyle(css,id+\"-style\"); return id; &#125; function generateID() &#123; var id = (\"scoped\"+ Math.random()).replace(\"0.\",\"\"); if(document.getElementById(id))&#123; return generateID(); &#125;else &#123; return id; &#125; &#125; var isIE = (function () &#123; var undef, v = 3, div = document.createElement('div'), all = div.getElementsByTagName('i'); while ( div.innerHTML = '&lt;!--[if gt IE ' + (++v) + ']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;', all[0] ); return v &gt; 4 ? v : undef; &#125;()); function addStyle(cssText, id) &#123; var d = document, someThingStyles = d.createElement('style'); d.getElementsByTagName('head')[0].appendChild(someThingStyles); someThingStyles.setAttribute('type', 'text/css'); someThingStyles.setAttribute('id', id); if (isIE) &#123; someThingStyles.styleSheet.cssText = cssText; &#125; else &#123; someThingStyles.textContent = cssText; &#125; &#125; window.scoper = scoper;&#125;)();var id = scoper(\"h1 &#123;\\ color:red;\\ /*color: #0079ff;*/\\ &#125;\\ \\ /* h2 &#123;\\ color:green\\ &#125;*/\");document.body.getElementsByTagName(\"div\")[0].setAttribute(\"id\",id);","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"https://github.com/centmaster/hexo-centmaster/tags/mvvm/"}]},{"title":"vue-router源码分析","slug":"vue-router","date":"2017-09-13T14:01:57.000Z","updated":"2017-09-13T14:30:25.000Z","comments":true,"path":"2017/09/13/vue-router/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/13/vue-router/","excerpt":"目录结构先来看整体的目录结构 src |—components ​ |—link.js ​ |—view.js ​ |—history ​ |—base.js ​ |—util ​ |—route.js ​ |—index.js 入口文件 ​ |—create-matcher.js 创建match匹配函数 ​ |—create-route-map.js 匹配路由纪录的map ​ |—install.js 插件的install方法 我们指对于源码有个宏观的掌握，具体的细节就不一一贴出来，都可以在目录文件中找到","text":"目录结构先来看整体的目录结构 src |—components ​ |—link.js ​ |—view.js ​ |—history ​ |—base.js ​ |—util ​ |—route.js ​ |—index.js 入口文件 ​ |—create-matcher.js 创建match匹配函数 ​ |—create-route-map.js 匹配路由纪录的map ​ |—install.js 插件的install方法 我们指对于源码有个宏观的掌握，具体的细节就不一一贴出来，都可以在目录文件中找到 入口123456789101112131415161718192021222324252627282930313233343536373839404142import Vue from 'vue'import VueRouter from 'vue-router'// 1. 插件// 安装 &lt;router-view&gt; and &lt;router-link&gt; 组件// 且给当前应用下所有的组件都注入 $router and $route 对象Vue.use(VueRouter)// 2. 定义各个路由下使用的组件，简称路由组件const Home = &#123; template: '&lt;div&gt;home&lt;/div&gt;' &#125;const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 3. 创建 VueRouter 实例 routerconst router = new VueRouter(&#123; mode: 'history', base: __dirname, routes: [ &#123; path: '/', component: Home &#125;, &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125; ]&#125;)// 4. 创建 启动应用// 一定要确认注入了 router // 在 &lt;router-view&gt; 中将会渲染路由组件new Vue(&#123; router, template: ` &lt;div id=\"app\"&gt; &lt;h1&gt;Basic&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;router-link to=\"/\"&gt;/&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/foo\"&gt;/foo&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=\"/bar\"&gt;/bar&lt;/router-link&gt;&lt;/li&gt; &lt;router-link tag=\"li\" to=\"/bar\"&gt;/bar&lt;/router-link&gt; &lt;/ul&gt; &lt;router-view class=\"view\"&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;).$mount('#app') 根据入口文件我们可以把本篇文章分为四部分去讲。1.插件 2.实例化vueRouter 3.实例化Vue 4.link和view 插件机制我们可以看到利用 Vue.js 提供的插件机制 .use(plugin) 来安装 VueRouter，而这个插件机制则会调用该 plugin 对象的 install 方法（当然如果该 plugin 没有该方法的话会把 plugin 自身作为函数来调用） 在install.js中我们可以看到vue插件的经典写法。 12345678910111213141516import &#123; install &#125; from './install'// ...import &#123; inBrowser, supportsHistory &#125; from './util/dom'// ...export default class VueRouter &#123;// ...&#125;// 赋值 installVueRouter.install = install// 自动使用插件if (inBrowser &amp;&amp; window.Vue) &#123; window.Vue.use(VueRouter)&#125; 我们可以继续在目录中查找install.js，查阅发现，主要逻辑将$route,$router注入vue原型中。所有vue组件都是vue的实例，所以都可以访问到。 实例化VueRouter在入口文件中，首先要实例化一个 VueRouter ，然后将其传入 Vue 实例的 options 中。 123456789101112131415161718192021222324252627282930313233343536373839// ...import &#123; createMatcher &#125; from './create-matcher'// ...export default class VueRouter &#123;// ... constructor (options: RouterOptions = &#123;&#125;) &#123; this.app = null this.options = options this.beforeHooks = [] this.afterHooks = [] // 创建 match 匹配函数 this.match = createMatcher(options.routes || []) // 根据 mode 实例化具体的 History let mode = options.mode || 'hash' this.fallback = mode === 'history' &amp;&amp; !supportsHistory if (this.fallback) &#123; mode = 'hash' &#125; if (!inBrowser) &#123; mode = 'abstract' &#125; this.mode = mode switch (mode) &#123; case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this) break default: assert(false, `invalid mode: $&#123;mode&#125;`) &#125; &#125;// ...&#125; 这里引出两个文件create-matcher.js和create-route-map.js。前者根据传入的routes生成对应的路由 map，然后直接返回了 match 匹配函数。后者根据用户路由配置对象生成普通的根据 path 来对应的路由记录以及根据 name来对应的路由记录的 map。 然后继续往下，非常重要的一步就是实例话history，在history目录下有base.js是history的基类。至此实例化VueRouter完成。 实例化Vue在Vue实例化过程中，将router传入options。 创建一个 Vue 实例，对应的 beforeCreate 钩子就会被调用： 1234567891011121314// ... Vue.mixin(&#123; beforeCreate () &#123; // 判断是否有 router if (this.$options.router) &#123; // 赋值 _router this._router = this.$options.router // 初始化 init this._router.init(this) // 定义响应式的 _route 对象 Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; &#125; &#125;) 实例化过程中值得关注的两件事router.init 和 定义响应式的 _route 对象。router.init在index.js文件中 123456789101112131415161718192021222324252627282930313233import &#123; install &#125; from './install'import &#123; createMatcher &#125; from './create-matcher'import &#123; HashHistory, getHash &#125; from './history/hash'import &#123; HTML5History, getLocation &#125; from './history/html5'import &#123; AbstractHistory &#125; from './history/abstract'import &#123; inBrowser, supportsHistory &#125; from './util/dom'import &#123; assert &#125; from './util/warn'export default class VueRouter &#123;// ... init (app: any /* Vue component instance */) &#123;// ... this.app = app const history = this.history if (history instanceof HTML5History) &#123; history.transitionTo(getLocation(history.base)) &#125; else if (history instanceof HashHistory) &#123; history.transitionTo(getHash(), () =&gt; &#123; window.addEventListener('hashchange', () =&gt; &#123; history.onHashChange() &#125;) &#125;) &#125; history.listen(route =&gt; &#123; this.app._route = route &#125;) &#125;// ...&#125;// ... 可以看到初始化主要就是给 app 赋值，针对于 HTML5History 和 HashHistory 特殊处理，因为在这两种模式下才有可能存在进入时候的不是默认页，需要根据当前浏览器地址栏里的 path 或者 hash 来激活对应的路由，此时就是通过调用 transitionTo 来达到目的；而且此时还有个注意点是针对于 HashHistory 有特殊处理，为什么不直接在初始化 HashHistory 的时候监听 hashchange 事件呢？这个是为了修复vuejs/vue-router#725这个 bug 而这样做的，简要来说就是说如果在 beforeEnter 这样的钩子函数中是异步的话，beforeEnter 钩子就会被触发两次，原因是因为在初始化的时候如果此时的 hash 值不是以 /开头的话就会补上 #/，这个过程会触发 hashchange 事件，所以会再走一次生命周期钩子，也就意味着会再次调用 beforeEnter 钩子函数。 router-link 和 router-view 组件router-view在view.js文件中。可以看到逻辑还是比较简单的，拿到匹配的组件进行渲染就可以了。同文件夹中的link.js用来构造router-link.可以看出 router-link 组件就是在其点击的时候根据设置的 to 的值去调用 router 的 push 或者 replace 来更新路由的，同时呢，会检查自身是否和当前路由匹配（严格匹配和包含匹配）来决定自身的 activeClass 是否添加 Router 总结Vuex-router 预备知识利用H5History API 无刷新更改地址栏浏览器历史记录可以看作一个「栈」。 pushState(state, “My Profile”, “/profile/“) 方法当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会立即发送请求该URL 执行pushState函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。它可以接收三个参数，按顺序分别为： 一个对象或者字符串，用于描述新记录的一些特性。这个参数会被一并添加到历史记录中，以供以后使用。这个参数是开发者根据自己的需要自由给出的。 一个字符串，代表新页面的标题。当前基本上所有浏览器都会忽略这个参数。 一个字符串，代表新页面的相对地址。 popstate 事件当用户点击浏览器的「前进」、「后退」按钮时，就会触发popstate事件。你可以监听这一事件，从而作出反应。 replaceState 方法有时，你希望不添加一个新记录，而是替换当前的记录（比如对网站的 landing page），则可以使用replaceState方法。这个方法和pushState的参数完全一样。 利用浏览器的hash特点#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。它具有如下特点： hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面 可以为hash的改变添加监听事件： 1window.addEventListener(&quot;hashchange&quot;, funcRef, false) 每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录 HashHistory.push()1window.location.hash = route.fullPath vue-router的具体实现的比较（https://zhuanlan.zhihu.com/p/27588422）“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： 利用URL中的hash（“#”） 利用History interface在 HTML5中新增的方法 利用hash从设置路由改变到视图更新的流程如下： 1$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() -！！！-&gt; &#123;app._route = route&#125; --&gt; vm.render() 在感叹号这一步过程中，updateRoute的回调函数触发了mixin（应该就是vue和router的mix） 123456789101112export function install (Vue) &#123; Vue.mixin(&#123; beforeCreate () &#123; if (isDef(this.$options.router)) &#123; this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) &#125; registerInstance(this, this) &#125;, &#125;)&#125; 通过Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在beforeCreate钩子中通过Vue.util.defineReactive()定义了响应式的_route属性。所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。 repalce和push 同理，区别在于替换。另外： 1setupListeners () //用来监听手动替换的hash 利用History原理基本一样。不再赘述，方法替换就好。 调用history.pushState()相比于直接修改hash主要有以下优势： pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中 pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串 pushState可额外设置title属性供后续使用","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"https://github.com/centmaster/hexo-centmaster/tags/mvvm/"}]},{"title":"自己看到其他人面经的只是查漏补缺","slug":"nk-interview","date":"2017-09-13T13:42:47.000Z","updated":"2017-09-13T14:29:25.000Z","comments":true,"path":"2017/09/13/nk-interview/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/13/nk-interview/","excerpt":"低版本浏览器不支持HTML5标签怎么解决 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.staticfile.org/html5shiv/r29/html5.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt;","text":"低版本浏览器不支持HTML5标签怎么解决 123&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://cdn.staticfile.org/html5shiv/r29/html5.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; CSS W3C盒子和IE盒子的如何互相转化box-sizing属性box-sizing: content-box|border-box|initial|inherit; inherit表明从父元素继承；initial表明默认值；Content-box表示width和height属性只包含内容区的大小；border-box表示width和height属性是border + padding + content的大小 Array对象自带的排序函数底层是怎么实现的？查阅资料发现，V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数组长度小于等于 22 的用插入排序 InsertionSort，比22大的数组则使用快速排序 QuickSort。 插入排序：遍历序列，每次i都从头开始比放到合适位置 邮箱 正则https://segmentfault.com/q/10100000066611871/^[a-z0-9]+([._\\\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+\\.)&#123;1,63&#125;[a-z0-9]+$/ 面向对象 面向过程它的设计上的特点是：继承、封装、多态 面向对象设计的核心思想是模块化，对问题进行抽象。 ps：如何实现多态？重写父类的方法 JS实现异步的方法1.回调函数 2.Promise 3.事件监听，监听到再触发下一个任务 4.发布订阅模式 publish（‘done’） subscribe（‘done’，） 移动端前端配适方案1.Media Query 2.Flex 它的viewport是固定的：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; 3.rem 懒加载的性能优化全部一次性插入进去设置隐藏的效率远比动态插入删除效率高的多 cookie除了key与value还有哪些参数path domain Expire size typeof Undefined &quot;undefined&quot; Null &quot;object&quot;(see below) Boolean &quot;boolean&quot; Number &quot;number&quot; String &quot;string&quot; Symbol (new in ECMAScript 2015) &quot;symbol&quot; Host object (provided by the JS environment) Implementation-dependent Function object (implements [[Call]] in ECMA-262 terms) &quot;function&quot; Any other object &quot;object&quot; 1234function g()&#123;return 23;&#125; typeof g()//number 常用算法排序 排序法 最差时间分析 平均时间复杂度 稳定度 空间复杂度 冒泡排序 O(n2) O(n2) 稳定 O(1) 快速排序 O(n2) O(n*log2n) 不稳定 O(log2n)~O(n) 选择排序 O(n2) O(n2) 稳定 O(1) 二叉树排序 O(n2) O(n*log2n) 不一顶 O(n) 插入排序 O(n2) O(n2) 稳定 O(1) 堆排序 O(n*log2n) O(n*log2n) 不稳定 O(1) 希尔排序 O O 不稳定 O(1) 事件绑定addEventListener是w3c标准写法，共有三个参数，第一个为事件类型，但是不加on，第二个参数是一个函数，用于写逻辑代码进行事件操作，第三个参数为boolean型值，true或false,true表示事件捕获，false表示事件冒泡，默认为false 123456function handler(e)&#123; //操作 console.log(e)&#125;ele.addEventListener('click', handler);//绑定ele.removeEventListener('click', handler);//解绑 ES6和ES5继承的区别ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）. ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。 cnd dnsCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 文档流absolute：相对于非static的最近祖先 Web优化策略 请求数量：合并脚本和样式表, iconfont，拆分初始化负载（一开始只加载必要脚本），划分主域（增加DNS查询代价，但是增加了并发链接数） 请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化 利用缓存：使用 CDN，使用外部 JavaScript 和 CSS，减少 DNS 查找 页面结构：将样式表(影响样式的内容)放在顶部，将脚本放在底部，尽早刷新文档的输出 rem和em的区别都是相对font-size大小，但是rem是根据root的em，em是根据父级 发现一个神奇的东西按说substr——》对应splice substring———》slice 但只有splice会真实的改变原来的数据，其他三个都不能 css百分比相对于谁相对于父元素宽度的：[max/min-]width、left、right、padding、margin 等； 相对于父元素高度的：[max/min-]height、top、bottom 等； 相对于继承字号的：font-size 等； 相对于自身字号的：line-height 等； 相对于自身宽高的：border-radius、background-size、transform: translate()、transform-origin、zoom、clip-path 等； js严格模式如果两个js用了不同模式，怎么放在一起？用IIFE将两者隔离开来 语法限制1.不允许使用未声明变量，当然也不许删除变量 2.对象。对象属性改动限制 3.函数。不允许名字相同的参数，arguments与参数独立。 4.eval方法只在其操作的eval内部 5.this在严格模式下始终指向指定的值，包括null和undefined。 6.不允许使用with 12345'use strict'window.color=\"red\"; //node环境中为global.color = \"red\"; function displayColor()&#123; console.log(this.color);//严格模式下报错&#125; 遍历方法的区别map():返回一个新的Array，每个元素为调用func的结果 filter():返回一个符合func条件的元素数组 some():返回一个boolean，判断是否有元素是否符合func条件 every():返回一个boolean，判断每个元素是否符合func条件 forEach():没有返回值，只是针对每个元素调用func 原生css实现三角形12345width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid red; https和http以及http2http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/ http1.0——&gt;http1.1——&gt;https——&gt;SPDY——&gt;http2.0 影响http的主要因素带宽和延时。带宽现在不是大问题了，主要是延时。产生延时的3个因素 1.浏览器阻塞。 因为浏览器限制最大连接数 2.DNS查询 3.建立连接。三次握手。慢启动—拥塞避免。 一开始从很小开始试网络情况，然后动态调整 1.0和1.1的区别1.缓存处理。引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 2.带宽优化。在请求头引入了range头域，它允许只请求资源的某个部分 3.增加了更多的错误状态码。410（Gone）表示服务器上的某个资源被永久性的删除。 4.Host头处理。在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址 5.长连接 为了保证安全性，https应运而生在http和tcp中间多加了一个层，SSL／TLS 改造成https过程：安装CA证书，大量的密钥计算增加cpu计算成本 证书的作用：实现加密传输，认证服务器身份。 使用SPDY—在http和ssl中间层1.多路复用 2.请求优先级 3.header压缩 4.基于https HTTP2.0新特性1.新的二进制格式 2.多路复用 按层从高到低。HTTP—SPDY—-SSL—-TCP 线程与进程进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。 async await和generator的区别实验证明，前者其实就是地狱回调的样子，等callback之后再往后走。就是同步的。 async 是多个异步操作的promise对象，await相当于then 使用await Promise.all([func1(),func2()])。就可以把同步变成异步了。 区别： 前者 await后边是跟promise不是自己会转 后者跟的还是generator json和对象的区别JSON是一种数据格式，可以用来交换、存储数据。从JSON可以方便的生成JS对象。 其语法可以认为是JS Object的子集，主要区别在： JSON的键必须带引号，JS可以不带（解释器自动加） JSON没有函数、undefined、NaN等数据类型 object.create的实现原理我觉得，prototype引原来的，再用assign把属性方法都引过来，是不是就差不多？ 前后端分离怎么做？意义？解耦可以方便完全不同的前后端人员开发，理清逻辑。如果前端变化远比后端变化快，应该分离。 cookie,LocalStorage被重复覆盖cookie.setMaxAge(Integer.MAX_VALUE); 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。 cookie配合sessionid，共同验证登录 后者存的是字符串。都会被覆盖。 js 如何添加class 不覆盖原来的12element.className = &quot;redColor&quot;;//设置classelement.className += &quot; yellowBack&quot;;//增加class 一个何时会报undefined，何时会报referenceerror当你var a，或者找一个对象里的某个属性，a=Object.create({});a.name的时候会报undefined。如果一个变量从未声明，则referenceerror。如果求一个简单变量查找属性，则typeerror 判断js对象是否存在的方法12345678910111213141516171819202122232425262728293031323334353637383940411 if (!myObj) &#123; var myObj = &#123; &#125;; &#125;//一定要有var，变量提升之后才不会报错，否则ReferenceError2 if (!window.myObj) &#123; var myObj = &#123; &#125;; &#125;3 if (!this.myObj) &#123; this.myObj = &#123; &#125;; &#125;4 var global = this; if (!global.myObj) &#123; global.myObj = &#123; &#125;; &#125;5 if (typeof myObj == \"undefined\") &#123; var myObj = &#123; &#125;; &#125;6 if (myObj == undefined) &#123; var myObj = &#123; &#125;; &#125;7 if (!this.hasOwnProperty('myObj')) &#123; this.myObj = &#123; &#125;; &#125;8 if (!('myObj' in window)) &#123; window.myObj = &#123; &#125;; &#125;9 if (myObj === undefined) &#123; var myObj = &#123; &#125;; &#125; 函数优先12345678910foo() //1var foo;function foo()&#123; console.log(1);&#125;var foo= function()&#123; console.log(2);&#125; 同时出现hoist的话，函数优先。 window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？感觉是完全加载完才停止转圈圈 babel的使用规则配置：.babelrc 根据官方给的规则集配置文件 12345678&#123; \"presets\": [ \"es2015\", \"react\", \"stage-2\" ], \"plugins\": []&#125; 工具: Babel-cli 用于命令行转码。 Babel-node 它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。 Babel-register 每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。 Babel-core 如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块 Babel-polyfill Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 js的内存泄露问题垃圾回收机制：最常用的就是引用计数 123&gt; const arr = [1, 2, 3, 4];&gt; console.log('hello world');&gt; 上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。 ES6新出的Weakset和WeakMap： 123456const wm = new WeakMap();const element = document.getElementById('example');wm.set(element, 'some information');wm.get(element) // \"some information\" 这样，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 常见的js内存泄露： 1.意外的全局变量。当你没用var声明的时候，默认帮到window全局，就有了引用，会一直占用内存。还有this误指到全局的。可以用use strict 检测这种情况。 2.并没有清除事件 setInterval(clearInterval)，addEventListener(removeEventListener) 3.IE6中dom对象引用了js对象，而dom对象在某个时刻被移除掉了，但js引擎不知道它被移除掉，还傻傻的保留着引用呢，就不会把js对象释放。 url和uli的区别总的来说，locators are also identifiers, so every URL is also a URI, but there are URIs which are not URLs. Dom渲染树渲染过程。 其实不同的浏览器引擎渲染过程稍有不同 HTML和XHTML的区别1.所有的标记都必须要有一个相应的结束标记2.所有标签的元素和属性的名字都必须使用小写3.所有的XML标记都必须合理嵌套4.所有的属性必须用引号””括起来5.把所有&lt;和&amp;特殊符号用编码表示6.给所有属性赋一个值7.不要在注释内容中使“–”8.图片必须有说明文字 怪异模式和标准模式的区别在哪（判断alert(window.top.document.compatMode) ） 在严格模式中 ：width是内容宽度 ，元素真正的宽度 = marginLeft + borderLeftWidth + paddingLeft +width + paddinRight + borderRightWidth + marginRight;在怪癖模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( paddingLeft + paddingRight +borderLeftWidth + borderRightWidth) 可以设置行内元素的高宽在Standards模式下，给span等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。 可设置百分比的高度在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 用margin:0 auto设置水平居中在IE下会失效使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,quirk模式下的解决办法，用text-align属性:body{text-align:center}; content{text-align:left} quirk模式下设置图片的padding会失效 quirk模式下Table中的字体属性不能继承上层的设置 quirk模式下white-space:pre会失效 除了ajax之外，你知道fetch嘛1234567fetch(url).then(function(response) &#123; return response.json();&#125;).then(function(data) &#123; console.log(data);&#125;).catch(function(e) &#123; console.log(\"Oops, error\");&#125;); http相应头和请求头 相应头 请求头 Accept 用户代理可处理的媒体类型 Accept-Ranges 是否接受字节范围请求 Authorization web认证信息 Age 推算资源创建经过时间 Host 请求资源所在的服务器 Location 令客户端重定向至指定URI If-match 比较ETag WWW-Authenticate 服务器对客户端的认证信息 User-Agent Http客户端程序信息 Server http服务器的安装信息 Max-Forwards 最大传输跳转数 Allow 资源可支持的HTTP方法 Range 实体的字节范围请求 Content-Type 实体主体的媒体类型 Referer 对请求中URI的原始获取方 Expires 过期时间 Last-Modified 资源最后的修改日期 Content-Length 资源主体大小 Http2 优势(https://segmentfault.com/a/1190000005085636)多路复用 压缩头部 请求优先级 二进制 服务器推送 两个页面之间通信前端路由和后端路由的区别会造成假如两边都有一样的路径，就容易出bug 为什么要使用这种框架而不用原生api操作dom，性能并没有优化但是对于coding的人来说，牺牲一点计算量可以大大的减轻coding人的工作量 严格模式严格模式的一些主要优点包括： 使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。 不允许重复的属性名称或参数值。当检测到对象（例如，var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。 在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。 NaN123console.log(typeof NaN === \"number\"); //trueObject.is(NaN,NaN)Array.isNaN(NaN) isInteger实现123function isInteger(x) &#123; return (x^0) === x; &#125;function isInteger(x) &#123; return Math.round(x) === x; &#125;function isInteger(x) &#123; return (typeof x === 'number') &amp;&amp; (x % 1 === 0); 实现函数， 实现功能写一个 sum方法，在使用下面任一语法调用时，都可以正常工作。 123456789101112131415161718console.log(sum(2,3)); // Outputs 5console.log(sum(2)(3)); // Outputs 5function sum(x) &#123; if (arguments.length == 2) &#123; return arguments[0] + arguments[1]; &#125; else &#123; return function(y) &#123; return x + y; &#125;; &#125;&#125;function sum(x, y) &#123; if (y !== undefined) &#123; return x + y; &#125; else &#123; return function(y) &#123; return x + y; &#125;; &#125;&#125; 123456789在这种情况下，由于 b 和 c都是对象，因此它们都将被转换为&quot;[object Object]&quot;var a=&#123;&#125;, b=&#123;key:&apos;b&apos;&#125;, c=&#123;key:&apos;c&apos;&#125;; a[b]=123;a[c]=456; console.log(a[b]); 单向绑定和双向绑定（http://www.jianshu.com/p/4ec74cb5b748）单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新 单向数据绑定缺点：HTML代码一旦生成完以后，就没有办法再变了，如果有新的数据来了，那就必须把之前的HTML代码去掉，再重新把新的数据和模板一起整合后插入到文档流中。 React可以算作单向数据中的一种。 双向数据绑定最经常的应用场景是表单，这样当用户在前端页面完成输入后，不用任何操作，就可以拿到用户的数据存放到数据模型中了。 数据模型（Module）和视图（View）之间的双向绑定。无论数据改变，或是用户操作，都能带来互相的变动，自动更新。适用于项目细节 实现双向数据绑定的做法1.发布／订阅 2.脏检查（angular.js） 原理是设置了一些条件，当你触发了这些条件之后，它就执行一个检测来遍历所有的数据，对比你更改了地方，然后执行变化 3.ES7的Object.observe() 最完美的方法，但是很多浏览器并不支持 4.封装属性访问器/数据劫持（vue.js） 结合发布者-订阅者模式的方式，通过ES5的Object.defineProperty()来劫持各个属性的setter，getter 三种隐藏方式差别:visibility:hidden,display:none,opacity:0渲染上的差异:1.将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的回流和重绘。 2.设置元素的visibility为hidden，和display:none的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会回流。 3.opacity:0,只是看不到元素,元素依然存在并且占有原有位置. 注: 事件绑定的差异: 1、display:none：元素彻底消失，不会触发绑定的事件.2、visibility:hidden：无法触发其点击事件，有一种说法是display:none是元素看不见摸不着，而visibility:hidden是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。3、opacity:0：可以触发点击事件，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发绑定事件动画属性的差异: 1、display:none：完全不受transition属性的影响，元素立即消失2、visibility：hidden：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果.3、opacity:0,动画属性生效,能够进行正常的动画效果.","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/centmaster/hexo-centmaster/tags/interview/"}]},{"title":"ES6 快速掌握","slug":"ES6","date":"2017-09-12T12:50:19.000Z","updated":"2017-09-13T14:28:43.000Z","comments":true,"path":"2017/09/12/ES6/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/12/ES6/","excerpt":"ES6生命变量的六种方式let const promise reflect proxy generator decorator Symbol Iterator 结构赋值 Array: .from .of …(扩展运算符) .copyWithin .find .findindex .includes .fill .entires .keys .values Object: 属性表达式 .is .assign class","text":"ES6生命变量的六种方式let const promise reflect proxy generator decorator Symbol Iterator 结构赋值 Array: .from .of …(扩展运算符) .copyWithin .find .findindex .includes .fill .entires .keys .values Object: 属性表达式 .is .assign class 1.let/constlet1.块级作用域 12345678910111213141516var funcs = [], object = &#123; a: true, b: true, c: true &#125;;for (let key in object) &#123; funcs.push(function() &#123; console.log(key); &#125;);&#125;//因为再执行的时候key都已经变成c了funcs.forEach(function(func) &#123; func(); // outputs \"a\", then \"b\", then \"c\"&#125;); //if change to var then outputs c c c 2.不存在变量提升 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 3.暂时性死区 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 4.在同一个块级作用域中不允许重复声明 const声明一个只读常量，一旦声明不能改变。声明也必须带着值 实质是，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。也就是说，可以再往对象里填东西，但不能重复声明。 const同时也满足，块级作用域，变量不提升，暂时性死区。 const必须声明的时候赋值块级作用域在ES6浏览器中，允许块级作用域中声明函数 因为外边看不到块里边的变量，所以提案，do用来得到块级作用域中的变量 1234let x = do &#123; let t = f(); t * t + 1;&#125;; let与const表现相同，因为在每个块级作用于中都没有被改变。for循环就不行，因为i++试图更改const 1234567891011121314151617var funcs = [], object = &#123; a: true, b: true, c: true &#125;;// doesn't cause an errorfor (const key in object) &#123; funcs.push(function() &#123; console.log(key); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // outputs \"a\", then \"b\", then \"c\"&#125;); 顶层对象一般我们顶层对象和全局是不区分的。let和const声明的全局对象不属于顶层对象（window，global） 2.函数的扩展基本的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445function log(x, y = 'World') &#123; console.log(x, y); //设置初始值不能有重复的参数&#125;function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125;function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method); //与赋值结构一同使用&#125;fetch('http://example.com', &#123;&#125;)// \"GET\"fetch('http://example.com')// 报错function f(x = 1, y) &#123; return [x, y]; //省略值只能在末尾&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1](function (a, b, c = 5) &#123;&#125;).length // 2。 length属性返回参数没有默认值的个数(function (a, b = 1, c) &#123;&#125;).length // 1。 在尾部的参数不计入(function(...args) &#123;&#125;).length // 0function f(y = x) &#123; let x = 2; //赋值是在一开始完成的 console.log(y);&#125;f() // ReferenceError: x is not definedvar x = 1; //这个比较复杂，如果把var去掉，foo()的结果就是2.function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 rest参数12345const sortNumbers = (...numbers) =&gt; numbers.sort(); //rest本来就是数组，不需要像arguments一样转function f(a, ...b, c) &#123; // 不能这么些，rest之后不能再有其他参数，会报错&#125; 严格模式规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。禁止这种写法的原因是因为先解析参数，可是函数执行才判断严格模式。 name属性12345678var f = function () &#123;&#125;;// ES5f.name // \"\"// ES6 f.name // \"f\"function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // \"bound foo\" 会加bound 箭头函数有几个使用注意点。（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 12345678910111213141516171819202122232425function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); //直接返回对象的话要加括号// ES6 这就是箭头函数的this，就是直接绑定不变且根据父亲this的指向function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应量： arguments、super、new.target。由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 替换掉call，apply，bind绑定123foo::bar;// 等同于bar.bind(foo); 尾部调用优化！！！我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 1234567891011function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f(); 尾部递归！！！（栈溢出）12345678910function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125; 改写有两种： 1.函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。f(x,y,z)===&gt;f(x)g(y)n(z) 2.使用默认值，就可以只传一个参数 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 允许最后一个参数有分号3.Promise基本用法12345678910111213141516171819202122232425262728293031323334353637383940var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); //catch和then都返回的是一个新的promise对象 &#125;&#125;); //then中第一个func为resolve的回调，第二个参数可选，catch更好，因为也可捕获之前then中的错误promise.then().catch. or promise.then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;);var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 可以看出，promise是个异步操作。但是还不是并发嘛，所以继续往下。 12345678910111213141516new Promise(function executor(resolve) &#123; console.log(2); setTimeout(()=&gt;&#123; resolve(); &#125;,100)&#125;).then(function() &#123; console.log(4); &#125;);new Promise(function executor(resolve) &#123; console.log(1); setTimeout(()=&gt;&#123; resolve(); &#125;,10)&#125;).then(function() &#123; //2 1 3 4 console.log(3); &#125;); 其他一些方法Promise.all()1var p = Promise.all([p1, p2, p3]); 当三个都resolve的时候才会继续往下走，有一个reject了就直接reject了。返回的是一个数组，方法参数可以不是数组。所有promise都会跑，然后出来也是按顺序的。 Promise.race()1var p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。会先把p1包装成Promise Promise.resolve()1var jsPromise = Promise.resolve($.ajax('/whatever.json')); 有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用 Promise.reject()Promise.done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 12345asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); 它的实现代码相当简单。 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;; 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。 Promise.finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 4.变量的结构赋值数组等号右边不是可遍历的结构，将会报错。Set也可以结构赋值 12345let [a, b, c] = [1, 2, 3];let [x, y = 'b'] = ['a']; // x='a', y='b'let [x = 1] = [null]; x // null 必须要严格等于undefined才会使用默认值let [x = f()] = [1]; //惰性求值let [x = 1, y = x] = [1, 2]; // x=1; y=2 对象123456789let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; //按照属性名来对应let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not definedvar &#123;x: y = 3&#125; = &#123;x: 5&#125;; y // 5let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串12const [a, b, c, d, e] = 'hello';let &#123;length : len&#125; = 'hello'; 数值和布尔值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true 函数1234[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); // [ 3, 7 ]function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y]; //设置默认值&#125; 圆括号问题变量声明不能使用圆括号，模式（就是一个对象的感觉）不能使用 用途1234567891011121314let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData; //json快速赋值let x = 1;let y = 2;[x, y] = [y, x]; //交换for (let [key, value] of map) &#123; console.log(key + \" is \" + value); //遍历Map&#125; 5.数组的扩展扩展运算符替代apply 12345678f.apply(null, args);f(...args);// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])arr1.push(...arr2); 应用 1234567891011121314// ES5[1, 2].concat(more)// ES6[1, 2, ...more]// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list[...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 将字符串转换成数组var nodeList = document.querySelectorAll('div');var array = [...nodeList]; //将Iterator 接口的对象转换成真正数组 Array.fromArray.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。第一个参数为对象，第二个参数可以像map一样操作，最后一个参数绑定this 1Array.from(arrayLike, x =&gt; x * x); Array.ofArray.of方法用于将一组值，转换为数组 主要其实是为了弥补Array(2)这个bug，要是我想这样呢 1Array.of(3) // [3] copyWithin123Array.prototype.copyWithin(target, start = 0, end = this.length)[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] find &amp;&amp; findindex1[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 主要是弥补了indexOf无法识别NAN，因为其内部用的是‘===’来判断的 includes感觉和上边这个差不多，只不过返回T/F。两个共同弥补indexOf fill全部擦除然后添上。允许第二，三个参数选择起始和结束位置 entries()，keys() 和 values()最后一点！数组的空位处理标准都不一样，ES6按undefined来。总之避免使用空位 6.对象的扩展属性的简洁表示1234var baz = &#123;foo&#125;; return &#123;x, y&#125;;// 等同于var baz = &#123;foo: foo&#125;; class是关键字，不要使用这种方式 属性名表达式123456obj['a' + 'bc'] = 123;let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 属性的简洁表示和属性名表达式不能同时使用 如果属性名表达式是一个对象，命名就是[object Object]，这一点要特别小心。 Object.is()12Object.is(+0, -0) // falseObject.is(NaN, NaN) // true 近似于三等号，只是有上边这两个区别。 Object.assign()将源对象（source）的所有可枚举属性，复制到目标对象（target）。浅复制 12345678910111213141516171819Object.assign(target, source1, source2);var v1 = 'abc';var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);//除了字符串其他基本类型都不行console.log(obj); // &#123; \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" &#125;var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source) // &#123; a: &#123; b: 'hello' &#125; &#125; 冲突就直接覆盖Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 把数组视为对象function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; //克隆对象options = Object.assign(&#123;&#125;, DEFAULTS, options);//这样可以用来设置默认值。最好用简单类型 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果该参数不是对象，则会先转成对象，然后返回。 属性的遍历ES6 一共有5种方法可以遍历对象的属性。 ps：JSON.stringify()：只串行化对象自身的可枚举的属性 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。 Null传到运算符1const firstName = message?.body?.user?.firstName || 'default'; 上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。 7.SymbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因 8.Proxy&amp;&amp;ReflectProxy写在一起是因为是配套使用的。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 get() set() has() deleteProperty() difineProperty()//与属性有关的方法 getOwnPropertyDescriptor() ownKeys()//Own的属性描述和属性keys getPrototypeOf() setPrototypeOf()//与原型有关的方法 isExtensible()判断是否可以扩展 preventExtensions()阻止添加新属性 apply()//调用方法有关 construct()//和new 有关的 revocabal //用来取消proxy实例 123456789101112var proxy = new Proxy(target, handler);var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;); this的指向问题：指向proxy而不是指向对象 Reflect1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 2.修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 3.让Object操作都变成函数行为。某些Object操作是命令式 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true 4.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 9.Iterator与for…of 循环因为现在已经有四种数据类型，Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。 默认Iterator接口———[Symbol.iterator]Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 12345678910111213141516171819202122232425const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125; //每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。&#125;;NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];//简便的赋方法let iterable = &#123; a: 'a', b: 'b', c: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // undefined, undefined, undefined 键名不是数字不行&#125; 3.调用Iterator接口的场合1.结构赋值 2.扩展运算符（…) 3.yield 4.遍历 4.遍历器对象的return(),throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 5.for…of 好在哪里forEach:不能break跳出 for…in: 主要是用来遍历对象。但是遍历对象其实也能用for(x of arr.keys()) 遍历数组有三个问题：（1)index本来是数字，它处理成字符串 ​ (2)遍历顺序不定 ​ (3)原型链上其他的值也会被遍历到 6.为对象添加Iterator接口12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 10.Generator函数然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 12345678910111213function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next() 与Iterator接口的关系 12345678910111213var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3]function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g //他自己本身返回的就是iterator next方法 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; for…of遍历 12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 一旦done:true 循环就会终止 利用generator为对象添加Iterator接口 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 当然也可以加上遍历器接口 1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 其他调用Iterator接口的也可以使用。这就可以把generator看成一种数据类型 1234567891011121314151617181920212223function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers();x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 return,throw 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 可以利用yield*来用generator调用另一个generator 12345678910111213141516function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125; 12345678910111213141516171819202122232425function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // \"open\"gen.next().value // 返回一个遍历器对象gen.next().value // \"close\"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // \"open\"gen.next().value // \"hello!\"gen.next().value // \"close\" 实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 123456function* g() &#123; this.a = 11;&#125;let obj = g();obj.a // undefined Generator函数也不能跟new命令一起用，会报错。因为返回的是指针，不是this，指针中有next。调用next后返回对象 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 应用1234567891011121314function* main() &#123; var result = yield request(\"http://some.url\"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); //必须要加上参数，yield本身没有返回值 &#125;);&#125;var it = main();it.next(); For…of本质是一个while循环 12345678var it = iterateJobs(jobs);var res = it.next();while (!res.done)&#123; var result = res.value; // ... res = it.next();&#125; Thunk和co用来处理generator的异步处理 11.asyncasync函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。 123456789async function getStockPriceByName(name) &#123; var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50); 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]); await命令只能用在async函数之中，如果用在普通函数，就会报错。 12.Class注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 1234567891011121314//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; [methodName]() &#123; // ... &#125;&#125; 下面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // truevar b=new Point() //与构造函数使用方法一样,必须要加new否则报错 类的所有方法都定义在类的prototype属性上面。 12345678910111213141516171819202122232425262728class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;;//这样也可以Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); 区别于ES5，类的内部所有定义的方法，都是不可枚举的（non-enumerable） constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; //只能在内部看到结果是Me，外部读不到 &#125;&#125;; 不存在变量提升。否则，下面这种情况，提升完因为let Foo(还没声明，没提升)，就会报错 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 原则上讲是不存在私有属性和方法的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...曲线救国，或者用symbol&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 私有方法使用#号。 1234567class Foo &#123; #a; #b; #sum() &#123; return #a + #b; &#125; //也相应的私有方法 printSum() &#123; console.log(#sum()); &#125; constructor(a, b) &#123; #a = a; #b = b; &#125;&#125; 注意内部this的指向。说白了跟其他的方法里边包了this，调用上下文不一致一样 1234567891011121314151617181920212223242526class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName();//使用箭头函数解决class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 下面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 new是从构造函数生成实例的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 Object.getPrototypeOf() 12Object.getPrototypeOf(ColorPoint) === Point// true 判断一个类是否继承了另一个类 super关键字，既可以当作函数使用，也可以当作对象使用 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。super()在这里相当于A.prototype.constructor.call(this)。代表了父类A的构造函数，但是返回的是子类B的实例 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 123456789101112class A &#123; p() &#123; return this; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // this是B中的this A.prototype.p() &#125;&#125; 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 1234567891011class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;//调用不到 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 12345class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125; Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类。它在 ES6 的实现如下。 12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== \"constructor\" &amp;&amp; key !== \"prototype\" &amp;&amp; key !== \"name\" ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 13.修饰器类的修饰 12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 方法的修饰 12345678910111213141516171819class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于 修饰类不可写Object.defineProperty(Person.prototype, 'name', descriptor); 为什么不能修饰函数？因为函数有变量提升 1234567891011121314151617181920212223var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125;//变量提升之后@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; 由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。 Mixin模式 1234567891011121314151617export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125;import &#123; mixins &#125; from './mixins';const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // \"foo\" 14.Module的加载实现ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 export 12345678910export var firstName = 'Michael';export &#123;firstName, lastName, year&#125;;export function multiply(x, y) &#123; return x * y;//可以输出类&#125;;export &#123; //使用as重命名 v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。 import import命令具有提升效果，会提升到整个模块的头部，首先执行。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12import &#123;firstName, lastName, year&#125; from './profile';import * as circle from './circle';//整体加载 Export default 当你不知道输出了什么模块也懒得看api的时候。 12345678910111213// 第一组 export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入 因为只能输出一个default，所以没必要加大括号了// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入type=&quot;module&quot;属性。 1&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。 12345&lt;script type=\"module\"&gt; import utils from \"./utils.js\"; // other code&lt;/script&gt; ES6模块加载与commonJS的差异它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/centmaster/hexo-centmaster/tags/interview/"}]},{"title":"algorithm 前端算法","slug":"algorithm","date":"2017-09-11T13:42:19.000Z","updated":"2017-09-13T14:28:31.000Z","comments":true,"path":"2017/09/11/algorithm/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/11/algorithm/","excerpt":"基础知识二进制12345let a=123;let b=a.toString(2);if(a&lt;0)&#123; b=~b+1; //取反加一就是取负值&#125;","text":"基础知识二进制12345let a=123;let b=a.toString(2);if(a&lt;0)&#123; b=~b+1; //取反加一就是取负值&#125; 算法问题分类树广度优先遍历，深度优先遍历1234567891011121314var levelOrderTraversal = function(node) &#123; if(!node) &#123; throw new Error('Empty Tree') &#125; var que = [] que.push(node) while(que.length !== 0) &#123; node = que.shift() console.log(node.value) if(node.left) que.push(node.left) if(node.right) que.push(node.right) &#125;&#125; //广度利用队列 12345678910111213var preOrderUnRecur = function(node) &#123; if(!node) &#123; throw new Error('Empty Tree') &#125; var stack = [] stack.push(node) while(stack.length !== 0) &#123; node = stack.pop() console.log(node.value) if(node.right) stack.push(node.right) if(node.left) stack.push(node.left) &#125;&#125; //深度利用栈 后序遍历1234567var postOrder = function (node) &#123; if(node)&#123; postOrder(node.left); postOrder(node.right); console.log(node.value); &#125; &#125; 链表 （2）链表反转； 123456789let pre=head;let cur=head.next;pre.next=null;while(cur.next!==null)&#123; let temp=cur.next; cur.next=pre; pre=cur; cur=temp;&#125; （3）链表排序； 123456789101112131415function sort()&#123;let i=head;let j=head.next;let base=i.val;while(j!==null)&#123; if(j.val&lt;base)&#123; i=i.next; swap(i,j); &#125; j=j.next;&#125;swap(i,head); sort(head,i); sort(i.next,j)&#125; （4）合并两个有序链表； （5）求出链表倒数第k个值； 123456789let fa=sl=head;for(var i=0;i&lt;k-2;i++)&#123; fa=fa.next;&#125;while(fa.next!=null)&#123; sl=sl.next; fa=fa.next;&#125;return sl.val; （6）判断链表是否有环，有环返回相遇节点； ​ 快慢针，能相遇就说明有 （7）在一个有环链表中找到环的入口； ​ 从快慢相遇点开始走，另一个从起始点开始走，就能走到 ​ 推倒。设环长r，非环长l，相遇点距环口m. ​ l+m+t1r=(l+m+t2r)/2 ​ l+m=(2*t1-t2)r=tr ​ l=tr-m=(r-m)+(t-1)r 所以一开始从那里走的话一定会在交叉点相会 （8）删除当前给定节点node； ​ node.next=temp; ​ node.val=temp.val; ​ node.next=temp.next; （9）找出链表的中间节点。快慢指针 其他斐波纳切 注意尾部回调123456789function fib(x,m=1,n=0)&#123; if(x&gt;2)&#123; x--; return fib(x,m+n,m); &#125;else&#123; return m+n; &#125; &#125; 数组去重12345678910111213var array = [1,3,4,4,5,6]; function filt(array)&#123; var result=[]; var hash = &#123;&#125;; array.forEach(function(item)&#123; if(!hash[item])&#123; result.push(item); hash[item]=true; &#125; &#125;) console.log(result); &#125;filt(); 判断两个json是否相同1234const x=&#123;a:1,b:2&#125;,y=&#123;b:2,a:1&#125;,z=&#123;a:2,b:3&#125;;//我能想到的方法就是便利每个变量，然后对比deter(x,y) //truedeter(x,z) //false 数据结构栈的实现1234567891011121314151617181920212223function stack()&#123; this.dataStore=[]; this.top=0; this.push=push; this.pop=pop; this.peek=peek;&#125;function push(element)&#123; this.dataStore[top++]=element;&#125;function pop(element)&#123; return this.dataStore[--this.top];&#125;function peek()&#123; return this.dataStore[this.top-1];&#125;function length()&#123; return this.top;&#125;function clear()&#123; this.top=0;&#125; 队列的实现12345678910111213141516171819202122232425262728293031function Queue()&#123; this.dataStore=[]; this.enqueue=enqueue; this.dequeue=dequeue; this.front=front; this.back=back; this.toString=toString; this.empty=empty; &#125;function enqueue(element)&#123; this.dataStore.push(element);&#125;function dequeue(element)&#123; this.dataStore.shift();&#125;function front()&#123; return this.dataStore[0];&#125;function back()&#123; return this.dataStore[this.dataStore.length-1];&#125;function toString()&#123; var resstr=''; for(var i=0;i&lt;this.dataStore.length;i++)&#123; resstr+=this.dataStore[i]+'/n'; &#125; return resstr;&#125;function empty()&#123; return this.dataStore.length==0?true:false;&#125; 链表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function Node(element)&#123; this.element=element; this.next=null;&#125;function llist()&#123; this.head=new Node('head'); this.find=find; this.insert=insert; this.remove=remove; this.display=display;&#125;function find(item)&#123; var curNode=this.head; while(curNode!=item)&#123; curNode=curNode.next; &#125; return curNode;&#125;function insert(newELement,item)&#123; var newNode=new Node(newElment); var current=this.find(item); newNode.next=current.next; current.next=newNode;&#125;function display()&#123; var curNode=this.head; while(!(curNode.next==null))&#123; print(curNode.next.element); curNode=curNode.next; &#125;&#125;function findprevious(item)&#123; var curNode=this.head; while(!(curNode.next==null)&amp;&amp;(curNode.next.element!=item))&#123; curNode=curNode.next; &#125; return curNode; &#125;function remove(item)&#123; var previous=findprevious(item); if(!(previous.next.next==null))&#123; previous.next=previous.next.next; &#125;&#125;//双向链表function Node(element)&#123; this.element=element; this.next=null; this.previous=null;&#125;function LList()&#123; this.head=new Node('head'); this.find=find; this.insert=insert; this.display=display; this.remove=remove; this.findlast=findlast; this.dispReverse=dispReverse;&#125;funciton dispReverse()&#123; var curNode=this.head; curNode=this.findLast(); while(!(curNode==null))&#123; print(curNode.element); curNode=curNode.previous; &#125;&#125;function findLast()&#123; var curNode=this.head; while(!(curNode.next==null))&#123; curNode=curNode.next; &#125; return curNode;&#125; 深度优先和广度优先的遍历123456789101112131415161718192021222324252627282930313233343536373839404142function wideTraversal(selectNode) &#123; var nodes = []; if (selectNode != null) &#123; var queue = []; queue.unshift(selectNode); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes; &#125;var preOrder = function (node) &#123; if (node) &#123; console.log(node.value); preOrder(node.left); preOrder(node.right); &#125;&#125;var inOrder = function (node) &#123; if(node)&#123; inOrder(node.left); console.log(node.value); inOrder(node.right); &#125;&#125;var postOrder = function (node) &#123; if (node) &#123; postOrder(node.left); postOrder(node.right); console.log(node.value); &#125;&#125;","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/centmaster/hexo-centmaster/tags/interview/"}]},{"title":"FE前端技术积累总结","slug":"FE-sum","date":"2017-09-08T13:41:55.000Z","updated":"2017-09-13T14:29:06.000Z","comments":true,"path":"2017/09/08/FE-sum/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/08/FE-sum/","excerpt":"前言这个面经的来源一共分为三部分。第一部分是市面上的面经结合自己的知识总结。第二部分就是自己的面经，大大小小面了也有一些了，希望自己也能总结总结造福自己造福后人。最后一部分就是针对自己做过的东西，简历上的东西做的总结，不具有普遍性。当然文件夹里还有一些算法题，平常做前端的也要动动脑嘛。希望自己和大家都能找到满意的工作。","text":"前言这个面经的来源一共分为三部分。第一部分是市面上的面经结合自己的知识总结。第二部分就是自己的面经，大大小小面了也有一些了，希望自己也能总结总结造福自己造福后人。最后一部分就是针对自己做过的东西，简历上的东西做的总结，不具有普遍性。当然文件夹里还有一些算法题，平常做前端的也要动动脑嘛。希望自己和大家都能找到满意的工作。 第一部分 前端面经总结大赞！https://github.com/paddingme/Front-end-Web-Development-Interview-Question/tree/master/%E5%89%8D%E7%AB%AF%E8%AF%95%E9%A2%98 html基础SEOhtml避免空链接（因为还是会请） 避免深层级嵌套 显示设置宽高 避免脚本阻塞加载 css避免使用@import JS事件代理 避免频繁的dom操作 网络减少http请求次数 减少dns查找次数（缓存三十分钟，可以分块） 减少重定向 首屏加载，滚屏加载 能使用GET就用GET 使用外部js，css 减少cookie GET POST &amp; get post 后退/刷新 无害 请求重新提交 书签 可做书签 不可做 缓存 可被缓存 不能被缓存 历史 保留在浏览器记录里 不保留 对数据长度限制 限制（2048字符） 不限制 安全性 url中暴露数据 相对安全 可见性 url中可见 不可见 你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包;POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 What’s the difference between HTML and XHTML?XHTML is not so much different from HTML 4.01 standard. The major differences are: XHTML elements must be properly nested. XHTML elements must always be closed. XHTML elements must be in lowercase. XHTML documents must have one root element. XML到底是啥，和html有啥区别一种语言的标准，比html更底层吧。XML是爹，主要是为了数据格式化，和json很像 XPath又是啥，干了什么XPath stands for XML Path Language.It uses a non-XML syntax to provide a flexible way of addressing (pointing to) different parts of an XML document. XPath is mainly used in一种xml语言– XSLT, but can also be used as a much more powerful way of navigating through the DOM of any XML-like language document, such as HTML and XUL, instead of relying on the document.getElementById method, the element.childNodes properties, and other DOM Core features. document.evaluate 怪异模式和标准模式最大的区别是什么盒模型，怪异模式按IE那种border里边都算宽高。 如何判断 一个对象是dom对象Obj instanceof HTMLElement //HTMLCollection HTMLDivElement. nodeType h5标签了解多少1&lt;header&gt;&lt;aside&gt;&lt;nav&gt;&lt;footer&gt;&lt;hgroup&gt;&lt;canvas&gt;&lt;vedio&gt;&lt;source&gt;&lt;mark&gt; 语义化的好处 1去掉样式能让页面清晰的呈现出来 2屏幕阅读器会按标记读你的网页／移动端友好 3.有益于SEO，爬虫 4.方便同事共同开发 浏览器内核Gecko:Firefox Presto:opera Webkit:chrome,safari Trident:IE 区分浏览器—navigator.userAgent 判断是否是IE-window.ActiveXObject NodeList 和 HTMLCollection之间的关系？主要不同在于HTMLCollection是元素集合而NodeList是节点集合（即可以包含元素，也可以包含文本节点）。所以 node.childNodes 返回 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection rem实现自适应相对于根元素决定字体大小。 常见兼容性问题123* 上下margin重合问题ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 DOM操作——怎样添加、移除、移动、复制、创建和查找节点12345678910111213141516171819202122232425（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点（2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点（3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 document.write和 innerHTML的区别123document.write只能重绘整个页面innerHTML可以重绘页面的一部分 DOM操作插入节点123456789101112131415161718192021222324252627282930313233343536373839404142(() =&gt; &#123; const ndContainer = document.getElementById('js-list'); if (!ndContainer) &#123; return; &#125; const total = 30000; const batchSize = 4; // 每批插入的节点次数，越大越卡 const batchCount = total / batchSize; // 需要批量处理多少次 let batchDone = 0; // 已经完成的批处理个数 function appendItems() &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; batchSize; i++) &#123; const ndItem = document.createElement('li'); ndItem.innerText = (batchDone * batchSize) + i + 1; fragment.appendChild(ndItem); &#125; // 每次批处理只修改 1 次 DOM ndContainer.appendChild(fragment); batchDone += 1; doBatchAppend(); &#125; function doBatchAppend() &#123; if (batchDone &lt; batchCount) &#123; window.requestAnimationFrame(appendItems); &#125; &#125; // kickoff doBatchAppend(); ndContainer.addEventListener('click', function (e) &#123; const target = e.target; if (target.tagName === 'LI') &#123; alert(target.innerHTML); &#125; &#125;);&#125;)(); 知识点DocumentFragment:文档碎片，虚拟的dom，优化了多次插入。 requestAnimationFrame:因为电脑屏幕是60帧，setInterval这些16.7并不好。 浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。 在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。 如果想自己设置频率： 1234567var fps = 15;function draw() &#123; setTimeout(function() &#123; requestAnimationFrame(draw); // Drawing code goes here &#125;, 1000 / fps);&#125; CSS基础Overflow :hidden 是否形成新的块级格式化上下文？1234&lt;div&gt; &lt;p&gt;I am floated&lt;/p&gt; &lt;p&gt;So am I&lt;/p&gt;&lt;/div&gt; 12div &#123;overflow: hidden;&#125;p &#123;float: left;&#125; A：会形成。 会触发BFC的条件有： float的值不为none。 overflow的值不为visible。 display的值为table-cell, table-caption, inline-block 中的任何一个。 position的值不为relative 和static。 flex的使用容器属性Main axis:主轴线 从左到右 Cross axis:交叉轴线 从上到下 1flex-direction: row | row-reverse | column | column-reverse; 1flex-wrap: nowrap | wrap | wrap-reverse; 1justify-content: flex-start | flex-end | center | space-between | space-around;主轴对齐方式 1align-items: flex-start | flex-end | center | baseline | stretch; 12align-content: flex-start | flex-end | center | space-between | space-around | stretch;定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 项目属性1order: &lt;integer&gt;; 数值越小，排列越靠前，默认为0 1flex-grow: &lt;number&gt;; 默认为0，即如果存在剩余空间，也不放大 1flex-shrink: &lt;number&gt;; 缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 1flex-basis: &lt;length&gt; | auto; 定义了在分配多余空间之前，项目占据的主轴空间。就是设宽度 12flex: none|[ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 12align-self: auto | flex-start | flex-end | center | baseline | stretch;允许单个项目有与其他项目不一样的对齐方式 实战骰子实现1239排列1234display: flex;flex-wrap: wrap;justify-content: flex-end;align-content: space-between; 圣杯布局123456789&lt;body class=\"HolyGrail\"&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=\"HolyGrail-body\"&gt; &lt;main class=\"HolyGrail-content\"&gt;...&lt;/main&gt; &lt;nav class=\"HolyGrail-nav\"&gt;...&lt;/nav&gt; &lt;aside class=\"HolyGrail-ads\"&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829.HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;header,footer &#123; flex: 1;&#125;.HolyGrail-body &#123; display: flex; flex: 1;&#125;.HolyGrail-content &#123; flex: 1;&#125;.HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em;&#125;.HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1;&#125; 固定低栏12345&lt;body class=\"Site\"&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=\"Site-content\"&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; 123456789.Site &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;.Site-content &#123; flex: 1;&#125; css选择器 element,element div,p 选择所有 元素和所有 元素。 1 element element div p 选择 元素内部的所有 元素。 1 element&gt;element div&gt;p 选择父元素为 元素的所有 元素。 2 element+element div+p 选择紧接在 元素之后的所有 元素。 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [[attribute\\ =value]](http://www.w3school.com.cn/cssref/selector_attribute_value_start.asp) [lang\\ =en] 选择 lang 属性值以 “en” 开头的所有元素。 2 screen关键词是指设备物理屏幕的大小还是指浏览器的视窗？1@media only screen and (max-width: 1024px) &#123;margin: 0;&#125; A: 浏览器视窗 Difference between block inline-block inline大体来说HTML元素各有其自身的布局级别（block元素还是inline元素）： 常见的块级元素有 DIV, FORM, TABLE, P, PRE, H1~H6, DL, OL, UL 等。 常见的内联元素有 SPAN, A, STRONG, EM, LABEL, INPUT, SELECT, TEXTAREA, IMG, BR 等。 block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。 display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 ​ Difference between transition and animationtransition123456789101112img&#123; height:15px; width:15px;&#125;img:hover&#123; height: 450px; width: 450px;&#125;img&#123; transition: 1s 1s height ease;&#125; 只选择效果时间。transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 css圆角如果是长度，就是圆角的半径，0就是直角。 如果是百分比，超过50%，四个角就合成椭圆了 mypic.jpg会被浏览器加载吗？1234567891011&lt;div id=&quot;test1&quot;&gt; &lt;span id=&quot;test2&quot;&gt;&lt;/span&gt;&lt;/div&gt;#test1 &#123; display: none;&#125;#test2 &#123; background-image: url(&apos;mypic.jpg&apos;); visibility: hidden;&#125; A: 不会被下载。 What is Flash of Unstyled Content? How do you avoid FOUC?原因大致为：1，使用import方法导入样式表。2，将样式表放在页面底部3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。 解决方法：使用LINK标签将样式表放在文档HEAD中。 隐藏元素的方法Display,visibility,opacity,position:absolute;top:-9999px; { box-sizing: border-box; }固定了盒子的尺寸，无论怎么调整边距都不会改变盒子的大小.似乎是padding变了 Js基础JS原生自定义事件在某个对象上绑定不同类别的一个或多个方法，并且让它们分别执行 123456789101112131415161718192021222324252627var eventHandle = &#123; on: function(obj,events,fn)&#123; obj.listeners = obj.listeners || &#123;&#125;; obj.listeners[events] = obj.listeners[events] || []; obj.listeners[events].push(fn); &#125;, fire: function(obj,events)&#123; for(var i = 0, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123; console.log(obj.listeners[events]); obj.listeners[events][i] &amp;&amp; obj.listeners[events][i](); &#125; &#125;, off: function(obj,events)&#123; for(var i = 0, n = obj.listeners[events].length; i &amp;lt; n; i++)&#123; obj.listeners[events][i] = null; &#125; &#125;&#125;;//绑定自定义事件，eventHandle.on(oDiv,\"eventType1\",function()&#123;console.log(1);&#125;);//准备执行方法1eventHandle.on(oDiv,\"eventType1\",function()&#123;console.log(2);&#125;);//准备执行方法2eventHandle.on(oDiv,\"eventType1\",function()&#123;console.log(3);&#125;);//准备执行方法3eventHandle.on(oDiv,\"eventType2\",function()&#123;console.log(4);&#125;);//准备执行方法4//触发执行eventHandle.fire(oDiv,\"eventType1\");//执行eventType1下的所有方法 原型链原型 构造函数 实例三者之间关系 JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。 每个对象都有一个指向它的原型的的内部链接(此链接还没有规范的访问方式，一般用proro代替),这个原型也有自己的原型，直到每个对象的原型为null为止 任意一个函数都可以作为构造器即var someFun = new AnyFun() 每个函数都有一个prototype属性，其它对象没有，该属性也是一个对象，该对象有一个constructor属性指向该函数 使用new去实例化一个函数后，得到的是一个对象。该函数的实例的原型指向构造函数的prototype属性 每个对象都有自己的属性和方法，如果没有找到就会沿着自己的原型链一直往上去找 js的继承和继承的方法和优缺点？http://www.zyy1217.com/2017/03/13/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F/ 区别类的继承和实例化 非常常用的类继承是这个样子的： B.prototype = new A()这时候特别容易和实例化给混淆了(反正我混了—)：b = new A() js的继承方式下面的这些怎么判断，直接看是不是在prototype上，在的话就会共用，不在的话就没有复用。 那为什么放在原型上就可以复用呢？ 因为每个实例都可以顺着原型链找到student.prototype，所以放在上游大家就能复用了。不放在上游等于没次构造函数就实例化一次，浪费了。 1.原型链继承 1234567891011121314151617181920212223let Super = functioin(name) &#123; this.name = name; this.setName = (newName) =&gt; &#123; this.name = name; &#125;; this.getName = () =&gt; &#123; return this.name; &#125;&#125;let Sub = function(sex) &#123; this.sex = sex;&#125;Sub.prototype = new Super('eric'); //通过改变原型对象实现继承let sub1 = new Sub('male') sub2 = new Sub('female');sub1.setName('ada');// 这里必须通过setName方法来修改继承来的name属性。// 如果通过sub1.name== 'ada',就打不到目的，因为此时sub1对象上没有name属性，// 这样等于为该对象添加了新的属性，而不是修改继承而来的name属性。console.log(sub2.name); // ada,可见此sub2的name也会被修改掉console.log(sub1.getName === sub2.getName) // true,复用了方法 优点：父类的方法得到了复用。 缺点：同理父类的属性也是复用，即子类实例没有自己的属性。 new多个实例，改变其中一个，其他的属性也会被更改 2.借用构造函数 1234567891011121314151617let Super = function(name) &#123; this.name = name; this.getName = () =&gt; &#123; return this.name; &#125;&#125;let Sub = function(sex,name) &#123; Super.call(this,name); // 调用父类方法为子类实例添加属性 this.sex = sex;&#125;let sub1 = new Sub('male','eric'), sub2 = new Sub('female','eric');sub1.name = 'ada';console.log(sub2.name); // eric,实例的属性没有相互影响console.log(sub1.getName === sub2.getName); // false,可见方法没有复用 优点：子类的每个实例都有自己的属性（name），不会相互影响。 缺点：但是继承父类方法的时候就不需要这种特性，没有实现父类方法的复用。 3.组合继承 123456789101112131415161718let Super = function(name) &#123; this.name = name;&#125;Super.prototype = &#123; constructor: Super, // 保持构造函数和原型对象的完整性 getName() &#123; return this.name; &#125;&#125;let Sub = function(sex) &#123; Super.call(this,'eric'); //继承父类属性 this.sex = sex;&#125;Sub.prototype = new Super('eric'); //继承父类方法Sub.prototype.constructor = Sub;let sub1 = new Sub('male'), sub2 = new Sub('female');// 可以按上述两种方法验证，复用了父类的方法，实例没有复用，达到目的 优点：继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性。 缺点：因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费。 4.原型式继承 12345function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 5.寄生组合继承 123456789101112131415161718let Super = function(name) &#123; this.name = name;&#125;Super.prototype = &#123; constructor: Super, getName() &#123; return this.name; &#125;&#125;let Sub = function(sex,name) &#123; Super.call(this,name); this.sex = sex;&#125;// 组合继承的缺点就是在继承父类方法的时候调用了父类构造函数，从而造成内存浪费，// 现在只要解决了这个问题就完美了。那在复用父类方法的时候，// 使用Object.create方法也可以达到目的，没有调用父类构造函数，问题解决。Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub; 这特么不就是，你原型用人家的原型没动构造函数，你直接又把人家构造函数拿过来。齐活！ 通过在父类原型和子类原型之间加入一个临时的构造函数F，切断了子类原型和父类原型之间的联系，这样当子类原型做修改时就不会影响到父类原型。 6.es6中的class 12345678910111213141516171819202122232425262728293031class Super() &#123; constructor(props) &#123; this.name = props.name || 'eric'; &#125; setName(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Sub extends Super &#123; constructor(props) &#123; super(props); // 创建实例，继承父类属性和方法 this.sex = props.sex || 'male'; &#125;&#125;let sub1 = new Sub(&#123; name: 'eric', sex: 'male'&#125;)let sub2 = new Sub(&#123; name: 'eric', sex: 'female'&#125;)sub1.setName('ada');console.log(sub1.getName(),sub2.getName()) // ada,eric,属性没复用，各自实例都有自己的属性。console.log(sub1.getName === sub2.getName) // true; 复用了父类的方法console.log(Sub.prototype.sex) // undefined// 子类原型对象上没有父类构造函数中赋值的属性，不是组合式继承 由以上结果可以看到es6中的class只不过是一种语法糖，通过上面的验证得知符合寄生组合继承的特点 原始数据结构类型和引用类型的区别（讲的特好https://segmentfault.com/a/1190000008472264） 原始数据类型1.基本数据类型的值都是不可变的 123var name = \"change\";name = \"change1\";console.log(name)//change1 原来的change并没有改变，只是将指针指向了change1 2.基本数据类型不可以添加属性和方法 3.基本数据类型的赋值是简单的赋值。就直接把值给你 4.基本数据类型值的比较是值的比较 5.基本数据类型存放在栈区 包括变量的标识符和值 引用数据类型1.引用类型的值是可以改变的 2.引用类型可以添加属性和方法 3.引用类型的赋值是对象的引用（只是把指针给你） 4.引用类型的比较是引用的比较 5.引用类型是同时存在栈和堆中 引用类型的存储需要在内存的栈区和堆区共同完成，栈区保存变量标识符和指向堆内存的地址 基本包装类型ECMAScript还提供了三个特殊的引用类型Boolean,String,Number.我们称这三个特殊的引用类型为基本包装类型，也叫包装对象. 12var s1 = \"helloworld\";var s2 = s1.substr(4); 所以当第二行代码访问s1的时候，后台会自动完成下列操作： 创建String类型的一个实例；// var s1 = new String(“helloworld”); 在实例上调用指定方法；// var s2 = s1.substr(4); 销毁这个实例；// s1 = null; 正因为有第三步这个销毁的动作，所以你应该能够明白为什么基本数据类型不可以添加属性和方法，这也正是基本装包类型和引用类型主要区别：对象的生存期.使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中.而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁 123var a=new String('A');var b=new String('A');a==b //false Null 和 Undefined 的区别1234Number(Null)//05+Null //5Number(undefined)// NaN5 + undefined// NaN null表示”没有对象”，即该处不应该有值 （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 //new Object(null). 没有继承任何对象，自己就是终点 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义 （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 Object.defineProperty(obj, prop, descriptor)descriptor中定义的参数用来定义或修改的属性的描述符 configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。 enumerable当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。。 属性特性 enumerable 决定这个属性是否能被 for...in 循环或 Object.keys 方法遍历得到 writable当且仅当该属性的 writable 为 true 时，该属性才能被[赋值运算符]改变。 value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。 get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。 关于对象添加getter和setter的方法1.通过对象初始化器在创建对象的时候指明（也可以称为通过字面值创建对象时声明） 1234567891011(function () &#123; var o = &#123; a : 7, get b()&#123;return this.a +1;&#125;,//通过 get,set的 b,c方法间接性修改 a 属性 set c(x)&#123;this.a = x/2&#125; &#125;; console.log(o.a); console.log(o.b); o.c = 50; console.log(o.a);&#125;)(); 2.使用 Object.create 方法. Object.create(proto, [ propertiesObject ]) 123456789101112131415161718192021(function () &#123; var o = null; o = Object.create(Object.prototype,//指定原型为 Object.prototype &#123; bar:&#123; get :function()&#123; return this.a; &#125;, set : function (val) &#123; console.log(\"Setting `o.bar` to \",val); this.a = val; &#125;, configurable :true &#125; &#125;//第二个参数 ); o.a = 10; console.log(o.bar); o.bar = 12; console.log(o.bar);&#125;)(); 3.使用 Object.defineProperty 方法. Object.defineProperty(obj, prop, descriptor) 12345678910111213141516(function () &#123; var o = &#123; a : 1&#125;//声明一个对象,包含一个 a 属性,值为1 Object.defineProperty(o,\"b\",&#123; get: function () &#123; return this.a; &#125;, set : function (val) &#123; this.a = val; &#125;, configurable : true &#125;); console.log(o.b); o.b = 2; console.log(o.b);&#125;)(); 4.使用 Object.defineProperties方法. Object.defineProperties(obj, props) 1234567891011121314151617181920(function () &#123; var obj = &#123;a:1,b:\"string\"&#125;; Object.defineProperties(obj,&#123; \"A\":&#123; get:function()&#123;return this.a+1;&#125;, set:function(val)&#123;this.a = val;&#125; &#125;, \"B\":&#123; get:function()&#123;return this.b+2;&#125;, set:function(val)&#123;this.b = val&#125; &#125; &#125;); console.log(obj.A); console.log(obj.B); obj.A = 3; obj.B = \"hello\"; console.log(obj.A); console.log(obj.B);&#125;)(); 对象的扩展，密封以及冻结 扩展特性 Object.isExtensible 方法 可扩展和上述的可修改不是一个概念 12345678910//对象是否可以扩展与对象的属性是否可以配置无关empty = Object.create(&#123;&#125;,&#123; \"a\":&#123; value : 1, configurable : false,//不可配置 enumerable : true,//可枚举 writable : true//可写 &#125;&#125;);console.log(Object.isExtensible(empty) === true);//true Object.preventExtensions 方法 修改为不可扩展。如果为当前不可扩展对象 empty 修改属性是成功的，这是因为一个对象的属性是否可以被修改与该对象是否可以扩展无关，而是与该对象在创建的时候是否声明为不可重写有关 密封特性 Object.isSealed 方法 密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象。 123456789101112131415161718(function () &#123; //新建的对象默认不是密封的 var empty = &#123;&#125;; console.log(Object.isSealed(empty) === false);//true //如果把一个空对象变得不可扩展,则它同时也会变成个密封对象. Object.preventExtensions(empty); console.log(Object.isSealed(empty) === true);//true //但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的. var hasProp = &#123;fee : \"fie foe fum\"&#125;; Object.preventExtensions(hasProp); console.log(Object.isSealed(hasProp) === false);//true //如果把这个属性变得不可配置,则这个对象也就成了密封对象. Object.defineProperty(hasProp,\"fee\",&#123;configurable : false&#125;); console.log(Object.isSealed(hasProp) === true);//true&#125;)(); Object.seal 方法 1234Object.seal(o); //与下面的操作效果相同Object.defineProperty(o,\"a\",&#123;configurable:false,writable:false&#125;);Object.preventExtensions(o); 冻结特性 Object.isFrozen 方法 冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。 Object.freeze 方法 浅冻结 与 深冻结 倘若一个对象的属性是一个对象，那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结，若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。 深冻结：遍历递归操作冻结每一层 事件代理Jquery1234$(\"#tab\").bind(\"click\",function(ev))&#123; var $obj=$(ev.target); $obj.css(\"background\",\"red\");&#125; Js123456var ulNode=document.getElementById(\"list\");ulNode.addEventListener('click',function(e)&#123; if(e.target&amp;&amp;e.target.nodeName.toUpperCase()==\"LI\")&#123;/*判断目标事件是否为li*/ alert(e.target.innerHTML); &#125; &#125;,false); async和defer的作用是什么？有什么区别1. 没有defer或async属性，浏览器会立即加载并执行相应的脚本。也就是说在渲染script标签之后的文档之前，不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载；2. 有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；（异步加载，加载完马上执行）3. 有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。(不耽误后边文档加载，但是都加载完执行。) event对象属性方法onblur onload onkeyup onmouseup for in 和for of的区别是什么for in 遍历的是索引. 还可以遍历对象，但是可能会遍历到继承的元素方法，使用hasOwnProperty（）判断 for of遍历的是对应的元素值 遍历对象新出的 Object.keys() Object.values. Object.entires() 遍历对象Object.keys. for..in 深复制与浅复制1.直接用等号赋值 浅复制 2.Object.assign() 居然也是浅复制. 因为copy对象的时候是复制指针 12345678910111213141516171819202122let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; // Deep Clone obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 3.jQuery.extend vue的touch函数？ 4.Json.parse. Json.stringify 闭包 ！什么是闭包？定义：当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 辨认：就两点，1内部有一个函数保存了作用域内的变量 2这个变量暴露暴露出来 例子： 123456789101112function wait(message)&#123; setTimeout(function timer()&#123; console.log(message) &#125;,1000);&#125; //不是非得return出去才叫暴露function setup(name,selector)&#123; $(selector).click(function activator()&#123; console.log(name) &#125;);&#125; //在任务中，只要使用了回调函数，实际上就是在使用闭包 12345678910111213141516function Counter(start) &#123; var count = start; return &#123; increment: function() &#123; count++; &#125;, get: function() &#123; return count; &#125; &#125;&#125;var foo = Counter(4);foo.increment();foo.get(); // 5 其实这就是模块的写法 闭包与setTimeout因为for循环他们共享同一个 12345var result = [];for (var i=0; i &lt; 5; i++) &#123; result.push(function () &#123; return i &#125;); // (*)&#125;console.log(result[3]()); // 5 (not 3) 改变函数使得输出12345 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; answer 1234567891011121314151617181920212223for (var i=1; i&lt;=5; i++) &#123; (function(i)&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,i*1000) &#125;)(i)&#125;for(var i=1;i&lt;5;i++)&#123; setTimeout((function timer()&#123; return function(i)&#123; console.log(i) &#125;)(i) &#125;,i*1000)&#125; for(var i = 0; i &lt; 10; i++) &#123; setTimeout((function(e) &#123; return function() &#123; console.log(e); &#125; &#125;)(i), 1000)&#125; 1234567891011var output = function (i) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 5; i++) &#123; output(i); // 这里传过去的 i 值被复制了&#125;console.log(new Date, i); 使用Promise 12345678910111213141516171819const tasks = []; // 这里存放异步操作的 Promiseconst output = (i) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); resolve(); &#125;, 1000 * i);&#125;);// 生成全部的异步操作for (var i = 0; i &lt; 5; i++) &#123; tasks.push(output(i));&#125;// 异步操作完成之后，输出最后的 iPromise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000);&#125;); 1234567891011121314// 模拟其他语言中的 sleep，实际上可以是任何异步操作const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeountMS);&#125;);(async () =&gt; &#123; // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(new Date, i); &#125; await sleep(1000); console.log(new Date, i);&#125;)(); 变异啦！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; //内部其实没有对参数的引用，所以还是55555for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)();&#125; //undefined x5for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; //立即执行函数立即执行，setTimeout就等于传了个undefined。会立刻输出01234setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; //2 3 5 4 1 console.log(4); &#125;);console.log(5); //执行过程如下：JavaScript引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行；然后再从macrotask queue中取下一个，执行完毕后，再次将microtask queue中的全部取出；循环往复，直到两个queue中的任务都取完。解释：代码开始执行时，所有这些代码在macrotask queue中，取出来执行之。后面遇到了setTimeout，又加入到macrotask queue中，然后，遇到了promise.then，放入到了另一个队列microtask queue。等整个execution context stack执行完后，下一步该取的是microtask queue中的任务了。因此promise.then的回调比setTimeout先执行 创建对象的三种方法原型对象12345678910111213141516//Object.create(proto, [ propertiesObject ]) 第二个参数为新要添加的属性var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125; 构造函数123456789101112function Student(props) &#123; this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125; class 实现12345678910111213141516171819class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 上下文和作用域在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续寻找。直到找到该变量，或抵达最外层的作用域为止。 123456789101112function foo()&#123; console.log(a); //2&#125;function bar()&#123; var a=3; foo();&#125;var a=2;bar(); 作用域分为两种，词法作用域和动态作用域。js是词法作用域。 词法作用域最重要的特征是它的定义过程发生在代码书写阶段。 this的误区指向自身，this指向函数的作用域。 //this取决于调用位置 this和上下文作用域分成声明和赋值两个步骤。一开始先声明，然后赋值的时候如果没声明再声明（全局作用域），最后赋值。 this不是author-time binding，而是 runtime binding。 当函数作为对象方法调用时，this指向该对象。 12345678var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37 this对象绑定规则（箭头函数不满足）new&gt;call或者apply&gt;上下文对象调用&gt;严格模式下绑定undefined否则global 123456789var p= &#123; data:&#123; flag: true &#125;, init: ()=&gt;&#123; console.log(this.data.flag) &#125;&#125; //箭头函数没有自己的this，他的this值继承自外部。而这里就是继承p的，p的上下文this是全局 window对象了，所以会报 undefined的错误p.init() //结果是undefined，如果是普通函数结果是true 特殊情况！： 深度拷贝对象https://www.zhihu.com/question/230312151234567891011121314151617181920212223242526272829303132333435363738394041window.val = 1; var obj = &#123; val: 2, dbl: function () &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125; &#125;; // 说出下面的输出结果 obj.dbl(); var func = obj.dbl; func(); // 2 4 8 8 var obj = &#123; say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125; &#125; obj.say() var obj = &#123; say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125; &#125; obj.say() 12345678var a=10;(function test()&#123; console.log(a);//undefined a=100; console.log(a);//100 console.log(this.a);//10 var a;&#125;)() 正则表达式RegExp 是JS中的类，同Array类似。 第一个参数正则匹配。第二个参数（g:全局查找 i:不区分大小写 m:多行查找） 正则表达式的方法test()—return boolean exec()—return a Array with index and input search()—return index and u can both input RegExp or String //字符串带的方法 replace()—as it looks like difference between [] {} ()[0-9] 查找任何从 0 至 9 的数字 {8} 表示位数为8位 ()的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如(\\s+)表示连续空格的字符串 ^ 和 $^ 匹配一个字符串的开头，比如 (^a) 就是匹配以字母a开头的字符串 $ 匹配一个字符串的结尾,比如 (b$) 就是匹配以字母b结尾的字符串 ^还有另个一个作用就是取反，比如[^xyz]表示匹配的字符串不包含xyz \\d \\s \\w .\\d 匹配一个非负整数， 等价于 [0-9]； \\s 匹配一个空白字符； \\w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]； . 匹配除换行符以外的任意字符，等价于[^\\n]。 * + ?*表示匹配前面元素0次或多次，比如(\\s*)就是匹配0个或多个空格； + 表示匹配前面元素1次或多次，比如(\\d+)就是匹配由至少1个整数组成的字符串； ?表示匹配前面元素0次或1次，相当于{0,1}，比如(\\w?) 就是匹配最多由1个字母或数字组成的字符串 。 还有一些语法[adgk] 查找给定集合内的任何字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NULL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 n{X,Y} X和 Y 为正整数。前面的模式n 连续出现至少 X次，至多 Y次时匹配 ?=n 匹配任何其后紧接指定字符串n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 vuediff算法https://segmentfault.com/a/1190000008782928 为什么要virtual dom操作dom太耗资源，所以优化为操作对象 核心：比较只会在同层级进行, 不会跨层级比较。更新流程： 1.先判断两个vnode的key和sel是否相同。不值的比较就直接用新节点替代老节点。否则进入第二步 2.节点的比较有5种情况 if (oldVnode === vnode)，他们的引用一致，可以认为没有变化。 if(oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用Node.textContent = vnode.text。 if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用updateChildren函数比较子节点，这是diff的核心，后边会讲到。 else if (ch)，只有新的节点有子节点，调用createEle(vnode)，vnode.el已经引用了老的dom节点，createEle函数会在老dom节点上添加子节点。 else if (oldCh)，新节点没有子节点，老节点有子节点，直接删除老节点。 3.通过设置的key进行遍历比较子节点 结论 尽量不要跨层级的修改dom 设置key可以最大化的利用节点 不要盲目相信diff的效率，在必要时可以手工优化 自己写一个vue组件https://juejin.im/entry/58a11c648d6d81006c9d739d 仿照着分页自己写了个conole-panel的控制台。主要实现了，黑色背景，字体，以及随着控制log的增加，自动跟随到最新的信息。大概的思路就是自己写个普通的组件，要填的通过props传进来。然后vue.use引用就好了 父子组件间通信12345678910111213141516171819202122232425262728293031&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt; Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 非父子组件间通信如果2个组件不是父子组件那么如何通信呢？这时可以通过eventHub来实现通信.所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件. 1let Hub = new Vue(); //创建事件中心11 组件1触发： 123456&lt;div @click=&quot;eve&quot;&gt;&lt;/div&gt;methods: &#123; eve() &#123; Hub.$emit(&apos;change&apos;,&apos;hehe&apos;); //Hub触发事件 &#125;&#125;123456123456 组件2接收: 123456&lt;div&gt;&lt;/div&gt;created() &#123; Hub.$on(&apos;change&apos;, () =&gt; &#123; //Hub接收事件 this.msg = &apos;hehe&apos;; &#125;);&#125;123456123456 这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！ vue的生命周期beforecreate created beforemounted mounted beforeupdate updated activated deactivated beforedestory destroyed vue的生命周期各阶段都做了什么？beforeCreate 实例创建前：这个阶段实例的data、methods是读不到的created 实例创建后：这个阶段已经完成了数据观测(data observer)，属性和方法的运算， watch/event 事件回调。mount挂载阶段还没开始，$el 属性目前不可见，数据并没有在DOM元素上进行渲染beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。mounted：el选项的DOM节点 被新创建的 vm.$el 替换，并挂载到实例上去之后调用此生命周期函数。此时实例的数据在DOM节点上进行渲染beforeUpdate：数据更新时调用，但不进行DOM重新渲染，在数据更新时DOM没渲染前可以在这个生命函数里进行状态处理updated：这个状态下数据更新并且DOM重新渲染，当这个生命周期函数被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。当实例每次进行数据更新时updated都会执行beforeDestory：实例销毁之前调用。destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue生命周期在真实场景下的业务应用created：进行ajax请求异步数据的获取、初始化数据mounted：挂载元素内dom节点的获取nextTick：针对单一事件更新数据后立即操作domupdated：任何数据的更新，如果要做统一的业务逻辑处理watch：监听具体数据变化，并做相应的处理 react的写法 12345678910111213141516171819202122232425262728293031323334class Brother2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; render()&#123; return ( &lt;div&gt; &#123;this.props.text || \"兄弟组件未更新\"&#125; &lt;/div&gt; ) &#125;&#125;class Parent extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;&#125; &#125; refresh()&#123; return (e)=&gt;&#123; this.setState(&#123; text: \"兄弟组件沟通成功\", &#125;) &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;兄弟组件沟通&lt;/h2&gt; &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt; &lt;Brother2 text=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ) react组件之间交流方式父子：父组件更新组件状态／子组件触发更新父组件状态—也在props里调用父亲组件的方法改变state 兄弟：借助父组件更新，层次比较深就很不方便／React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。 vuex是为什么出现的 管理多个组件共享状态。 全局状态管理。 状态变更跟踪。 让状态管理形成一种规范，使代码结构更清晰。 源码中的遍历对象12345678910111213function touch(obj)&#123; if(obj === 'Object')&#123; if(Array.isArray(obj))&#123; obj.forEach(ele =&gt; &#123;touch(ele)&#125;) &#125;else&#123; let keys=Object.keys(obj) for(let key in keys)&#123; touch(obj[key]) &#125; &#125; &#125; console.log(obj);&#125; 构建工具webpack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// webpack.config.jsvar webpack = require(\"webpack\");var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; devtool: \"source-map\", //配置生成 Source Maps 的选项 将编译前后代码每行一 一对应起来，有四个不同轻重的选项。 entry: __dirname + \"/app/main.js\", //入口文件路径 output: &#123; path: __dirname + \"/build/\", //存放打包后文件的地方路径 filename: \"[name]-[hash].js\" //打包后的文件名 &#125;, devServer: &#123; //构建本地服务器 port: \"9000\", inline: true, //改变文件自动刷新 historyApiFallback: true, hot: true &#125;, module: &#123; //loader进行文件预处理，允许js之外所有静态自由 loaders: [&#123; //匹配不同文件进行解析 test: /\\.json$/, loader: \"json-loader\" &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, //编译打包时需要排除 node_modules 文件夹 loader: \"babel-loader\" //.babelrc将babel配置写到这个文件中 &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader?modules!postcss-loader\" //cssmodules运用模块 //postcss 解析scss,less之类的 //css-loader 使你能够使用类似 @import 和 url(...) 的方法实现 require() 的功能 //style-loader 将所有的计算后的样式加入页面中 &#125;) &#125;] &#125;, plugins: [ //插件 new webpack.BannerPlugin(\"Copyright Flying Unicorns inc.\"), //在这个数组中new一个实例就可以了 new HtmlWebpackPlugin(&#123; template: __dirname + \"/app/index.tmpl.html\" //new一个插件的实例，并传入相关的参数 &#125;), new webpack.HotModuleReplacementPlugin(), //热加载插件 new webpack.optimize.OccurrenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(\"[name]-[hash].css\") ]&#125; Webpack中 —save-dev 和 —save 的区别前者是开发时候用的，后者是发布之后也要用的 模块系统CommonJSNodejs 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 AMDAsynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。 1234define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123; return someExportedValue;&#125;);require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS CMDCommon Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。 123456define(function(require, exports, module) &#123; var $ = require(&apos;jquery&apos;); var Spinning = require(&apos;./spinning&apos;); exports.doSomething = ... module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行 CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 123456789101112//CMDdefine(function(require,exports,module)&#123; var a = require(\"./a\"); a.doSomethis(); var b = require(\"./b\")//依赖可以就近书写 b.doSomething()&#125;)//AMDdefine(['./a,./b'],function(a,b)&#123;//依赖必须一开始就写好 a.dosomething() b.dosomething()&#125;) webpack vs gulp&amp;grunt前者的工作流程是，将整个项目作为一个主体，通过给定的主文件，根据整个文件开始找到项目的所有依赖。然后通过loaders处理，最后打包成一个浏览器可以识别的js文件。 后者就有点像小孩。在配置文件中给出需要对文件的各种操作命令，然后他会帮你操作完成。 清除浮动清除浮动 还是 闭合浮动 外边距重合，父div撑不起来 清除浮动指的是运用clear属性去解决浮动父容器高度塌陷的问题，clear属性规定元素的哪一侧不允许其他浮动元素。可选择的值有：left, right, both, none, inherit 清除浮动方法1：通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素。 清除浮动方法2：BFC（Block Format Content）清理浮动，BFC可以阻止垂直外边距折叠、不会重叠浮动元素、可以包含浮动。因此清理浮动在BFC的语境下就是“包含浮动”，也即让父容器形成BFC就可以。 会触发BFC的条件有： float的值不为none。 overflow的值不为visible。 display的值为table-cell, table-caption, inline-block 中的任何一个。 position的值不为relative 和static。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 ps：一个包另一个，被包的那个的margin就被吃掉了，还是贴在一起的！！！ 还有一种就是里边是float外边div，就撑不开，跑外边来了 css圆角如果是长度，就是圆角的半径，0就是直角。 如果是百分比，超过50%，四个角就合成椭圆了 浏览器渲染兵分三路。HTML/SVG/XHTML负责DOM树，css负责css树，js通过相应的api操作这两个树，解析完成后通过两个树变成渲染树。 ps：Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。 回流与重绘 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 Resize ,Add or delete element 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 Change color 注意：回流必将引起重绘，而重绘不一定会引起回流。 浏览器很聪明，回流重绘到一定数量才会发生。 如何减少回流和重绘一次性更改style，绝对定位复杂操作的动画。不要把DOM结点的属性值放在一个循环里当成循环里的变量。千万不要使用table布局 当你增加、删除、修改DOM结点时，会导致Reflow或Repaint 当你移动DOM的位置，或是搞个动画的时候。 当你修改CSS样式的时候。 当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 第二部分 计算机网络在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？dns缓存（地址），cdn缓存（文件），浏览器缓存，服务器缓存。 关于cookie的一切cookie的属性： Domain：域，表示当前cookie所属于哪个域或子域下面。（www.jianshu.com） Path：表示cookie的所属路径。（／） Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了（2017-10-20T02:16:19.000Z） secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。 httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。 服务器发送cookie给客户端： 从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。 Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.169it.com; HttpOnly 从客户端把cookie发送到服务器： 从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。 关于修改，设置cookie： 除了服务器发送给客户端（浏览器）的时候，通过Set-Cookie，创建或更新对应的cookie之外，还可以通过浏览器内置的一些脚本，比如javascript，去设置对应的cookie，对应实现是操作js中的document.cookie。 Cookie的缺陷： (1)cookie会被附加在每个HTTP请求中，所以无形中增加了流量。 (2)由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS) (3)Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。 浏览器缓存机制Cache-Control：max-age=600。设置有效时长 Expires：一个时间节点，表示在这个时间节点之前都是有效的 Last-Modified（或 Etag）：最后一次更新时间节点 Etag：相当于一个tagid，上传到server端检查id是否一致 200 for cache vs 304 not Modify 200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存 304&lt;——&gt;由last-modify&amp;&amp;etag控制。 200 for cache&lt;——&gt;由Cache-Control &amp;&amp; Expires控制。前者优先级更高 http报文格式请求报文请求行 //三个字段：方法字段，URL字段，HTTP版本 请求头部 //Host 请求主机名，Accept 客户端可识别的内容类型列表，User-Agent 产生请求的浏览器类型， Connection 是否持续保持连接 请求正文 //POST 响应报文状态行 //由HTTP协议版本号， 状态码， 状态消息 响应头部. //Date：服务器生成响应报文并发送的日期和时间，该时间是服务器在它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。Server:表示该报文是由一台Apache Web服务器产生的。Last-Modified： 对象创建或最后修改的时间。Content-Type：指定了实体中的对象是HTML(text/html),编码类型是UTF-8 空行告诉下一行是正文 响应正文 为什么要三次握手，四次挥手三次是为了server端一直等待。server 说好，但是服务器端没收到或者发的没收到。 四次是因为双方都有可能还有信息没有发，所以需要各自都说不发了。 为什么要重定向其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。 301 or 302 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 反向代理 所有服务器前面加个代理来分配大量的请求响应 http状态码1xx：信息性状态码，表示服务器接受请求正在处理 2xx：成功状态码，表示服务器正确处理完请求 3xx：重定向状态码，表示请求资源位置发生改变，需要重新重定向 4xx：服务器端错误状态码，服务器无法处理该请求 5xx：服务器错误状态码，服务器处理请求错误 面试官问了问题，是直接返回404好还是返回200在response的body中返回404比较好 1**：信息性状态码 2**：成功状态码 200：OK 请求正常处理 204：No Content请求处理成功，但没有资源可返回 206：Partial Content对资源的某一部分的请求 3**：重定向状态码 301：Moved Permanently 永久重定向 302：Found 临时性重定向 304：Not Modified 缓存中读取 4**：客户端错误状态码 400：Bad Request 请求报文中存在语法错误 401：Unauthorized需要有通过Http认证的认证信息 403：Forbidden访问被拒绝 404：Not Found无法找到请求资源 5**：服务器错误状态码 500：Internal Server Error 服务器端在执行时发生错误 503：Service Unavailable 服务器处于超负载或者正在进行停机维护 计算机网络—自顶向下总结(http://www.jianshu.com/p/48f2bebaeb40)应用层 进程与计算机网络间的接口协议http协议（web） ：无状态，乱序是TCP考虑的事，拉协议 FTP协议（文件传输） SMTP协议（电子邮件）：推协议 DNS主机名—&gt;IP地址转换的目录服务 通常从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的 攻击DDos：向处理如.com域的域名服务器发送大量DNS请求，使得大部分合法请求无法获得响应 DNS反射：请求中冒充目标主机源地址，大量请求DNS服务器，DNS就大量向源地址主机发送回答，淹没目标主机 传输层 为应用程序提供正确的应用级进程之间的交付服务协议TCP：有连接的，需要握手包到底的。稳定但是大。HTTP FTP head:20bit TCP does error checking and error recovery. Erroneous packets are retransmitted from the source to the destination. UDP： DNS,VOIP. 8bit UDP does error checking but simply discards erroneous packets. Error recovery is not attempted. 网络层仅在网络层提供连接服务的计算机网络成为虚电路；仅在网络层提供无连接服务的计算机网络称为数据报网络 链路层物理层第三部分 简历和面试技巧总结回答职业规划类型问题体现扎根动机，公司优秀多向公司学习 反问面试官的最后一个问题这次面试我还有哪些需要提高的地方在公司里的部门，做什么平常关注的前端消息知乎，前端周刊 https://zhuanlan.zhihu.com/p/27966492 ​ 前端外看评论 https://zhuanlan.zhihu.com/FrontendMagazine ​ 前端学习指南 https://zhuanlan.zhihu.com/study-fe ​ 前端大哈 https://zhuanlan.zhihu.com/qianduandaha 看过的前端书籍权威指南，你不知道的js，understunding es6，阮es6，DOM编程艺术，bad things about JavaScript，图解http，css secrets ,css 权威指南，算法导论，jquery实战，黑客与画家,编写高质量JavaScript代码的68个有效方法,Head First HTML5 Programming,数据结构与算法JavaScript描述，编写高质量代码–Web前端开发修炼之道，javascript秘密花园，javascript的怪癖，Git教程，css编写规范，深入理解javascript，typescript， 廖雪峰 阮一峰 公众号前端大全 算法与数学之美 36氪 IFE 简历内容具体分析弹幕功能实现： 颜色随机 span.style.color = colors[index]; 高度：算出一共能多少行，随机行数 一开始在屏幕的最右侧： var screenW = window.innerWidth;span.style.left = screenW +’px’; 动态往左：arr[i] -= 2。oSpan[i].style.left = arr[i]+’px’; 判断是否超出屏幕：if (arr[i] &lt; -oSpan[i].offsetWidth) 细节处理： 观看量35万的视5000条弹幕。可以设置屏幕的弹幕数，vip有优先权。 bilibili也会出现弹幕太多覆盖屏幕，只能关了再看。会有遮盖，不过颜色不同，行高固定。 使用的是transform translate chorme插件调试安卓手机 所以也不用再在chrome上安装ADB插件了 但需要下载最新的chrome chrome://inspect 手机上看到的内容pc端可以同步审查元素 mock后端数据json-server react生命周期http://www.jianshu.com/p/4784216b8194 git版本控制Master 正式发版用 Develop 开发重大版本 Feature 开发某种特定功能 Release 发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试 Fixbug 修补bug分支 后三种为临时分支，用完就删 Dev git checkout -b develop master 创建分枝 git checkout master 切换到Master分支 git merge –no-ff develop 对Develop分支进行合并 这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 Feature git checkout -b feature-x develop git checkout develop git merge –no-ff feature-x git branch -d feature-x 删除分支 Release git checkout -b release-1.2 develop git checkout master git merge –no-ff release-1.2 git tag -a 1.2 对合并生成的新节点，做一个标签 Fixbug git checkout -b fixbug-0.1 master git checkout master git merge –no-ff fixbug-0.1 git tag -a 0.1.1 git checkout develop git merge –no-ff fixbug-0.1 git checkout develop git merge –no-ff fixbug-0.1 滚屏加载123456789101112131415161718192021222324252627$(function()&#123; var winH = $(window).height(); //页面可视区域高度 var i = 1; //设置当前页数 $(window).scroll(function () &#123; var pageH = $(document.body).height(); var scrollT = $(window).scrollTop(); //滚动条top var aa = (pageH-winH-scrollT)/winH; if(aa&lt;0.02)&#123; $.getJSON(\"result.php\",&#123;page:i&#125;,function(json)&#123; if(json)&#123; var str = \"\"; $.each(json,function(index,array)&#123; var str = \"&lt;div class=\\\"single_item\\\"&gt;&lt;div class=\\\"element_head\\\"&gt;\"; var str += \"&lt;div class=\\\"date\\\"&gt;\"+array['date']+\"&lt;/div&gt;\"; var str += \"&lt;div class=\\\"author\\\"&gt;\"+array['author']+\"&lt;/div&gt;\"; var str += \"&lt;/div&gt;&lt;div class=\\\"content\\\"&gt;\"+array['content']+\"&lt;/div&gt;&lt;/div&gt;\"; $(\"#container\").append(str); &#125;); i++; &#125;else&#123; $(\".nodata\").show().html(\"别滚动了，已经到底了。。。\"); return false; &#125; &#125;); &#125; &#125;); &#125;); Js： 网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidth JQuery: $(document).ready(function(){alert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height());//浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding marginalert($(window).width()); //浏览器当前窗口可视区域宽度alert($(document).width());//浏览器当前窗口文档对象宽度alert($(document.body).width());//浏览器当前窗口文档body的宽度alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 当数据量很大的时候，更细致的分析(https://juejin.im/post/58b545f0b123db005734634e)问题： 1.设置阀值，不要等到最后再拉动加载，比如可以提前一页 2.top，temp，bottom三块，滚动过程中不断改变数组中数据，保证数据长度一定。 3.dom操作是阻塞的 衡量标准： 1.使用window.performance HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。 2.使用console.time方法与console.timeEnd方法 其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。 解决思路： 但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题： 1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。 2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。 “截流和防抖动函数”（Throttle和Debounce）。简单总结一下： 1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间; 2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。 基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。 其中，是否发生滚动由lastScrollY === window.scrollY来判断。 document.body.scrollTop DOM回收 每加载一次数据，就生成“.page-container .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。 总结—一共就四点优化dom回收，维持dom数量。 对于滚动事件的监听 不要等到拉到最后再加载。 墓碑（Tombstones）—先占位","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/centmaster/hexo-centmaster/tags/interview/"}]},{"title":"react 更新机制的源码研究","slug":"react-refresh","date":"2017-09-07T14:01:39.000Z","updated":"2017-09-13T14:29:48.000Z","comments":true,"path":"2017/09/07/react-refresh/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/07/react-refresh/","excerpt":"Virtual DOMDOM元素非常庞大，具有复杂的属性，牵一发而动全身。通过JavaScript来模拟DOM树的结构，加快响应时间 建立虚拟DOM树：用JavaScript对象记录节点类型、属性、子节点。通过递归该虚拟DOM建立真正的DOM树 diff算法：因为跨层DOM操作很少，只比较同层DOM，从而将O(n^3)的比较降低到O(n)复杂度，深度优先遍历，记录差异： 替换节点类型： div -&gt; p 增、删、调换子节点 修改节点属性 修改文本内容 记录差异类型，差异内容，压入patch数组 根据patch数组，对真实DOM进行操作。","text":"Virtual DOMDOM元素非常庞大，具有复杂的属性，牵一发而动全身。通过JavaScript来模拟DOM树的结构，加快响应时间 建立虚拟DOM树：用JavaScript对象记录节点类型、属性、子节点。通过递归该虚拟DOM建立真正的DOM树 diff算法：因为跨层DOM操作很少，只比较同层DOM，从而将O(n^3)的比较降低到O(n)复杂度，深度优先遍历，记录差异： 替换节点类型： div -&gt; p 增、删、调换子节点 修改节点属性 修改文本内容 记录差异类型，差异内容，压入patch数组 根据patch数组，对真实DOM进行操作。 diff算法自我理解1.忽略跨层级操作 tree diff 2.拥有相同类的组件拥有相似的树结构 component diff 3.同一个层级之间的节点通过key进行优化 element diff tree diff同一个层级之间更改，不同层级就直接删除 component diff同一类型的组件比较，不同类型直接替换。 允许shouldcomponentupdate自己要求是否更新 element diff每个element都有自己的key。遍历过程中还有个lastindex表示遍历过的节点中在老节点位置中最右的index。 然后新节点便利，如果在老节点中index比lastindex小，挪动。新出来的节点的话加上去。如果index比lastindex大，不动。最后再遍历一遍老节点，删除已经没有的老节点。 说白了：新节点位置已经比左边的新节点位置靠右了，如果在老节点中比你靠左，那就说明得挪嘛。 更新机制我们知道，react的state变化需要借助setState，在setState后再利用virtual dom，虚拟dom差异化算法（diff algorithm）更新元素元素和节点，实现更新机制。下面我们来具体讨论关于自定义元素的整个更新机制的流程。 react自定义元素通过receiveComponent实现更新的机制如下为我们使用setState的具体场景。当我们点击文字的时候就会出发更新事件。 1234567891011121314var HelloMessage = React.createClass(&#123; getInitialState: function() &#123; return &#123;type: 'say:'&#125;; &#125;, changeType:function()&#123; this.setState(&#123;type:'shout:'&#125;) &#125;, render: function() &#123; return React.createElement(\"div\", &#123;onclick:this.changeType&#125;,this.state.type, \"Hello \", this.props.name); &#125;&#125;);React.render(React.createElement(HelloMessage, &#123;name: \"John\"&#125;), document.getElementById(\"container\")); 我们首先来定义一个ReactClass类。我们可以看到调用setState会出发receiveComponent方法。所有的挂载，更新都应该交给对应的component来管理。 12345678910//定义ReactClass类var ReactClass = function()&#123;&#125;ReactClass.prototype.render = function()&#123;&#125;//setStateReactClass.prototype.setState = function(newState) &#123; this._reactInternalInstance.receiveComponent(null, newState);&#125; 接下来我们来具体实现这个类。首先，我们合并改动，用改动后最新的state，props与改动前对比。如果shouldComponentsUpdate为true，我们真正开始更新。然后判断新的属性与原来差的多不多，多的话就直接用新的渲染就好了，不多的话就更新element。如果要更新就继续调用对应的component类对应的receiveComponent，本质上还是递归调用receiveComponent的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//更新ReactCompositeComponent.prototype.receiveComponent = function(nextElement, newState) &#123; //如果接受了新的，就使用最新的element this._currentElement = nextElement || this._currentElement var inst = this._instance; //合并state var nextState = $.extend(inst.state, newState); var nextProps = this._currentElement.props; //改写state inst.state = nextState; //如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。 if (inst.shouldComponentUpdate &amp;&amp; (inst.shouldComponentUpdate(nextProps, nextState) === false)) return; //生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。 if (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState); var prevComponentInstance = this._renderedComponent; var prevRenderedElement = prevComponentInstance._currentElement; //重新执行render拿到对应的新element; var nextRenderedElement = this._instance.render(); //判断是需要更新还是直接就重新渲染 //注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法 if (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123; //如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。 prevComponentInstance.receiveComponent(nextRenderedElement); //调用componentDidUpdate表示更新完成了 inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); &#125; else &#123; //如果发现完全是不同的两种element，那就干脆重新渲染了 var thisID = this._rootNodeID; //重新new一个对应的component， this._renderedComponent = this._instantiateReactComponent(nextRenderedElement); //重新生成对应的元素内容 var nextMarkup = _renderedComponent.mountComponent(thisID); //替换整个节点 $('[data-reactid=\"' + this._rootNodeID + '\"]').replaceWith(nextMarkup); &#125;&#125;//用来判定两个element需不需要更新//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。var _shouldUpdateReactComponent ＝ function(prevElement, nextElement)&#123; if (prevElement != null &amp;&amp; nextElement != null) &#123; var prevType = typeof prevElement; var nextType = typeof nextElement; if (prevType === 'string' || prevType === 'number') &#123; return nextType === 'string' || nextType === 'number'; &#125; else &#123; return nextType === 'object' &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key; &#125; &#125; return false;&#125; 其实这种更新方式与dom节点的diff算法一致，高效的更新渲染组件。 react的dom元素使用receiveComponent更新的实现说到这里我们必须要聊一聊diff算法的实现。 想一下我们怎么以最小代价去更新这段html呢。不难发现其实主要包括两个部分： 属性的更新，包括对特殊属性比如事件的处理 子节点的更新,这个比较复杂，为了得到最好的效率，我们需要处理下面这些问题： 拿新的子节点树跟以前老的子节点树对比，找出他们之间的差别。我们称之为diff 所有差别找出后，再一次性的去更新。我们称之为patch 所以我们定义receiveComponent方法如下 12345678910ReactDOMComponent.prototype.receiveComponent = function(nextElement) &#123; var lastProps = this._currentElement.props; var nextProps = nextElement.props; this._currentElement = nextElement; //需要单独的更新属性 this._updateDOMProperties(lastProps, nextProps); //再更新子节点 this._updateDOMChildren(nextElement.props.children);&#125; 首先是属性的变更。只需要把过时的删掉，添加上新的属性就好。要注意对于特殊事件的属性作出特殊处理。 12345678910111213141516171819202122232425262728293031323334353637383940ReactDOMComponent.prototype._updateDOMProperties = function(lastProps, nextProps) &#123; var propKey; //遍历，当一个老的属性不在新的属性集合里时，需要删除掉。 for (propKey in lastProps) &#123; //新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除 if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) &#123; continue; &#125; //对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //针对当前的节点取消事件代理 $(document).undelegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey]); continue; &#125; //从dom上删除不需要的属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').removeAttr(propKey) &#125; //对于新的属性，需要写到dom节点上 for (propKey in nextProps) &#123; //对于事件监听的属性我们需要特殊处理 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //以前如果已经有，说明有了监听，需要先去掉 lastProps[propKey] &amp;&amp; $(document).undelegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey]); //针对当前的节点添加事件代理,以_rootNodeID为命名空间 $(document).delegate('[data-reactid=\"' + this._rootNodeID + '\"]', eventType + '.' + this._rootNodeID, nextProps[propKey]); continue; &#125; if (propKey == 'children') continue; //添加新的属性，或者是更新老的同名属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').prop(propKey, nextProps[propKey]) &#125;&#125; 接下来是最核心的部分，关于dom节点的更新。把大象装进冰箱无非两部，找到差异（diff），更新（patch） 123456789101112131415161718192021222324252627ReactDOMComponent.prototype.receiveComponent = function(nextElement)&#123; var lastProps = this._currentElement.props; var nextProps = nextElement.props; this._currentElement = nextElement; //需要单独的更新属性 this._updateDOMProperties(lastProps,nextProps); //再更新子节点 this._updateDOMChildren(nextProps.children);&#125;//全局的更新深度标识var updateDepth = 0;//全局的更新队列，所有的差异都存在这里var diffQueue = [];ReactDOMComponent.prototype._updateDOMChildren = function(nextChildrenElements)&#123; updateDepth++ //_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 this._diff(diffQueue,nextChildrenElements); updateDepth-- if(updateDepth == 0)&#123; //在需要的时候调用patch，执行具体的dom操作 this._patch(diffQueue); diffQueue = []; &#125;&#125; _diff内部也会递归调用子节点的receiveComponent于是当某个子节点也是浏览器普通节点，就也会走_updateDOMChildren这一步。所以这里使用了updateDepth来记录递归的过程，只有等递归回来updateDepth为0时，代表整个差异已经分析完毕，可以开始使用patch来处理差异队列了。 首先我们先来看diff的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//差异更新的几种类型var UPATE_TYPES = &#123; MOVE_EXISTING: 1, REMOVE_NODE: 2, INSERT_MARKUP: 3&#125;//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识function flattenChildren(componentChildren) &#123; var child; var name; var childrenMap = &#123;&#125;; for (var i = 0; i &lt; componentChildren.length; i++) &#123; child = componentChildren[i]; name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(36); childrenMap[name] = child; &#125; return childrenMap;&#125;//主要用来生成子节点elements的component集合//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。//如果是新的节点，就会重新生成一个新的componentInstance，function generateComponentChildren(prevChildren, nextChildrenElements) &#123; var nextChildren = &#123;&#125;; nextChildrenElements = nextChildrenElements || []; $.each(nextChildrenElements, function(index, element) &#123; var name = element.key ? element.key : index; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var prevElement = prevChild &amp;&amp; prevChild._currentElement; var nextElement = element; //调用_shouldUpdateReactComponent判断是否是更新 if (_shouldUpdateReactComponent(prevElement, nextElement)) &#123; //更新的话直接递归调用子节点的receiveComponent就好了 prevChild.receiveComponent(nextElement); //然后继续使用老的component nextChildren[name] = prevChild; &#125; else &#123; //对于没有老的，那就重新新增一个，重新生成一个component var nextChildInstance = instantiateReactComponent(nextElement, null); //使用新的component nextChildren[name] = nextChildInstance; &#125; &#125;) return nextChildren;&#125;//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。ReactDOMComponent.prototype._diff = function(diffQueue, nextChildrenElements) &#123; var self = this; //拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的，记不得的可以翻上面 //_renderedChildren 本来是数组，我们搞成map var prevChildren = flattenChildren(self._renderedChildren); //生成新的子节点的component对象集合，这里注意，会复用老的component对象 var nextChildren = generateComponentChildren(prevChildren, nextChildrenElements); //重新赋值_renderedChildren，使用最新的。 self._renderedChildren = [] $.each(nextChildren, function(key, instance) &#123; self._renderedChildren.push(instance); &#125;) var nextIndex = 0; //代表到达的新的节点的index //通过对比两个集合的差异，组装差异节点添加到队列中 for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue; &#125; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; //相同的话，说明是使用的同一个component,所以我们需要做移动的操作 if (prevChild === nextChild) &#123; //添加差异对象，类型：MOVE_EXISTING diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.MOVE_EXISTING, fromIndex: prevChild._mountIndex, toIndex: nextIndex &#125;) &#125; else &#123; //如果不相同，说明是新增加的节点 //但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。 if (prevChild) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChild._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空 if (prevChild._rootNodeID) &#123; $(document).undelegate('.' + prevChild._rootNodeID); &#125; &#125; //新增加的节点，也组装差异对象放到队列里 //添加差异对象，类型：INSERT_MARKUP diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.INSERT_MARKUP, fromIndex: null, toIndex: nextIndex, markup: nextChild.mountComponent() //新增的节点，多一个此属性，表示新节点的dom内容 &#125;) &#125; //更新mount的index nextChild._mountIndex = nextIndex; nextIndex++; &#125; //对于老的节点里有，新的节点里没有的那些，也全都删除掉 for (name in prevChildren) &#123; if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChild._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听 if (prevChildren[name]._rootNodeID) &#123; $(document).undelegate('.' + prevChildren[name]._rootNodeID); &#125; &#125; &#125;&#125; 大概就做了如下几件事，首先component用来放element，把数组转成了对象map，用 key作为每个element的标识，递归的根据key查找看能复用，然后根据前后节点的不同分为这么几个情况，这几个情况分别处理。 类型 情况 MOVE_EXISTING 新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。 INSERT_MARKUP 新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点 REMOVE_NODE 老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。 REMOVE_NODE 老的component不在新的集合里的，我们需要删除 接下来我们一起来处理patch的实现。_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//用于将childNode插入到指定位置function insertChildAt(parentNode, childNode, index) &#123; var beforeChild = parentNode.children().get(index); beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);&#125;ReactDOMComponent.prototype._patch = function(updates) &#123; var update; var initialChildren = &#123;&#125;; var deleteChildren = []; for (var i = 0; i &lt; updates.length; i++) &#123; update = updates[i]; if (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) &#123; var updatedIndex = update.fromIndex; var updatedChild = $(update.parentNode.children().get(updatedIndex)); var parentID = update.parentID; //所有需要更新的节点都保存下来，方便后面使用 initialChildren[parentID] = initialChildren[parentID] || []; //使用parentID作为简易命名空间 initialChildren[parentID][updatedIndex] = updatedChild; //所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可 deleteChildren.push(updatedChild) &#125; &#125; //删除所有需要先删除的 $.each(deleteChildren, function(index, child) &#123; $(child).remove(); &#125;) //再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入 for (var k = 0; k &lt; updates.length; k++) &#123; update = updates[k]; switch (update.type) &#123; case UPATE_TYPES.INSERT_MARKUP: insertChildAt(update.parentNode, $(update.markup), update.toIndex); break; case UPATE_TYPES.MOVE_EXISTING: insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex); break; case UPATE_TYPES.REMOVE_NODE: // 什么都不需要做，因为上面已经帮忙删除掉了 break; &#125; &#125;&#125; 这样整个的更新机制就完成了。我们再来简单回顾下reactjs的差异算法： 首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。 react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。 每个类型的元素都要处理好自己的更新： 自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。 text节点的更新很简单，直接更新文案。 浏览器基本元素的更新，分为两块： 先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。 然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。 整个reactjs的差异算法就是这个样子。最核心的两个_shouldUpdateReactComponent以及diff,patch算法。","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"https://github.com/centmaster/hexo-centmaster/tags/mvvm/"}]},{"title":"mv* 三种模式直接的对比理解","slug":"mv","date":"2017-09-03T14:02:28.000Z","updated":"2017-09-13T14:29:39.000Z","comments":true,"path":"2017/09/03/mv/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/09/03/mv/","excerpt":"对于MVC、MVP、MVVM三种模式的理解 mv*本质都是处理model层和vision层之间的关系，数据的流动方式。","text":"对于MVC、MVP、MVVM三种模式的理解 mv*本质都是处理model层和vision层之间的关系，数据的流动方式。 数据驱动 在MVVM中，以前开发模式中必须先处理业务数据，然后根据的数据变化，去获取UI的引用然后更新UI，通过也是通过UI来获取用户输入，而在MVVM中，数据和业务逻辑处于一个独立的View Model中，ViewModel只要关注数据和业务逻辑，不需要和UI或者控件打交道。由数据自动去驱动UI去自动更新UI，UI的改变又同时自动反馈到数据，数据成为主导因素，这样使得在业务逻辑处理只要关心数据，方便而且简单很多。 低耦合度MVVM模式中，数据是独立于UI的，ViewModel只负责处理和提供数据，UI想怎么处理数据都由UI自己决定，ViewModel 不涉及任何和UI相关的事也不持有UI控件的引用，即使控件改变（TextView 换成 EditText）ViewModel 几乎不需要更改任何代码，专注自己的数据处理就可以了，如果是MVP遇到UI更改，就可能需要改变获取UI的方式，改变更新UI的接口，改变从UI上获取输入的代码，可能还需要更改访问UI对象的属性代码等等。 更新 UI在MVVM中，我们可以在工作线程中直接修改View Model的数据（只要数据是线程安全的），剩下的数据绑定框架帮你搞定，很多事情都不需要你去关心。 团队协作！MVVM的分工是非常明显的，由于View和View Model之间是松散耦合的。一个是处理业务和数据，一个是专门的UI处理。完全有两个人分工来做，一个做UI（xml 和 Activity）一个写ViewModel，效率更高。 可复用性一个View Model复用到多个View中，同样的一份数据，用不同的UI去做展示，对于版本迭代频繁的UI改动，只要更换View层就行，对于如果想在UI上的做AbTest 更是方便的多。 单元测试View Model里面是数据和业务逻辑，View中关注的是UI，这样的做测试是很方便的，完全没有彼此的依赖，不管是UI的单元测试还是业务逻辑的单元测试，都是低耦合的。 mvvm mvp mvc区别","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"https://github.com/centmaster/hexo-centmaster/tags/mvvm/"}]},{"title":"读书笔记","slug":"readbook","date":"2017-08-25T13:43:48.000Z","updated":"2017-09-13T14:29:55.000Z","comments":true,"path":"2017/08/25/readbook/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/08/25/readbook/","excerpt":"Javascript秘密花园删除属性的唯一方法是使用 delete 操作符；设置属性为 undefined 或者 null 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。 一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。 这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。","text":"Javascript秘密花园删除属性的唯一方法是使用 delete 操作符；设置属性为 undefined 或者 null 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。 一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。 这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。 构造函数在构造函数内部 - 也就是被调用的函数内 - this 指向新创建的对象 Object。 这个新创建的对象的 prototype 被指向到构造函数的 prototype。 如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 - 也就是新创建的对象。 ps: 什么之前修改一个实例的原型链上方法不会改变另一个实例方法。因为并没有真正改变原型链上的方法，改变的这个方法其实是写在这个实例自身上的。覆盖了原来的方法，如果用proto找到原型链上的方法改动，另一个也改了。 new Bar() 返回的是新创建的对象，而不是数字的字面值 2。 因此 new Bar().constructor === Bar，但是如果返回的是数字对象，结果就不同了，如下所示 1234function Bar() &#123; return new Number(2);&#125;new Bar().constructor === Number 用工厂模式替代构造函数1234567891011121314function Foo() &#123; var obj = &#123;&#125;; obj.value = 'blub'; var private = 2; obj.someMethod = function(value) &#123; this.value = value; &#125; obj.getPrivate = function() &#123; return private; &#125; return obj;&#125; 因为new其实就是隐式返回一个this指向的对象嘛，我自己返回一个对象。 虽然上面的方式比起 new 的调用方式不容易出错，并且可以充分利用私有变量带来的便利， 但是随之而来的是一些不好的地方。 会占用更多的内存，因为新创建的对象不能共享原型上的方法。 为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。 放弃原型链仅仅是因为防止遗漏 new 带来的问题，这似乎和语言本身的思想相违背。 Ps:如果 return 对象的左括号和 return 不在一行上就会出错。 数组123456var foo = [1, 2, 3, 4, 5, 6];foo.length = 3;foo; // [1, 2, 3]foo.length = 6;foo; // [1, 2, 3] 为了更好的性能，推荐使用普通的 for 循环并缓存数组的 length 属性。 使用 for in 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。 类型1234567891011121314151617Value Class Type-------------------------------------&quot;foo&quot; String stringnew String(&quot;foo&quot;) String object1.2 Number numbernew Number(1.2) Number objecttrue Boolean booleannew Boolean(true) Boolean objectnew Date() Date objectnew Error() Error object[1,2,3] Array objectnew Array(1, 2, 3) Array objectnew Function(&quot;&quot;) Function function/abc/g RegExp object (function in Nitro/V8)new RegExp(&quot;meow&quot;) RegExp object (function in Nitro/V8)&#123;&#125; Object objectnew Object() Object object 可以看出来大部分Type都收Object，我们用Object.prototype.toString.call(obj).slice(8, -1);来判断Class(“[object Array]”) setTimeout 和 setInterval当回调函数的执行被阻塞时，setInterval 仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。 解决方法： 12345function foo()&#123; // 阻塞执行 1 秒 setTimeout(foo, 100);&#125;foo(); 绝对不要使用字符串作为 setTimeout 或者 setInterval 的第一个参数， 这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。 另外，应该避免使用 setInterval，因为它的定时执行不会被 JavaScript 阻塞。 深入理解javascript—编写高质量代码和设计模式最小全局变量1var a = b = 0;//b就成了全局变量 隐式全局变量和明确定义的全局变量间有些小的差异，就是通过 delete 操作符让变量未定义的能力。 通过 var 创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过 delete 操作符删除的，而变量是不能的 访问全局变量123var global = (function () &#123; return this;&#125;()); 单 var 形式（Single var Pattern）在函数顶部使用单 var 语句是比较有用的一种形式，其好处在于： 提供了一个单一的地方去寻找功能所需要的所有局部变量 防止变量在定义之前使用的逻辑错误 帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的… 少代码（类型啊传值啊单线完成） 123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; for循环123456789function looper() &#123; var i = 0, max, myarray = []; // ... for (i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么 &#125;&#125; 循环中尽量不要每次去求长度，性能影响很多。 for…in在 for-in 中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的 for 循环，对象使用 for-in 循环。 字符串转换成数值123+\"08\" // 结果是 8Number(\"08\") // 8parseInt('08') //性能不行。因为不是简单的转化，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以 NaN 告终。 将声明变量和函数区分对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是 myFunction()， calculateArea()和 getFirstName()。 要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name， favorite_bands，和 old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。 全面解析 Module 模式引用全局变量首先我们来看看 Module 模式的基本特征： 模块化，可重用 封装了变量和 function，和全局的 namaspace 不接触，松耦合 只暴露可用 public 的方法，其它私有方法全部隐藏 先看一下最简单的一个实现，代码如下： 1234567891011var Calculator = function (eq) &#123; //这里可以声明私有成员 var eqCtl = document.getElementById(eq); return &#123; // 暴露公开的成员 add: function (x, y) &#123; var val = x + y; eqCtl.innerHTML = val; &#125; &#125;;&#125;; 关于闭包123456789101112131415(function ($, YAHOO) &#123; // 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样&#125; (jQuery, YAHOO));var blogModule = (function () &#123; var my = &#123;&#125;, privateName = \"博客园\"; function privateAddTopic(data) &#123; // 这里是内部处理代码 &#125; my.Name = privateName; my.AddTopic = function (data) &#123; privateAddTopic(data); &#125;; return my;&#125; ()); //将变量传入全局 扩展Module 模式的一个限制就是所有的代码都要写在一个文件，但是在一些大型项目里，将一个功能分离成多个文件是非常重要的，因为可以多人合作易于开发。 松散耦合扩展123456var blogModule = (function (my) &#123; my.AddPhoto = function () &#123; //添加内部代码 &#125;; return my;&#125; (blogModule|| &#123;&#125;)); //通过||可以保证结构 紧耦合扩展虽然松耦合扩展很牛叉了，但是可能也会存在一些限制，比如你没办法重写你的一些属性或者函数，也不能在初始化的时候就是用 Module 的属性。紧耦合扩展限制了加载顺序，但是提供了我们重载的机会，看如下例子： 1234567var blogModule = (function (my) &#123; var oldAddPhotoMethod = my.AddPhoto; my.AddPhoto = function () &#123; // 重载方法，依然可通过oldAddPhotoMethod调用旧的方法 &#125;; return my;&#125; (blogModule)); 通过这种方式，我们达到了重载的目的，当然如果你想在继续在内部使用原有的属性，你可以调用 oldAddPhotoMethod 来用。 子模块最后一个也是最简单的使用方式，那就是创建子模块 12345blogModule.CommentSubModule = (function () &#123; var my = &#123;&#125;; // ... return my;&#125; ()); 尽管非常简单，我还是把它放进来了，因为我想说明的是子模块也具有一般模块所有的高级使用方式，也就是说你可以对任意子模块再次使用上面的一些应用方法。 自执行函数function(){}() 这样为什么不行？因为在解析器解析全局的 function 或者 function 内部 function 关键字的时候，默认是认为 function 声明，而不是 function 表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的 function，并且抛出一个语法错误信息，因为 function 声明需要一个名字。 123456789// 下面这个function在语法上是没问题的，但是依然只是一个语句// 加上括号()以后依然会报错，因为分组操作符需要包含表达式function foo()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token )// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出// 但是foo函数依然不会执行function foo()&#123; /* code */ &#125;( 1 ); // 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式： function foo()&#123; /* code */ &#125; ( 1 ); 要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为 JavaScript 里括弧()里面不能包含语句，所以在这一点上，解析器在解析 function 关键字的时候，会将相应的代码解析成 function 表达式，而不是 function 声明。","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/centmaster/hexo-centmaster/tags/interview/"}]},{"title":"vue 1和2dom渲染的分析","slug":"v-dom","date":"2017-08-23T14:01:48.000Z","updated":"2017-09-13T14:30:03.000Z","comments":true,"path":"2017/08/23/v-dom/","link":"","permalink":"https://github.com/centmaster/hexo-centmaster/2017/08/23/v-dom/","excerpt":"vue1利用DocumentFragment渲染 _compile 部分分为三步 transclude compile link transcludetransclude的意思是内嵌，这个步骤会把你template里给出的模板转换成一段dom，然后抽取出你el选项指定的dom里的内容（即子元素，因为模板里可能有slot），把这段模板dom嵌入到el里面去，当然，如果replace为true，那他就是直接替换el，而不是内嵌。我们大概明白transclude这个名字的意义了，但其实更关键的是把template转换为dom的过程（如&lt;p&gt;&lt;p&gt;字符串转为真正的段落元素），这里为后面的编译准备好了dom。 说白了就是把字符串转换成dom compilecompile的的过程具体就是遍历模板解析出模板里的指令。更精确的说是解析后生成了指令描述对象。同时，compile函数是一个高阶函数，他执行完成之后的返回值是另一个函数：link，所以compile函数的第一个阶段是编译，返回出去的这个函数完成另一个阶段：link。 linkcompile阶段将指令解析成为指令描述对象(descriptor)，闭包在了link函数里，link函数会把descriptor传入Directive构造函数，创建出真正的指令实例。此外link函数是作为参数传入linkAndCaptrue中的，后者负责执行link，同时取出这些新生成的指令，先按照指令的预置的优先级从高到低排好顺序，然后遍历指令执行指令的_bind方法，这个方法会为指令创建watcher，并计算表达式的值，完成前面描述的依赖收集。并最后执行对应指令的bind和update方法，使指令生效、界面更新。","text":"vue1利用DocumentFragment渲染 _compile 部分分为三步 transclude compile link transcludetransclude的意思是内嵌，这个步骤会把你template里给出的模板转换成一段dom，然后抽取出你el选项指定的dom里的内容（即子元素，因为模板里可能有slot），把这段模板dom嵌入到el里面去，当然，如果replace为true，那他就是直接替换el，而不是内嵌。我们大概明白transclude这个名字的意义了，但其实更关键的是把template转换为dom的过程（如&lt;p&gt;&lt;p&gt;字符串转为真正的段落元素），这里为后面的编译准备好了dom。 说白了就是把字符串转换成dom compilecompile的的过程具体就是遍历模板解析出模板里的指令。更精确的说是解析后生成了指令描述对象。同时，compile函数是一个高阶函数，他执行完成之后的返回值是另一个函数：link，所以compile函数的第一个阶段是编译，返回出去的这个函数完成另一个阶段：link。 linkcompile阶段将指令解析成为指令描述对象(descriptor)，闭包在了link函数里，link函数会把descriptor传入Directive构造函数，创建出真正的指令实例。此外link函数是作为参数传入linkAndCaptrue中的，后者负责执行link，同时取出这些新生成的指令，先按照指令的预置的优先级从高到低排好顺序，然后遍历指令执行指令的_bind方法，这个方法会为指令创建watcher，并计算表达式的值，完成前面描述的依赖收集。并最后执行对应指令的bind和update方法，使指令生效、界面更新。 为什么dom的编译要分成compile和link两个phase。 在组件的多个实例、v-for数组等场合，我们会出现同一个段模板要绑定不同的数据然后分发到dom里面去的需求。这也是mvvm性能考量的主要场景：大数据量的重复渲染生成。而重复渲染的模板是一致的，不一致的是他们需要绑定的数据，因此compile阶段找出指令的过程是不用重复计算的，只需要link函数（和里面闭包的指令)，而模板生成的dom使用原生的cloneNode方法即可复制出一份新的dom。现在，复制出的新dom+ link+具体的数据即可完成渲染，所以分离compile、并缓存link使得Vue在渲染时避免大量重复的性能消耗。 vue2虚拟dom的解析和react几乎一样 Vue在2.0版本也引入了vdom。其vdom算法是基于snabbdom算法所做的修改。 Render—&gt;createElement—&gt;diff—&gt;patch 这是vdom的流程，让我看看每一步都做了什么 首先是vnode的定义1234567891011121314151617181920212223242526272829303132333435constructor ( tag?: string, data?: VNodeData, // 关于这个节点的data值，包括attrs,style,hook等 children?: ?Array&lt;VNode&gt;, // 子vdom节点 text?: string, // 文本内容 elm?: Node, // 真实的dom节点 context?: Component, // 创建这个vdom的上下文 componentOptions?: VNodeComponentOptions ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.functionalContext = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child (): Component | void &#123; return this.componentInstance &#125;&#125; 每一个vnode都映射到一个真实的dom节点上。其中几个比较重要的属性: tag 属性即这个vnode的标签属性 data 属性包含了最后渲染成真实dom节点后，节点上的class,attribute,style以及绑定的事件 children 属性是vnode的子节点 text 属性是文本属性 elm 属性为这个vnode对应的真实dom节点 key 属性是vnode的标记，在diff过程中可以提高diff的效率，后文有讲解 在当oldVnode不存在的时候，这个时候是root节点初始化的过程，因此调用了createElm(vnode, insertedVnodeQueue, parentElm, refElm)方法去创建一个新的节点。而当oldVnode是vnode且sameVnode(oldVnode, vnode)2个节点的基本属性相同，那么就进入了2个节点的diff过程。 diff过程12345678910111213141516171819202122232425const elm = vnode.elm = oldVnode.elm const oldCh = oldVnode.children const ch = vnode.children // 如果vnode没有文本节点 if (isUndef(vnode.text)) &#123; // 如果oldVnode的children属性存在且vnode的属性也存在 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // updateChildren，对子节点进行diff if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; // 如果oldVnode的text存在，那么首先清空text的内容 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') // 然后将vnode的children添加进去 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; // 删除elm下的oldchildren removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; // oldVnode有子节点，而vnode没有，那么就清空这个节点 nodeOps.setTextContent(elm, '') &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素 nodeOps.setTextContent(elm, vnode.text) &#125; 这其中的diff过程中又分了好几种情况，oldCh为oldVnode的子节点，ch为Vnode的子节点： 首先进行文本节点的判断，若oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换； 在vnode没有文本节点的情况下，进入子节点的diff； 当oldCh和ch都存在且不相同的情况下，调用updateChildren对子节点进行diff； 若oldCh不存在，ch存在，首先清空oldVnode的文本节点，同时调用addVnodes方法将ch添加到elm真实dom节点当中； 若oldCh存在，ch不存在，则删除elm真实节点下的oldCh子节点； 若oldVnode有文本节点，而vnode没有，那么就清空这个文本节点。 其中其他的都比较容易理解，我们要着重看一眼第三步的细节，也就是updateChildren过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; // 为oldCh和newCh分别建立索引，为之后遍历的依据 let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, elmToMove, refElm // 直到oldCh或者newCh被遍历完后跳出循环 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) // 插入到老的开始节点的前面 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 如果以上条件都不满足，那么这个时候开始比较key值，首先建立key和index索引的对应关系 if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null // 如果idxInOld不存在 // 1. newStartVnode上存在这个key,但是oldKeyToIdx中不存在 // 2. newStartVnode上并没有设置key属性 if (isUndef(idxInOld)) &#123; // New element // 创建新的dom节点 // 插入到oldStartVnode.elm前面 // 参见createElm方法 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !elmToMove) &#123; warn( 'It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.' ) // 将找到的key一致的oldVnode再和newStartVnode进行diff if (sameVnode(elmToMove, newStartVnode)) &#123; patchVnode(elmToMove, newStartVnode, insertedVnodeQueue) oldCh[idxInOld] = undefined // 移动node节点 canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; else &#123; // same key but different element. treat as new element // 创建新的dom节点 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; &#125; // 如果最后遍历的oldStartIdx大于oldEndIdx的话 if (oldStartIdx &gt; oldEndIdx) &#123; // 如果是老的vdom先被遍历完 refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm // 添加newVnode中剩余的节点到parentElm中 addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; // 如果是新的vdom先被遍历完，则删除oldVnode里面所有的节点 // 删除剩余的节点 removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 不带key标签的话，遍历完一遍以后有多余的就直接把节点删了。（不推荐，不细说） 在vnode不带key的情况下，每一轮的diff过程当中都是起始和结束节点进行比较，直到oldCh或者newCh被遍历完。而当为vnode引入key属性后，在每一轮的diff过程中，当起始和结束节点都没有找到sameVnode时，首先对oldCh中进行key值与索引的映射: 12if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null createKeyToOldIdx(src/core/vdom/patch.js)方法，用以将oldCh中的key属性作为键，而对应的节点的索引作为值。然后再判断在newStartVnode的属性中是否有key，且是否在oldKeyToIndx中找到对应的节点。 如果不存在这个key，那么就将这个newStartVnode作为新的节点创建且插入到原有的root的子节点中: 1234567if (isUndef(idxInOld)) &#123; // New element // 创建新的dom节点 // 插入到oldStartVnode.elm前面 // 参见createElm方法 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; 如果存在这个key，那么就取出oldCh中的存在这个key的vnode，然后再进行diff的过程: 123456789101112131415161718elmToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !elmToMove) &#123; // 将找到的key一致的oldVnode再和newStartVnode进行diff if (sameVnode(elmToMove, newStartVnode)) &#123; patchVnode(elmToMove, newStartVnode, insertedVnodeQueue) // 清空这个节点 oldCh[idxInOld] = undefined // 移动node节点 canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; else &#123; // same key but different element. treat as new element // 创建新的dom节点 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; 通过以上分析，给vdom上添加key属性后，遍历diff的过程中，当起始点, 结束点的搜寻及diff出现还是无法匹配的情况下时，就会用key来作为唯一标识，来进行diff，这样就可以提高diff效率。 注意在第一轮的diff过后oldCh上的B节点被删除了，但是newCh上的B节点上elm属性保持对oldCh上B节点的elm引用。 patch1234567891011121314function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) &#123; // 当oldVnode不存在时 if (isUndef(oldVnode)) &#123; // 创建新的节点 createElm(vnode, insertedVnodeQueue, parentElm, refElm) &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node // 对oldVnode和vnode进行diff，并对oldVnode打patch patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) &#125; &#125; &#125; 在对oldVnode和vnode类型判断中有个sameVnode方法，这个方法决定了是否需要对oldVnode和vnode进行diff及patch的过程。 123456789function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) )&#125; sameVnode会对传入的2个vnode进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个vnode只是局部发生了更新，然后才会对这2个vnode进行diff，如果2个vnode的基本属性存在不一致的情况，那么就会直接跳过diff的过程，进而依据vnode新建一个真实的dom，同时删除老的dom节点。","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"https://github.com/centmaster/hexo-centmaster/tags/mvvm/"}]}]}